<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX5EFF4EC48AEA467D8F319E3C1C981AC5">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">PackageManagerPlugin</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Script" referent="RBX69E40D195E3B4128BF923B783AA95C26">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Main</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{EE6CE10A-FC78-4DB1-A4B6-17A330B1C431}</string>
				<ProtectedString name="Source"><![CDATA[local plugin: Plugin = plugin

local UiInteraction = require(script.UIInterface)
local disguise = require(script.LuaUTypes).disguise
local UiElements = require(script.UiElements)
local SelectionCollection = require(script["@CHL/SelectionCollection"])

local toolbar = plugin:CreateToolbar('Package Manager')
local toolbarButton = toolbar:CreateButton("Open Gui", "", "rbxassetid://7734021469")

local dockWidget = plugin:CreateDockWidgetPluginGui(
	"__PackageManager", 
	DockWidgetPluginGuiInfo.new(
		Enum.InitialDockState.Float,
		false, 
		false, 
		518.5, 
		312.5, 
		250, 
		100
	)
)
dockWidget.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
dockWidget.Title = 'PackageManager'
dockWidget.Name = 'PackageManager'
UiInteraction:setWidget(dockWidget)

toolbarButton.Click:Connect(function()dockWidget.Enabled = not dockWidget.Enabled;end)

-- Main UI
local PackageManager = require(script.PackageManager)
local FileExporter = require(script.FileExporter)
local LuaTableImporter = require(script.LuaTableImporter)
local UIStack = require(script.UiStack)
local SoundFolder = require(script["@CHL/SoundFolder"])

local pManager: PackageManager.object = PackageManager.new()
local internalUIStack: UIStack.object = UIStack.new(disguise(UiInteraction.widget).Frame.Frame)
local frame = internalUIStack.frame
local backButton: TextButton = frame.Parent.TextLabel.TextLabel
local soundFolder = SoundFolder.new(disguise(UiInteraction.widget).Sounds)

CommonClick = soundFolder:getSound('CommonClick')
ErrorSound = soundFolder:getSound('Error')

-- module statics
UiElements.packageManager = pManager

-- internal uistack
internalUIStack.sizeMutated:Connect(function(n)backButton.Visible = n > 1 end)
backButton.MouseButton1Click:Connect(function()internalUIStack:pop()end)

-- menu
local menu = frame.Menu.Menu

for _, v:TextButton in next, menu:GetChildren() do
	if not v:IsA('TextButton') then continue end
	
	local referral = frame:FindFirstChild(v.Name)
	-- print(v.Name, referral.BackgroundTransparency, referral.Visible)
	referral.Visible = false
	
	v.MouseButton1Click:Connect(function()internalUIStack:push(referral)end)
end

internalUIStack:push(menu.Parent)

-- Library
local LibraryFrame = frame.Library
local LibraryCollection: Frame = LibraryFrame.Section.PackageList1
local LibrarySearchBar: TextBox = LibraryFrame.Search.Box
local LibraryClearText: ImageButton = LibraryFrame.Search.ClearText
local LibraryElement1: Frame = disguise(LibraryCollection).Element
local LibraryCollection2: Frame = LibraryFrame.SelectSection.PackageList1.PackageList1
local LibraryElement2: Frame = disguise(LibraryCollection2).Element
local LibrarySelectCollection: SelectionCollection.object<string> = 
	SelectionCollection.new()
local LibrarySelectionOptions = LibraryFrame.SelectSection.Options.ListInitOffset

LibraryFrame.Section.Visible = true
LibraryFrame.SelectSection.Visible = false

LibraryElement1.Parent = nil
UiElements.LibraryElement1.referral = LibraryElement1

LibraryElement2.Parent = nil
UiElements.LibraryElement2.referral = LibraryElement2

function addElement(package_struct)
	local c = UiElements.LibraryElement1.new(package_struct)
	
	c.frame.Parent = LibraryCollection
	c.clicked:Connect(function(...: any) CommonClick:Play()  end)
	c.selectInited:connect(function()
		CommonClick:Play()
		
		LibraryFrame.Section.Visible = false
		internalUIStack:push(LibraryFrame.SelectSection)
		LibraryFrame.Visible = true
		
		LibrarySelectCollection:turnAllButOneOff(package_struct.package.name)
		internalUIStack.sizeMutated:Once(function()LibraryFrame.Section.Visible=true;end)
	end)
	c.installFailed:Connect(function()ErrorSound:Play()end)
end
function addElement2(package_Struct: PackageManager.package_struct)
	local le2 = UiElements.LibraryElement2.new(package_Struct)
	LibrarySelectCollection:addSwitch(package_Struct.package.name, le2.selectBox)
	le2.frame.Parent = LibraryCollection2
	le2.selectBox.flicked:Connect(function(...: any)CommonClick:Play()  end)
end

function populateLibrary()
	-- for all lib 1
	for _, v in next, LibraryCollection:GetChildren() do
		if not v:IsA('UIGridLayout') then
			v:Destroy()
		end
	end
	
	-- for all lib 2
	for _, v in next, LibraryCollection2:GetChildren() do
		if not v:IsA('UIListLayout') then
			v:Destroy()
		end
	end
	
	-- fill
	for _, v in next, pManager.library do 
		addElement(v)
		addElement2(v)
	end
end

LibraryClearText.MouseButton1Click:Connect(function()LibrarySearchBar.Text = ''end)

LibrarySearchBar:GetPropertyChangedSignal('Text'):Connect(function()
	local find: string = LibrarySearchBar.Text:lower()
	for _, v in next, LibraryCollection:GetChildren() do
		if not v:IsA('Frame') then continue end;
		
		local text: string = v.Title.Text
		
		v.Visible = text:lower():find(find, nil, true)
	end
	
	for _, v in next, LibraryCollection2:GetChildren() do
		if not v:IsA('Frame') then continue end;

		local text: string = v.Title.Text

		v.Visible = text:lower():find(find, nil, true)
	end
end)

LibrarySelectionOptions.Install.MouseButton1Click:Connect(function()
	local pks = LibrarySelectCollection:getSwitched()
	
	for _, v in next, pks do
		pManager:loadPackage(v, true)
	end
	
	internalUIStack:pop()
end)

LibrarySelectionOptions.Uninstall.MouseButton1Click:Connect(function()
	local pks = LibrarySelectCollection:getSwitched()
	
	for _, v in next, pks do
		pManager:unloadPackage(v, true)
	end
	
	internalUIStack:pop()
end)

LibrarySelectionOptions.Reinstall.MouseButton1Click:Connect(function()
	local pks = LibrarySelectCollection:getSwitched()
	
	for _, v in next, pks do
		pManager:reloadPackage(v)
	end
	
	internalUIStack:pop()
end)

-- import
local ImportFrame = frame.Import
disguise((ImportFrame.PackageFile :: TextButton).MouseButton1Click:Connect(function()
	local success, content = LuaTableImporter.fileToTable()
	if not success then
		ErrorSound:Play()
		return warn(`Import Issue: {content}`)
	end
	
	for _, v in next, content do
		pManager:addPackageToLibrary(v)
	end
	populateLibrary()
	internalUIStack:pop()
end))

-- export
disguise(FileExporter).prompt = function()plugin:PromptSaveSelection('library')end
local ExportFrame = frame.Export
disguise((ExportFrame.PackageFile :: TextButton).MouseButton1Click:Connect(function()
	FileExporter.exportFileFromTable(pManager.exportOutput)
	internalUIStack:pop()
end))
disguise((ExportFrame.PackageFileV2 :: TextButton).MouseButton1Click:Connect(function()
	FileExporter.exportFile(pManager.pmsc:parseLibrary(pManager.exportOutput))
	internalUIStack:pop()
end))

-- add package
local AddPackageFrame = frame.AddPackage
disguise((AddPackageFrame.ModuleScript :: TextButton).MouseButton1Click:Connect(function()
	local ModuleScript = game:GetService('Selection'):Get()[1]
	if not ModuleScript or not ModuleScript:IsA('ModuleScript')then
		ErrorSound:Play()
		return warn('Attempting to add a package with a non-modulescript \z
			(based on first selected Instance)')
	end
	
	local success, content = LuaTableImporter.stringToTable(ModuleScript.Source)
	if not success then 
		ErrorSound:Play()
		return warn(`Adding Package Issue: script_reference=\z
			{ModuleScript:GetFullName()}|{content}`)
	end
	
	pManager:addPackageToLibrary(content)
	addElement(pManager.library[content.name])
	internalUIStack:pop()
end))

-- add repository
local AddRepository = frame.AddRepository
local IndexTextBox: TextBox = AddRepository.Index
IndexTextBox.FocusLost:Connect(function()
	local text = IndexTextBox.Text
	
	if pManager.repositories[text]then
		ErrorSound:Play()
		warn('attempting to overwrite a repository')
		IndexTextBox.PlaceholderText = `Attempting to overwrite a repo: {text}`
		IndexTextBox.Text = ''
		return;
	end
end)

disguise((AddRepository.Add :: TextButton).MouseButton1Click:Connect(function()
	local inst = game:GetService('Selection'):Get()[1]
	if not inst then
		ErrorSound:Play()
		return warn('Attempting to use nil as a repository')
	end
	
	pManager:addRepository(IndexTextBox.Text, inst)
	internalUIStack:pop()
end))

-- PackageManager
local PackageManagerFrame = disguise(frame).PackageManager

disguise((PackageManagerFrame.CheckObject::TextButton).MouseButton1Click:Connect(function()
	print(pManager)
end))

-- other ui interactions:
for _, v in UiInteraction.widget:GetDescendants() do
	if v:HasTag('__hasCommonClick') then
		if not v:IsA('GuiButton') then
			warn(`Attempting to use __hasCommonClick on button: {v:GetFullName()}`)
		else
			v.MouseButton1Click:Connect(function()
				CommonClick:Play()
			end)
		end
	end
end]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXB83EAD60780948F5BE945B38440D394D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">UIInterface</string>
					<string name="ScriptGuid">{092D7262-4414-4A00-BCBD-E171EEE05A47}</string>
					<ProtectedString name="Source"><![CDATA[local LuaUTypes = require(script.Parent.LuaUTypes)
local disguise = LuaUTypes.disguise

type __object = {
	gui: ScreenGui;
	widget: DockWidgetPluginGui;
	
	setWidget: (self:__object, DockWidgetPluginGui) -> nil;
	
}

local UIInterface: __object = disguise({})

UIInterface.gui = assert(script:FindFirstChildWhichIsA('ScreenGui'), 'Missing Gui to use.')

UIInterface.setWidget = function(self: __object, widget: DockWidgetPluginGui)
	self.widget = widget
	
	for _,c in next, self.gui:GetChildren() do
		local d=c:Clone()
		d.Parent = widget
		if d.Name == 'Frame'then
			d.Position = UDim2.new()
			d.Size = UDim2.fromScale(1,1)
			d.AnchorPoint = Vector2.new()
		end
	end
end

return UIInterface
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ScreenGui" referent="RBX6D6928A902E24D90A33CD0B23B8F3376">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="ClipToDeviceSafeArea">true</bool>
						<bool name="DefinesCapabilities">false</bool>
						<int name="DisplayOrder">0</int>
						<bool name="Enabled">true</bool>
						<string name="Name">Gui</string>
						<bool name="ResetOnSpawn">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SafeAreaCompatibility">1</token>
						<token name="ScreenInsets">2</token>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<token name="ZIndexBehavior">1</token>
					</Properties>
					<Item class="Frame" referent="RBX27412E63AB2D4C44A34AF5A53B2DA4CA">
						<Properties>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">1</int>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="ClipsDescendants">false</bool>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Draggable">false</bool>
							<bool name="Interactable">true</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">Frame</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">true</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="UICorner" referent="RBX6941F690A6E74DDFBD3C77BCBADF2FFE">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<UDim name="CornerRadius">
									<S>0</S>
									<O>8</O>
								</UDim>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX37AE642C889045F1961767FB3CC8B2E6">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0.0784313753</R>
									<G>0.0784313753</G>
									<B>0.0784313753</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">false</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/Inconsolata.json</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
									<CachedFaceId><url>rbxasset://fonts/Inconsolata-Regular.ttf</url></CachedFaceId>
								</Font>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<string name="LocalizationMatchIdentifier"></string>
								<string name="LocalizationMatchedSourceText"></string>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">TextLabel</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<string name="OpenTypeFeatures"></string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>5</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>-10</XO>
									<YS>0</YS>
									<YO>50</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">Package Manager</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="TextDirection">0</token>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UICorner" referent="RBX4197FD46681F4B8A9AF0180E414500AD">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<UDim name="CornerRadius">
										<S>0</S>
										<O>8</O>
									</UDim>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UICorner</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ImageButton" referent="RBX10CB0239216445C2891F6EAD9A9010EA">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">true</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.0784313753</R>
										<G>0.0784313753</G>
										<B>0.0784313753</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">false</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="HoverImage"><null></null></Content>
									<Content name="Image"><url>rbxassetid://7743874367</url></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<bool name="Modal">false</bool>
									<string name="Name">TextLabel</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>5</XO>
										<YS>0</YS>
										<YO>5</YO>
									</UDim2>
									<Content name="PressedImage"><null></null></Content>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">-90</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">false</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>-10</XO>
										<YS>1</YS>
										<YO>-10</YO>
									</UDim2>
									<token name="SizeConstraint">2</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
						<Item class="Frame" referent="RBXF958C67960F145AF84081EBE509F87FC">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>1</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0.0784313753</R>
									<G>0.0784313753</G>
									<B>0.0784313753</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="ClipsDescendants">true</bool>
								<bool name="DefinesCapabilities">false</bool>
								<bool name="Draggable">false</bool>
								<bool name="Interactable">true</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Frame</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>-5</XO>
									<YS>1</YS>
									<YO>-5</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>-10</XO>
									<YS>1</YS>
									<YO>-65</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="Frame" referent="RBX2FD4C63FD1D54CEFB13080CE379B40C1">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>1</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.0784313753</R>
										<G>0.0784313753</G>
										<B>0.0784313753</B>
									</Color3>
									<float name="BackgroundTransparency">2</float>
									<Color3 name="BorderColor3">
										<R>0.164705887</R>
										<G>0.262745112</G>
										<B>0.329411775</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">true</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">Library</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">true</bool>
									<int name="ZIndex">3</int>
								</Properties>
								<Item class="Frame" referent="RBX388AD91ACE3546BF95658AE04E8A57B7">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.0784313753</R>
											<G>0.0784313753</G>
											<B>0.0784313753</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0.164705887</R>
											<G>0.262745112</G>
											<B>0.329411775</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">true</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Section</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">true</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>-55</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">false</bool>
										<int name="ZIndex">3</int>
									</Properties>
									<Item class="ScrollingFrame" referent="RBX281017F325864A33AFEF6A10E226B133">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticCanvasSize">2</token>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0784313753</R>
												<G>0.0784313753</G>
												<B>0.0784313753</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0.164705887</R>
												<G>0.262745112</G>
												<B>0.329411775</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">0</int>
											<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url></Content>
											<Vector2 name="CanvasPosition">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<UDim2 name="CanvasSize">
												<XS>0</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="ClipsDescendants">true</bool>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Draggable">false</bool>
											<token name="ElasticBehavior">0</token>
											<token name="HorizontalScrollBarInset">0</token>
											<bool name="Interactable">true</bool>
											<int name="LayoutOrder">0</int>
											<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
											<string name="Name">PackageList1</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<Color3 name="ScrollBarImageColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="ScrollBarImageTransparency">0</float>
											<int name="ScrollBarThickness">12</int>
											<token name="ScrollingDirection">4</token>
											<bool name="ScrollingEnabled">true</bool>
											<bool name="Selectable">true</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">true</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>-10</XO>
												<YS>1</YS>
												<YO>-10</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-top.png</url></Content>
											<token name="VerticalScrollBarInset">0</token>
											<token name="VerticalScrollBarPosition">0</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">3</int>
										</Properties>
										<Item class="Frame" referent="RBXD13BB8B4EF4348BD9C33728563F03A58">
											<Properties>
												<bool name="Active">true</bool>
												<Vector2 name="AnchorPoint">
													<X>1</X>
													<Y>1</Y>
												</Vector2>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<bool name="AutoLocalize">true</bool>
												<token name="AutomaticSize">0</token>
												<Color3 name="BackgroundColor3">
													<R>0.0431372561</R>
													<G>0.0431372561</G>
													<B>0.0431372561</B>
												</Color3>
												<float name="BackgroundTransparency">0</float>
												<Color3 name="BorderColor3">
													<R>0.0588235296</R>
													<G>0.0588235296</G>
													<B>0.0588235296</B>
												</Color3>
												<token name="BorderMode">2</token>
												<int name="BorderSizePixel">1</int>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="ClipsDescendants">false</bool>
												<bool name="DefinesCapabilities">false</bool>
												<bool name="Draggable">false</bool>
												<bool name="Interactable">true</bool>
												<int name="LayoutOrder">0</int>
												<string name="Name">Element</string>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<UDim2 name="Position">
													<XS>1</XS>
													<XO>0</XO>
													<YS>1</YS>
													<YO>0</YO>
												</UDim2>
												<Ref name="RootLocalizationTable">null</Ref>
												<float name="Rotation">0</float>
												<bool name="Selectable">true</bool>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>1</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>50</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<int64 name="SourceAssetId">-1</int64>
												<token name="Style">0</token>
												<BinaryString name="Tags"></BinaryString>
												<bool name="Visible">true</bool>
												<int name="ZIndex">4</int>
											</Properties>
											<Item class="TextButton" referent="RBX4186183F3D4A4F498B66A4E99D8E29FF">
												<Properties>
													<bool name="Active">true</bool>
													<Vector2 name="AnchorPoint">
														<X>0.5</X>
														<Y>0.5</Y>
													</Vector2>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<bool name="AutoButtonColor">true</bool>
													<bool name="AutoLocalize">true</bool>
													<token name="AutomaticSize">0</token>
													<Color3 name="BackgroundColor3">
														<R>0.0784313753</R>
														<G>0.0784313753</G>
														<B>0.0784313753</B>
													</Color3>
													<float name="BackgroundTransparency">1</float>
													<Color3 name="BorderColor3">
														<R>0.0588235296</R>
														<G>0.0588235296</G>
														<B>0.0588235296</B>
													</Color3>
													<token name="BorderMode">2</token>
													<int name="BorderSizePixel">1</int>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="ClipsDescendants">false</bool>
													<bool name="DefinesCapabilities">false</bool>
													<bool name="Draggable">false</bool>
													<Font name="FontFace">
														<Family><url>rbxasset://fonts/families/Inconsolata.json</url></Family>
														<Weight>400</Weight>
														<Style>Normal</Style>
														<CachedFaceId><url>rbxasset://fonts/Inconsolata-Regular.ttf</url></CachedFaceId>
													</Font>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">0</int>
													<float name="LineHeight">1</float>
													<string name="LocalizationMatchIdentifier"></string>
													<string name="LocalizationMatchedSourceText"></string>
													<int name="MaxVisibleGraphemes">-1</int>
													<bool name="Modal">false</bool>
													<string name="Name">Title</string>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<string name="OpenTypeFeatures"></string>
													<UDim2 name="Position">
														<XS>0.5</XS>
														<XO>0</XO>
														<YS>0.5</YS>
														<YO>0</YO>
													</UDim2>
													<bool name="RichText">false</bool>
													<Ref name="RootLocalizationTable">null</Ref>
													<float name="Rotation">0</float>
													<bool name="Selectable">true</bool>
													<bool name="Selected">false</bool>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>1</XS>
														<XO>0</XO>
														<YS>1</YS>
														<YO>-100</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<int64 name="SourceAssetId">-1</int64>
													<token name="Style">0</token>
													<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
													<string name="Text">Title</string>
													<Color3 name="TextColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<token name="TextDirection">0</token>
													<bool name="TextScaled">true</bool>
													<float name="TextSize">14</float>
													<Color3 name="TextStrokeColor3">
														<R>0</R>
														<G>0</G>
														<B>1</B>
													</Color3>
													<float name="TextStrokeTransparency">1</float>
													<float name="TextTransparency">0</float>
													<token name="TextTruncate">0</token>
													<bool name="TextWrapped">true</bool>
													<token name="TextXAlignment">2</token>
													<token name="TextYAlignment">1</token>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
												</Properties>
											</Item>
											<Item class="TextButton" referent="RBXE2E9EE30A80F460E829B056498701694">
												<Properties>
													<bool name="Active">true</bool>
													<Vector2 name="AnchorPoint">
														<X>1</X>
														<Y>1</Y>
													</Vector2>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<bool name="AutoButtonColor">true</bool>
													<bool name="AutoLocalize">true</bool>
													<token name="AutomaticSize">0</token>
													<Color3 name="BackgroundColor3">
														<R>0.0784313753</R>
														<G>0.0784313753</G>
														<B>0.0784313753</B>
													</Color3>
													<float name="BackgroundTransparency">1</float>
													<Color3 name="BorderColor3">
														<R>0.0588235296</R>
														<G>0.0588235296</G>
														<B>0.0588235296</B>
													</Color3>
													<token name="BorderMode">2</token>
													<int name="BorderSizePixel">1</int>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="ClipsDescendants">false</bool>
													<bool name="DefinesCapabilities">false</bool>
													<bool name="Draggable">false</bool>
													<Font name="FontFace">
														<Family><url>rbxasset://fonts/families/Inconsolata.json</url></Family>
														<Weight>400</Weight>
														<Style>Normal</Style>
														<CachedFaceId><url>rbxasset://fonts/Inconsolata-Regular.ttf</url></CachedFaceId>
													</Font>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">0</int>
													<float name="LineHeight">1</float>
													<string name="LocalizationMatchIdentifier"></string>
													<string name="LocalizationMatchedSourceText"></string>
													<int name="MaxVisibleGraphemes">-1</int>
													<bool name="Modal">false</bool>
													<string name="Name">Install</string>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<string name="OpenTypeFeatures"></string>
													<UDim2 name="Position">
														<XS>1</XS>
														<XO>0</XO>
														<YS>1</YS>
														<YO>0</YO>
													</UDim2>
													<bool name="RichText">false</bool>
													<Ref name="RootLocalizationTable">null</Ref>
													<float name="Rotation">0</float>
													<bool name="Selectable">true</bool>
													<bool name="Selected">false</bool>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>1</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>50</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<int64 name="SourceAssetId">-1</int64>
													<token name="Style">0</token>
													<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
													<string name="Text">Install</string>
													<Color3 name="TextColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<token name="TextDirection">0</token>
													<bool name="TextScaled">true</bool>
													<float name="TextSize">14</float>
													<Color3 name="TextStrokeColor3">
														<R>0</R>
														<G>1</G>
														<B>0</B>
													</Color3>
													<float name="TextStrokeTransparency">0</float>
													<float name="TextTransparency">0</float>
													<token name="TextTruncate">0</token>
													<bool name="TextWrapped">true</bool>
													<token name="TextXAlignment">2</token>
													<token name="TextYAlignment">1</token>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
												</Properties>
											</Item>
											<Item class="UICorner" referent="RBXFB9F60A118D7414BA2ED7A29B84FCBB7">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<UDim name="CornerRadius">
														<S>0</S>
														<O>8</O>
													</UDim>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">UICorner</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ImageButton" referent="RBX1BE57EFA64624A47B35FA4927385C777">
												<Properties>
													<bool name="Active">true</bool>
													<Vector2 name="AnchorPoint">
														<X>1</X>
														<Y>0</Y>
													</Vector2>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<bool name="AutoButtonColor">true</bool>
													<bool name="AutoLocalize">true</bool>
													<token name="AutomaticSize">0</token>
													<Color3 name="BackgroundColor3">
														<R>0.741176486</R>
														<G>0.741176486</G>
														<B>0.741176486</B>
													</Color3>
													<float name="BackgroundTransparency">1</float>
													<Color3 name="BorderColor3">
														<R>0.0588235296</R>
														<G>0.0588235296</G>
														<B>0.0588235296</B>
													</Color3>
													<token name="BorderMode">2</token>
													<int name="BorderSizePixel">1</int>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="ClipsDescendants">false</bool>
													<bool name="DefinesCapabilities">false</bool>
													<bool name="Draggable">false</bool>
													<Content name="HoverImage"><null></null></Content>
													<Content name="Image"><url>rbxassetid://7743872181</url></Content>
													<Color3 name="ImageColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<Vector2 name="ImageRectOffset">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<Vector2 name="ImageRectSize">
														<X>0</X>
														<Y>0</Y>
													</Vector2>
													<float name="ImageTransparency">0</float>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">0</int>
													<bool name="Modal">false</bool>
													<string name="Name">Select</string>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<UDim2 name="Position">
														<XS>1</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>0</YO>
													</UDim2>
													<Content name="PressedImage"><null></null></Content>
													<token name="ResampleMode">0</token>
													<Ref name="RootLocalizationTable">null</Ref>
													<float name="Rotation">0</float>
													<token name="ScaleType">0</token>
													<bool name="Selectable">true</bool>
													<bool name="Selected">false</bool>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>0</XS>
														<XO>50</XO>
														<YS>0</YS>
														<YO>50</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<Rect2D name="SliceCenter">
														<min>
															<X>0</X>
															<Y>0</Y>
														</min>
														<max>
															<X>0</X>
															<Y>0</Y>
														</max>
													</Rect2D>
													<float name="SliceScale">1</float>
													<int64 name="SourceAssetId">-1</int64>
													<token name="Style">0</token>
													<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
													<UDim2 name="TileSize">
														<XS>1</XS>
														<XO>0</XO>
														<YS>1</YS>
														<YO>0</YO>
													</UDim2>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
												</Properties>
											</Item>
										</Item>
										<Item class="UIGridLayout" referent="RBX6F410335A59A4257B5BE4B104FD4ED82">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<UDim2 name="CellPadding">
													<XS>0</XS>
													<XO>10</XO>
													<YS>0</YS>
													<YO>10</YO>
												</UDim2>
												<UDim2 name="CellSize">
													<XS>0</XS>
													<XO>200</XO>
													<YS>0</YS>
													<YO>200</YO>
												</UDim2>
												<bool name="DefinesCapabilities">false</bool>
												<token name="FillDirection">0</token>
												<int name="FillDirectionMaxCells">0</int>
												<token name="HorizontalAlignment">0</token>
												<string name="Name">UIGridLayout</string>
												<token name="SortOrder">2</token>
												<int64 name="SourceAssetId">-1</int64>
												<token name="StartCorner">0</token>
												<BinaryString name="Tags"></BinaryString>
												<token name="VerticalAlignment">1</token>
											</Properties>
										</Item>
									</Item>
									<Item class="UICorner" referent="RBX60F2214ADFCA45A79484763282AAA400">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<UDim name="CornerRadius">
												<S>0</S>
												<O>8</O>
											</UDim>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">UICorner</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
								<Item class="Frame" referent="RBXD3394F6FA02443929116D194697B9976">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.0784313753</R>
											<G>0.0784313753</G>
											<B>0.0784313753</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.164705887</R>
											<G>0.262745112</G>
											<B>0.329411775</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">true</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">SelectSection</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">true</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>-55</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">3</int>
									</Properties>
									<Item class="UICorner" referent="RBX6B10BF563DD447568DFF701196478DD7">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<UDim name="CornerRadius">
												<S>0</S>
												<O>8</O>
											</UDim>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">UICorner</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Frame" referent="RBX4BA8F4B8F9EC45AE95E9A5502DEB5646">
										<Properties>
											<bool name="Active">false</bool>
											<Vector2 name="AnchorPoint">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0784313753</R>
												<G>0.0784313753</G>
												<B>0.0784313753</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>0.105882362</R>
												<G>0.164705887</G>
												<B>0.207843155</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">1</int>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="ClipsDescendants">false</bool>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Draggable">false</bool>
											<bool name="Interactable">true</bool>
											<int name="LayoutOrder">0</int>
											<string name="Name">Options</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0</XS>
												<XO>0</XO>
												<YS>0</YS>
												<YO>0</YO>
											</UDim2>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>0</XO>
												<YS>0</YS>
												<YO>50</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
										<Item class="UICorner" referent="RBX3AE199D7C7E044E3A2E7E49C65368BD6">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<UDim name="CornerRadius">
													<S>0</S>
													<O>8</O>
												</UDim>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">UICorner</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="Frame" referent="RBX478E64930BF041F1B437116AFCF36A8D">
											<Properties>
												<bool name="Active">false</bool>
												<Vector2 name="AnchorPoint">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<bool name="AutoLocalize">true</bool>
												<token name="AutomaticSize">0</token>
												<Color3 name="BackgroundColor3">
													<R>0.0784313753</R>
													<G>0.0784313753</G>
													<B>0.0784313753</B>
												</Color3>
												<float name="BackgroundTransparency">1</float>
												<Color3 name="BorderColor3">
													<R>0.105882362</R>
													<G>0.164705887</G>
													<B>0.207843155</B>
												</Color3>
												<token name="BorderMode">0</token>
												<int name="BorderSizePixel">1</int>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="ClipsDescendants">false</bool>
												<bool name="DefinesCapabilities">false</bool>
												<bool name="Draggable">false</bool>
												<bool name="Interactable">true</bool>
												<int name="LayoutOrder">0</int>
												<string name="Name">ListInitOffset</string>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<UDim2 name="Position">
													<XS>0</XS>
													<XO>5</XO>
													<YS>0</YS>
													<YO>0</YO>
												</UDim2>
												<Ref name="RootLocalizationTable">null</Ref>
												<float name="Rotation">0</float>
												<bool name="Selectable">false</bool>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>1</XS>
													<XO>0</XO>
													<YS>0</YS>
													<YO>50</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<int64 name="SourceAssetId">-1</int64>
												<token name="Style">0</token>
												<BinaryString name="Tags"></BinaryString>
												<bool name="Visible">true</bool>
												<int name="ZIndex">1</int>
											</Properties>
											<Item class="UICorner" referent="RBXE1AA3EB557B5416DA6BD7D3A63690766">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<UDim name="CornerRadius">
														<S>0</S>
														<O>8</O>
													</UDim>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">UICorner</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="UIListLayout" referent="RBXE1130EC053B047DA9EDE00EF7F6AE244">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<token name="FillDirection">0</token>
													<token name="HorizontalAlignment">1</token>
													<token name="HorizontalFlex">0</token>
													<token name="ItemLineAlignment">0</token>
													<string name="Name">UIListLayout</string>
													<UDim name="Padding">
														<S>0</S>
														<O>5</O>
													</UDim>
													<token name="SortOrder">2</token>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
													<token name="VerticalAlignment">0</token>
													<token name="VerticalFlex">0</token>
													<bool name="Wraps">false</bool>
												</Properties>
											</Item>
											<Item class="ImageButton" referent="RBX030F64F632A84D92955ECB4FF83AC2F3">
												<Properties>
													<bool name="Active">false</bool>
													<Vector2 name="AnchorPoint">
														<X>0.5</X>
														<Y>0.5</Y>
													</Vector2>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<bool name="AutoButtonColor">true</bool>
													<bool name="AutoLocalize">true</bool>
													<token name="AutomaticSize">0</token>
													<Color3 name="BackgroundColor3">
														<R>0.0784313753</R>
														<G>0.0784313753</G>
														<B>0.0784313753</B>
													</Color3>
													<float name="BackgroundTransparency">1</float>
													<Color3 name="BorderColor3">
														<R>0.105882362</R>
														<G>0.164705887</G>
														<B>0.207843155</B>
													</Color3>
													<token name="BorderMode">0</token>
													<int name="BorderSizePixel">1</int>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="ClipsDescendants">false</bool>
													<bool name="DefinesCapabilities">false</bool>
													<bool name="Draggable">false</bool>
													<Content name="HoverImage"><null></null></Content>
													<Content name="Image"><url>rbxassetid://15269177520</url></Content>
													<Color3 name="ImageColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<Vector2 name="ImageRectOffset">
														<X>869</X>
														<Y>857</Y>
													</Vector2>
													<Vector2 name="ImageRectSize">
														<X>48</X>
														<Y>48</Y>
													</Vector2>
													<float name="ImageTransparency">0</float>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">2</int>
													<bool name="Modal">false</bool>
													<string name="Name">Uninstall</string>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<UDim2 name="Position">
														<XS>0</XS>
														<XO>75</XO>
														<YS>0</YS>
														<YO>25</YO>
													</UDim2>
													<Content name="PressedImage"><null></null></Content>
													<token name="ResampleMode">0</token>
													<Ref name="RootLocalizationTable">null</Ref>
													<float name="Rotation">0</float>
													<token name="ScaleType">0</token>
													<bool name="Selectable">false</bool>
													<bool name="Selected">false</bool>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>0</XS>
														<XO>45</XO>
														<YS>0</YS>
														<YO>45</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<Rect2D name="SliceCenter">
														<min>
															<X>0</X>
															<Y>0</Y>
														</min>
														<max>
															<X>0</X>
															<Y>0</Y>
														</max>
													</Rect2D>
													<float name="SliceScale">1</float>
													<int64 name="SourceAssetId">-1</int64>
													<token name="Style">0</token>
													<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
													<UDim2 name="TileSize">
														<XS>1</XS>
														<XO>0</XO>
														<YS>1</YS>
														<YO>0</YO>
													</UDim2>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
												</Properties>
												<Item class="UICorner" referent="RBX403694355BAA4E7CB326C1748DDE9DCD">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<UDim name="CornerRadius">
															<S>0</S>
															<O>8</O>
														</UDim>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">UICorner</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
											<Item class="ImageButton" referent="RBXA549327C458D4DCBAFF88D3ACE0ADEB9">
												<Properties>
													<bool name="Active">false</bool>
													<Vector2 name="AnchorPoint">
														<X>0.5</X>
														<Y>0.5</Y>
													</Vector2>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<bool name="AutoButtonColor">true</bool>
													<bool name="AutoLocalize">true</bool>
													<token name="AutomaticSize">0</token>
													<Color3 name="BackgroundColor3">
														<R>0.0784313753</R>
														<G>0.0784313753</G>
														<B>0.0784313753</B>
													</Color3>
													<float name="BackgroundTransparency">1</float>
													<Color3 name="BorderColor3">
														<R>0.105882362</R>
														<G>0.164705887</G>
														<B>0.207843155</B>
													</Color3>
													<token name="BorderMode">0</token>
													<int name="BorderSizePixel">1</int>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="ClipsDescendants">false</bool>
													<bool name="DefinesCapabilities">false</bool>
													<bool name="Draggable">false</bool>
													<Content name="HoverImage"><null></null></Content>
													<Content name="Image"><url>rbxassetid://15269177328</url></Content>
													<Color3 name="ImageColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<Vector2 name="ImageRectOffset">
														<X>967</X>
														<Y>612</Y>
													</Vector2>
													<Vector2 name="ImageRectSize">
														<X>48</X>
														<Y>48</Y>
													</Vector2>
													<float name="ImageTransparency">0</float>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">3</int>
													<bool name="Modal">false</bool>
													<string name="Name">Reinstall</string>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<UDim2 name="Position">
														<XS>0</XS>
														<XO>125</XO>
														<YS>0</YS>
														<YO>25</YO>
													</UDim2>
													<Content name="PressedImage"><null></null></Content>
													<token name="ResampleMode">0</token>
													<Ref name="RootLocalizationTable">null</Ref>
													<float name="Rotation">0</float>
													<token name="ScaleType">0</token>
													<bool name="Selectable">false</bool>
													<bool name="Selected">false</bool>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>0</XS>
														<XO>45</XO>
														<YS>0</YS>
														<YO>45</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<Rect2D name="SliceCenter">
														<min>
															<X>0</X>
															<Y>0</Y>
														</min>
														<max>
															<X>0</X>
															<Y>0</Y>
														</max>
													</Rect2D>
													<float name="SliceScale">1</float>
													<int64 name="SourceAssetId">-1</int64>
													<token name="Style">0</token>
													<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
													<UDim2 name="TileSize">
														<XS>1</XS>
														<XO>0</XO>
														<YS>1</YS>
														<YO>0</YO>
													</UDim2>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
												</Properties>
												<Item class="UICorner" referent="RBX22DD405B29C9482FA1B4D2F0E318C4CF">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<UDim name="CornerRadius">
															<S>0</S>
															<O>8</O>
														</UDim>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">UICorner</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
											<Item class="ImageButton" referent="RBX49A883C64F4D4002AD4AF523C0AA3045">
												<Properties>
													<bool name="Active">false</bool>
													<Vector2 name="AnchorPoint">
														<X>0.5</X>
														<Y>0.5</Y>
													</Vector2>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<bool name="AutoButtonColor">true</bool>
													<bool name="AutoLocalize">true</bool>
													<token name="AutomaticSize">0</token>
													<Color3 name="BackgroundColor3">
														<R>0.0784313753</R>
														<G>0.0784313753</G>
														<B>0.0784313753</B>
													</Color3>
													<float name="BackgroundTransparency">1</float>
													<Color3 name="BorderColor3">
														<R>0.105882362</R>
														<G>0.164705887</G>
														<B>0.207843155</B>
													</Color3>
													<token name="BorderMode">0</token>
													<int name="BorderSizePixel">1</int>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="ClipsDescendants">false</bool>
													<bool name="DefinesCapabilities">false</bool>
													<bool name="Draggable">false</bool>
													<Content name="HoverImage"><null></null></Content>
													<Content name="Image"><url>rbxassetid://15269176792</url></Content>
													<Color3 name="ImageColor3">
														<R>1</R>
														<G>1</G>
														<B>1</B>
													</Color3>
													<Vector2 name="ImageRectOffset">
														<X>661</X>
														<Y>820</Y>
													</Vector2>
													<Vector2 name="ImageRectSize">
														<X>48</X>
														<Y>48</Y>
													</Vector2>
													<float name="ImageTransparency">0</float>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">1</int>
													<bool name="Modal">false</bool>
													<string name="Name">Install</string>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<UDim2 name="Position">
														<XS>0</XS>
														<XO>25</XO>
														<YS>0</YS>
														<YO>25</YO>
													</UDim2>
													<Content name="PressedImage"><null></null></Content>
													<token name="ResampleMode">0</token>
													<Ref name="RootLocalizationTable">null</Ref>
													<float name="Rotation">0</float>
													<token name="ScaleType">0</token>
													<bool name="Selectable">false</bool>
													<bool name="Selected">false</bool>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>0</XS>
														<XO>45</XO>
														<YS>0</YS>
														<YO>45</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<Rect2D name="SliceCenter">
														<min>
															<X>0</X>
															<Y>0</Y>
														</min>
														<max>
															<X>0</X>
															<Y>0</Y>
														</max>
													</Rect2D>
													<float name="SliceScale">1</float>
													<int64 name="SourceAssetId">-1</int64>
													<token name="Style">0</token>
													<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
													<UDim2 name="TileSize">
														<XS>1</XS>
														<XO>0</XO>
														<YS>1</YS>
														<YO>0</YO>
													</UDim2>
													<bool name="Visible">true</bool>
													<int name="ZIndex">1</int>
												</Properties>
												<Item class="UICorner" referent="RBXE3AB2719B75C4FDA83D3903F6213F241">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<UDim name="CornerRadius">
															<S>0</S>
															<O>8</O>
														</UDim>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">UICorner</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
										</Item>
									</Item>
									<Item class="Frame" referent="RBX20EAF0C461BE48629AFCD39A85203220">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0</X>
												<Y>1</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0784313753</R>
												<G>0.0784313753</G>
												<B>0.0784313753</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>0.164705887</R>
												<G>0.262745112</G>
												<B>0.329411775</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">0</int>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="ClipsDescendants">true</bool>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Draggable">false</bool>
											<bool name="Interactable">true</bool>
											<int name="LayoutOrder">0</int>
											<string name="Name">PackageList1</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">true</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>-55</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<bool name="Visible">true</bool>
											<int name="ZIndex">3</int>
										</Properties>
										<Item class="UICorner" referent="RBXBF4EA3790AB34208AF9AD2B035180DB3">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<UDim name="CornerRadius">
													<S>0</S>
													<O>8</O>
												</UDim>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">UICorner</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ScrollingFrame" referent="RBX8372E1B8F47C49388A754A9AB20F02F7">
											<Properties>
												<bool name="Active">true</bool>
												<Vector2 name="AnchorPoint">
													<X>0.5</X>
													<Y>0.5</Y>
												</Vector2>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<bool name="AutoLocalize">true</bool>
												<token name="AutomaticCanvasSize">2</token>
												<token name="AutomaticSize">0</token>
												<Color3 name="BackgroundColor3">
													<R>0.0784313753</R>
													<G>0.0784313753</G>
													<B>0.0784313753</B>
												</Color3>
												<float name="BackgroundTransparency">1</float>
												<Color3 name="BorderColor3">
													<R>0.164705887</R>
													<G>0.262745112</G>
													<B>0.329411775</B>
												</Color3>
												<token name="BorderMode">0</token>
												<int name="BorderSizePixel">0</int>
												<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url></Content>
												<Vector2 name="CanvasPosition">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<UDim2 name="CanvasSize">
													<XS>0</XS>
													<XO>0</XO>
													<YS>1</YS>
													<YO>0</YO>
												</UDim2>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="ClipsDescendants">true</bool>
												<bool name="DefinesCapabilities">false</bool>
												<bool name="Draggable">false</bool>
												<token name="ElasticBehavior">0</token>
												<token name="HorizontalScrollBarInset">0</token>
												<bool name="Interactable">true</bool>
												<int name="LayoutOrder">0</int>
												<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
												<string name="Name">PackageList1</string>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<UDim2 name="Position">
													<XS>0.5</XS>
													<XO>0</XO>
													<YS>0.5</YS>
													<YO>0</YO>
												</UDim2>
												<Ref name="RootLocalizationTable">null</Ref>
												<float name="Rotation">0</float>
												<Color3 name="ScrollBarImageColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<float name="ScrollBarImageTransparency">0</float>
												<int name="ScrollBarThickness">12</int>
												<token name="ScrollingDirection">4</token>
												<bool name="ScrollingEnabled">true</bool>
												<bool name="Selectable">true</bool>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">true</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>1</XS>
													<XO>0</XO>
													<YS>1</YS>
													<YO>0</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-top.png</url></Content>
												<token name="VerticalScrollBarInset">0</token>
												<token name="VerticalScrollBarPosition">0</token>
												<bool name="Visible">true</bool>
												<int name="ZIndex">3</int>
											</Properties>
											<Item class="UIListLayout" referent="RBX66638AF1C482490B93E72969B66FD17F">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<token name="FillDirection">1</token>
													<token name="HorizontalAlignment">1</token>
													<token name="HorizontalFlex">0</token>
													<token name="ItemLineAlignment">0</token>
													<string name="Name">UIListLayout</string>
													<UDim name="Padding">
														<S>0</S>
														<O>0</O>
													</UDim>
													<token name="SortOrder">2</token>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
													<token name="VerticalAlignment">1</token>
													<token name="VerticalFlex">0</token>
													<bool name="Wraps">false</bool>
												</Properties>
											</Item>
											<Item class="Frame" referent="RBX74BBB2A14D2C4FA49969EC09F74E5850">
												<Properties>
													<bool name="Active">true</bool>
													<Vector2 name="AnchorPoint">
														<X>1</X>
														<Y>1</Y>
													</Vector2>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<bool name="AutoLocalize">true</bool>
													<token name="AutomaticSize">0</token>
													<Color3 name="BackgroundColor3">
														<R>0.0431372561</R>
														<G>0.0431372561</G>
														<B>0.0431372561</B>
													</Color3>
													<float name="BackgroundTransparency">0</float>
													<Color3 name="BorderColor3">
														<R>0.0588235296</R>
														<G>0.0588235296</G>
														<B>0.0588235296</B>
													</Color3>
													<token name="BorderMode">2</token>
													<int name="BorderSizePixel">1</int>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="ClipsDescendants">false</bool>
													<bool name="DefinesCapabilities">false</bool>
													<bool name="Draggable">false</bool>
													<bool name="Interactable">true</bool>
													<int name="LayoutOrder">1</int>
													<string name="Name">Element</string>
													<Ref name="NextSelectionDown">null</Ref>
													<Ref name="NextSelectionLeft">null</Ref>
													<Ref name="NextSelectionRight">null</Ref>
													<Ref name="NextSelectionUp">null</Ref>
													<UDim2 name="Position">
														<XS>1</XS>
														<XO>0</XO>
														<YS>1</YS>
														<YO>0</YO>
													</UDim2>
													<Ref name="RootLocalizationTable">null</Ref>
													<float name="Rotation">0</float>
													<bool name="Selectable">true</bool>
													<token name="SelectionBehaviorDown">0</token>
													<token name="SelectionBehaviorLeft">0</token>
													<token name="SelectionBehaviorRight">0</token>
													<token name="SelectionBehaviorUp">0</token>
													<bool name="SelectionGroup">false</bool>
													<Ref name="SelectionImageObject">null</Ref>
													<int name="SelectionOrder">0</int>
													<UDim2 name="Size">
														<XS>1</XS>
														<XO>0</XO>
														<YS>0</YS>
														<YO>50</YO>
													</UDim2>
													<token name="SizeConstraint">0</token>
													<int64 name="SourceAssetId">-1</int64>
													<token name="Style">0</token>
													<BinaryString name="Tags"></BinaryString>
													<bool name="Visible">true</bool>
													<int name="ZIndex">4</int>
												</Properties>
												<Item class="TextButton" referent="RBXB588B9194316438D95527D19D6531DB2">
													<Properties>
														<bool name="Active">true</bool>
														<Vector2 name="AnchorPoint">
															<X>0</X>
															<Y>0</Y>
														</Vector2>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<bool name="AutoButtonColor">true</bool>
														<bool name="AutoLocalize">true</bool>
														<token name="AutomaticSize">0</token>
														<Color3 name="BackgroundColor3">
															<R>0.0784313753</R>
															<G>0.0784313753</G>
															<B>0.0784313753</B>
														</Color3>
														<float name="BackgroundTransparency">1</float>
														<Color3 name="BorderColor3">
															<R>0.0588235296</R>
															<G>0.0588235296</G>
															<B>0.0588235296</B>
														</Color3>
														<token name="BorderMode">2</token>
														<int name="BorderSizePixel">1</int>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="ClipsDescendants">false</bool>
														<bool name="DefinesCapabilities">false</bool>
														<bool name="Draggable">false</bool>
														<Font name="FontFace">
															<Family><url>rbxasset://fonts/families/Inconsolata.json</url></Family>
															<Weight>400</Weight>
															<Style>Normal</Style>
															<CachedFaceId><url>rbxasset://fonts/Inconsolata-Regular.ttf</url></CachedFaceId>
														</Font>
														<bool name="Interactable">true</bool>
														<int name="LayoutOrder">0</int>
														<float name="LineHeight">1</float>
														<string name="LocalizationMatchIdentifier"></string>
														<string name="LocalizationMatchedSourceText"></string>
														<int name="MaxVisibleGraphemes">-1</int>
														<bool name="Modal">false</bool>
														<string name="Name">Title</string>
														<Ref name="NextSelectionDown">null</Ref>
														<Ref name="NextSelectionLeft">null</Ref>
														<Ref name="NextSelectionRight">null</Ref>
														<Ref name="NextSelectionUp">null</Ref>
														<string name="OpenTypeFeatures"></string>
														<UDim2 name="Position">
															<XS>0</XS>
															<XO>50</XO>
															<YS>0</YS>
															<YO>0</YO>
														</UDim2>
														<bool name="RichText">false</bool>
														<Ref name="RootLocalizationTable">null</Ref>
														<float name="Rotation">0</float>
														<bool name="Selectable">true</bool>
														<bool name="Selected">false</bool>
														<token name="SelectionBehaviorDown">0</token>
														<token name="SelectionBehaviorLeft">0</token>
														<token name="SelectionBehaviorRight">0</token>
														<token name="SelectionBehaviorUp">0</token>
														<bool name="SelectionGroup">false</bool>
														<Ref name="SelectionImageObject">null</Ref>
														<int name="SelectionOrder">0</int>
														<UDim2 name="Size">
															<XS>1</XS>
															<XO>-50</XO>
															<YS>1</YS>
															<YO>0</YO>
														</UDim2>
														<token name="SizeConstraint">0</token>
														<int64 name="SourceAssetId">-1</int64>
														<token name="Style">0</token>
														<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
														<string name="Text">Title</string>
														<Color3 name="TextColor3">
															<R>1</R>
															<G>1</G>
															<B>1</B>
														</Color3>
														<token name="TextDirection">0</token>
														<bool name="TextScaled">true</bool>
														<float name="TextSize">14</float>
														<Color3 name="TextStrokeColor3">
															<R>0</R>
															<G>0</G>
															<B>1</B>
														</Color3>
														<float name="TextStrokeTransparency">1</float>
														<float name="TextTransparency">0</float>
														<token name="TextTruncate">0</token>
														<bool name="TextWrapped">true</bool>
														<token name="TextXAlignment">0</token>
														<token name="TextYAlignment">1</token>
														<bool name="Visible">true</bool>
														<int name="ZIndex">1</int>
													</Properties>
												</Item>
												<Item class="UICorner" referent="RBX200E464C18FC423E955F1C1E31C68032">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<UDim name="CornerRadius">
															<S>0</S>
															<O>8</O>
														</UDim>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">UICorner</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
												<Item class="Frame" referent="RBX8EA23A0C8E04436581F4575F30FF9408">
													<Properties>
														<bool name="Active">true</bool>
														<Vector2 name="AnchorPoint">
															<X>0.5</X>
															<Y>0.5</Y>
														</Vector2>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<bool name="AutoLocalize">true</bool>
														<token name="AutomaticSize">0</token>
														<Color3 name="BackgroundColor3">
															<R>0.741176486</R>
															<G>0.741176486</G>
															<B>0.741176486</B>
														</Color3>
														<float name="BackgroundTransparency">1</float>
														<Color3 name="BorderColor3">
															<R>0.0588235296</R>
															<G>0.0588235296</G>
															<B>0.0588235296</B>
														</Color3>
														<token name="BorderMode">2</token>
														<int name="BorderSizePixel">1</int>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="ClipsDescendants">false</bool>
														<bool name="DefinesCapabilities">false</bool>
														<bool name="Draggable">false</bool>
														<bool name="Interactable">true</bool>
														<int name="LayoutOrder">0</int>
														<string name="Name">Select</string>
														<Ref name="NextSelectionDown">null</Ref>
														<Ref name="NextSelectionLeft">null</Ref>
														<Ref name="NextSelectionRight">null</Ref>
														<Ref name="NextSelectionUp">null</Ref>
														<UDim2 name="Position">
															<XS>0</XS>
															<XO>25</XO>
															<YS>0.5</YS>
															<YO>0</YO>
														</UDim2>
														<Ref name="RootLocalizationTable">null</Ref>
														<float name="Rotation">0</float>
														<bool name="Selectable">true</bool>
														<token name="SelectionBehaviorDown">0</token>
														<token name="SelectionBehaviorLeft">0</token>
														<token name="SelectionBehaviorRight">0</token>
														<token name="SelectionBehaviorUp">0</token>
														<bool name="SelectionGroup">false</bool>
														<Ref name="SelectionImageObject">null</Ref>
														<int name="SelectionOrder">0</int>
														<UDim2 name="Size">
															<XS>0</XS>
															<XO>50</XO>
															<YS>0</YS>
															<YO>50</YO>
														</UDim2>
														<token name="SizeConstraint">0</token>
														<int64 name="SourceAssetId">-1</int64>
														<token name="Style">0</token>
														<BinaryString name="Tags"></BinaryString>
														<bool name="Visible">true</bool>
														<int name="ZIndex">1</int>
													</Properties>
													<Item class="ImageButton" referent="RBX23B3561DF651404A9EE2EFEFF8D90FD7">
														<Properties>
															<bool name="Active">true</bool>
															<Vector2 name="AnchorPoint">
																<X>0</X>
																<Y>0</Y>
															</Vector2>
															<BinaryString name="AttributesSerialize"></BinaryString>
															<bool name="AutoButtonColor">true</bool>
															<bool name="AutoLocalize">true</bool>
															<token name="AutomaticSize">0</token>
															<Color3 name="BackgroundColor3">
																<R>1</R>
																<G>1</G>
																<B>1</B>
															</Color3>
															<float name="BackgroundTransparency">1</float>
															<Color3 name="BorderColor3">
																<R>0.0588235296</R>
																<G>0.0588235296</G>
																<B>0.0588235296</B>
															</Color3>
															<token name="BorderMode">2</token>
															<int name="BorderSizePixel">1</int>
															<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
															<bool name="ClipsDescendants">false</bool>
															<bool name="DefinesCapabilities">false</bool>
															<bool name="Draggable">false</bool>
															<Content name="HoverImage"><null></null></Content>
															<Content name="Image"><url>rbxassetid://7733919526</url></Content>
															<Color3 name="ImageColor3">
																<R>1</R>
																<G>1</G>
																<B>1</B>
															</Color3>
															<Vector2 name="ImageRectOffset">
																<X>0</X>
																<Y>0</Y>
															</Vector2>
															<Vector2 name="ImageRectSize">
																<X>0</X>
																<Y>0</Y>
															</Vector2>
															<float name="ImageTransparency">0</float>
															<bool name="Interactable">true</bool>
															<int name="LayoutOrder">0</int>
															<bool name="Modal">false</bool>
															<string name="Name">Selected</string>
															<Ref name="NextSelectionDown">null</Ref>
															<Ref name="NextSelectionLeft">null</Ref>
															<Ref name="NextSelectionRight">null</Ref>
															<Ref name="NextSelectionUp">null</Ref>
															<UDim2 name="Position">
																<XS>0</XS>
																<XO>0</XO>
																<YS>0</YS>
																<YO>0</YO>
															</UDim2>
															<Content name="PressedImage"><null></null></Content>
															<token name="ResampleMode">0</token>
															<Ref name="RootLocalizationTable">null</Ref>
															<float name="Rotation">0</float>
															<token name="ScaleType">0</token>
															<bool name="Selectable">true</bool>
															<bool name="Selected">false</bool>
															<token name="SelectionBehaviorDown">0</token>
															<token name="SelectionBehaviorLeft">0</token>
															<token name="SelectionBehaviorRight">0</token>
															<token name="SelectionBehaviorUp">0</token>
															<bool name="SelectionGroup">false</bool>
															<Ref name="SelectionImageObject">null</Ref>
															<int name="SelectionOrder">0</int>
															<UDim2 name="Size">
																<XS>1</XS>
																<XO>0</XO>
																<YS>1</YS>
																<YO>0</YO>
															</UDim2>
															<token name="SizeConstraint">0</token>
															<Rect2D name="SliceCenter">
																<min>
																	<X>0</X>
																	<Y>0</Y>
																</min>
																<max>
																	<X>0</X>
																	<Y>0</Y>
																</max>
															</Rect2D>
															<float name="SliceScale">1</float>
															<int64 name="SourceAssetId">-1</int64>
															<token name="Style">0</token>
															<BinaryString name="Tags"></BinaryString>
															<UDim2 name="TileSize">
																<XS>1</XS>
																<XO>0</XO>
																<YS>1</YS>
																<YO>0</YO>
															</UDim2>
															<bool name="Visible">true</bool>
															<int name="ZIndex">1</int>
														</Properties>
													</Item>
													<Item class="ImageButton" referent="RBX151C2F6399204421A3A8A496F9F1C219">
														<Properties>
															<bool name="Active">true</bool>
															<Vector2 name="AnchorPoint">
																<X>0</X>
																<Y>0</Y>
															</Vector2>
															<BinaryString name="AttributesSerialize"></BinaryString>
															<bool name="AutoButtonColor">true</bool>
															<bool name="AutoLocalize">true</bool>
															<token name="AutomaticSize">0</token>
															<Color3 name="BackgroundColor3">
																<R>1</R>
																<G>1</G>
																<B>1</B>
															</Color3>
															<float name="BackgroundTransparency">1</float>
															<Color3 name="BorderColor3">
																<R>0.0588235296</R>
																<G>0.0588235296</G>
																<B>0.0588235296</B>
															</Color3>
															<token name="BorderMode">2</token>
															<int name="BorderSizePixel">1</int>
															<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
															<bool name="ClipsDescendants">false</bool>
															<bool name="DefinesCapabilities">false</bool>
															<bool name="Draggable">false</bool>
															<Content name="HoverImage"><null></null></Content>
															<Content name="Image"><url>rbxassetid://7743872181</url></Content>
															<Color3 name="ImageColor3">
																<R>1</R>
																<G>1</G>
																<B>1</B>
															</Color3>
															<Vector2 name="ImageRectOffset">
																<X>0</X>
																<Y>0</Y>
															</Vector2>
															<Vector2 name="ImageRectSize">
																<X>0</X>
																<Y>0</Y>
															</Vector2>
															<float name="ImageTransparency">0</float>
															<bool name="Interactable">true</bool>
															<int name="LayoutOrder">0</int>
															<bool name="Modal">false</bool>
															<string name="Name">Unselected</string>
															<Ref name="NextSelectionDown">null</Ref>
															<Ref name="NextSelectionLeft">null</Ref>
															<Ref name="NextSelectionRight">null</Ref>
															<Ref name="NextSelectionUp">null</Ref>
															<UDim2 name="Position">
																<XS>0</XS>
																<XO>0</XO>
																<YS>0</YS>
																<YO>0</YO>
															</UDim2>
															<Content name="PressedImage"><null></null></Content>
															<token name="ResampleMode">0</token>
															<Ref name="RootLocalizationTable">null</Ref>
															<float name="Rotation">0</float>
															<token name="ScaleType">0</token>
															<bool name="Selectable">true</bool>
															<bool name="Selected">false</bool>
															<token name="SelectionBehaviorDown">0</token>
															<token name="SelectionBehaviorLeft">0</token>
															<token name="SelectionBehaviorRight">0</token>
															<token name="SelectionBehaviorUp">0</token>
															<bool name="SelectionGroup">false</bool>
															<Ref name="SelectionImageObject">null</Ref>
															<int name="SelectionOrder">0</int>
															<UDim2 name="Size">
																<XS>1</XS>
																<XO>0</XO>
																<YS>1</YS>
																<YO>0</YO>
															</UDim2>
															<token name="SizeConstraint">0</token>
															<Rect2D name="SliceCenter">
																<min>
																	<X>0</X>
																	<Y>0</Y>
																</min>
																<max>
																	<X>0</X>
																	<Y>0</Y>
																</max>
															</Rect2D>
															<float name="SliceScale">1</float>
															<int64 name="SourceAssetId">-1</int64>
															<token name="Style">0</token>
															<BinaryString name="Tags"></BinaryString>
															<UDim2 name="TileSize">
																<XS>1</XS>
																<XO>0</XO>
																<YS>1</YS>
																<YO>0</YO>
															</UDim2>
															<bool name="Visible">false</bool>
															<int name="ZIndex">1</int>
														</Properties>
													</Item>
												</Item>
											</Item>
										</Item>
									</Item>
								</Item>
								<Item class="Frame" referent="RBXB47F89B3F9EF49B8B30D44F951BB932B">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.0784313753</R>
											<G>0.0784313753</G>
											<B>0.0784313753</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Search</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>50</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="UICorner" referent="RBX232BAFECE83A46DD8060261E2A2C7343">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<UDim name="CornerRadius">
												<S>0</S>
												<O>8</O>
											</UDim>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">UICorner</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="TextBox" referent="RBXFABB80117D16479FB59919DF833CBCAA">
										<Properties>
											<bool name="Active">false</bool>
											<Vector2 name="AnchorPoint">
												<X>1</X>
												<Y>1</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0784313753</R>
												<G>0.0784313753</G>
												<B>0.0784313753</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>0.105882362</R>
												<G>0.164705887</G>
												<B>0.207843155</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">1</int>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="ClearTextOnFocus">false</bool>
											<bool name="ClipsDescendants">false</bool>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Draggable">false</bool>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Inconsolata.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Inconsolata-Regular.ttf</url></CachedFaceId>
											</Font>
											<bool name="Interactable">true</bool>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<string name="LocalizationMatchIdentifier"></string>
											<string name="LocalizationMatchedSourceText"></string>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="MultiLine">false</bool>
											<string name="Name">Box</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<string name="OpenTypeFeatures"></string>
											<Color3 name="PlaceholderColor3">
												<R>0.699999988</R>
												<G>0.699999988</G>
												<B>0.699999988</B>
											</Color3>
											<string name="PlaceholderText">Package Name Here</string>
											<UDim2 name="Position">
												<XS>1</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<bool name="ShowNativeInput">true</bool>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>-50</XO>
												<YS>0</YS>
												<YO>50</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text"></string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="TextDirection">0</token>
											<bool name="TextEditable">true</bool>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">14</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">0</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
										<Item class="UICorner" referent="RBX3568E945DACD463FAF4D802FD5D01C0F">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<UDim name="CornerRadius">
													<S>0</S>
													<O>8</O>
												</UDim>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">UICorner</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
									<Item class="ImageButton" referent="RBX8BE30DDDA6D94248B7AE207020A3C2AD">
										<Properties>
											<bool name="Active">false</bool>
											<Vector2 name="AnchorPoint">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0784313753</R>
												<G>0.0784313753</G>
												<B>0.0784313753</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0.105882362</R>
												<G>0.164705887</G>
												<B>0.207843155</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">1</int>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="ClipsDescendants">false</bool>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Draggable">false</bool>
											<Content name="HoverImage"><null></null></Content>
											<Content name="Image"><url>rbxassetid://15269177723</url></Content>
											<Color3 name="ImageColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<Vector2 name="ImageRectOffset">
												<X>710</X>
												<Y>771</Y>
											</Vector2>
											<Vector2 name="ImageRectSize">
												<X>48</X>
												<Y>48</Y>
											</Vector2>
											<float name="ImageTransparency">0</float>
											<bool name="Interactable">true</bool>
											<int name="LayoutOrder">0</int>
											<bool name="Modal">false</bool>
											<string name="Name">ClearText</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0</XS>
												<XO>0</XO>
												<YS>0</YS>
												<YO>0</YO>
											</UDim2>
											<Content name="PressedImage"><null></null></Content>
											<token name="ResampleMode">0</token>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<token name="ScaleType">0</token>
											<bool name="Selectable">false</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0</XS>
												<XO>50</XO>
												<YS>0</YS>
												<YO>50</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<Rect2D name="SliceCenter">
												<min>
													<X>0</X>
													<Y>0</Y>
												</min>
												<max>
													<X>0</X>
													<Y>0</Y>
												</max>
											</Rect2D>
											<float name="SliceScale">1</float>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
											<UDim2 name="TileSize">
												<XS>1</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
										<Item class="UICorner" referent="RBXC80B58FA1583475ABA2E03520E8D7C43">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<UDim name="CornerRadius">
													<S>0</S>
													<O>8</O>
												</UDim>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">UICorner</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
							</Item>
							<Item class="Frame" referent="RBX9A1FD1976AA74B3487816D5A0B2D67B7">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.0784313753</R>
										<G>0.0784313753</G>
										<B>0.0784313753</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0.164705887</R>
										<G>0.262745112</G>
										<B>0.329411775</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">true</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">AddPackage</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">false</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIListLayout" referent="RBX749F0E35C46F480C846AF0120C81FC64">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<token name="FillDirection">1</token>
										<token name="HorizontalAlignment">1</token>
										<token name="HorizontalFlex">0</token>
										<token name="ItemLineAlignment">0</token>
										<string name="Name">UIGridLayout</string>
										<UDim name="Padding">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="SortOrder">2</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<token name="VerticalAlignment">1</token>
										<token name="VerticalFlex">0</token>
										<bool name="Wraps">false</bool>
									</Properties>
								</Item>
								<Item class="TextButton" referent="RBX2D72B58A8935441CB8E0FB51569814C9">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoButtonColor">true</bool>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.0784313753</R>
											<G>0.0784313753</G>
											<B>0.0784313753</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.0588235296</R>
											<G>0.0588235296</G>
											<B>0.0588235296</B>
										</Color3>
										<token name="BorderMode">2</token>
										<int name="BorderSizePixel">1</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Inconsolata.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Inconsolata-Regular.ttf</url></CachedFaceId>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<bool name="Modal">false</bool>
										<string name="Name">ModuleScript</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<bool name="Selected">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>50</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
										<string name="Text">By ModuleScript</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>1</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="UICorner" referent="RBX4C393077F20A489FB991781D6EB13A1C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<UDim name="CornerRadius">
											<S>0</S>
											<O>8</O>
										</UDim>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">UICorner</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBXA2A3127EC2CB45FC8C9699594ABA772C">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.0784313753</R>
										<G>0.0784313753</G>
										<B>0.0784313753</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0.164705887</R>
										<G>0.262745112</G>
										<B>0.329411775</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">true</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">AddRepository</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">false</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIListLayout" referent="RBX2A63F0CB4C1C4F178682B8174ECC38C3">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<token name="FillDirection">1</token>
										<token name="HorizontalAlignment">1</token>
										<token name="HorizontalFlex">0</token>
										<token name="ItemLineAlignment">0</token>
										<string name="Name">UIGridLayout</string>
										<UDim name="Padding">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="SortOrder">2</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<token name="VerticalAlignment">1</token>
										<token name="VerticalFlex">0</token>
										<bool name="Wraps">false</bool>
									</Properties>
								</Item>
								<Item class="TextButton" referent="RBX40A6CACBCDD24045B5180357123E71DF">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoButtonColor">true</bool>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.0784313753</R>
											<G>0.0784313753</G>
											<B>0.0784313753</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.0588235296</R>
											<G>0.0588235296</G>
											<B>0.0588235296</B>
										</Color3>
										<token name="BorderMode">2</token>
										<int name="BorderSizePixel">1</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Inconsolata.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Inconsolata-Regular.ttf</url></CachedFaceId>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">2</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<bool name="Modal">false</bool>
										<string name="Name">Add</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<bool name="Selected">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>50</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
										<string name="Text">Add</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>1</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextBox" referent="RBX37F5718165BC434A95FFA97FD442881A">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.0784313753</R>
											<G>0.0784313753</G>
											<B>0.0784313753</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.0588235296</R>
											<G>0.0588235296</G>
											<B>0.0588235296</B>
										</Color3>
										<token name="BorderMode">2</token>
										<int name="BorderSizePixel">1</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClearTextOnFocus">false</bool>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Inconsolata.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Inconsolata-Regular.ttf</url></CachedFaceId>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">1</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<bool name="MultiLine">false</bool>
										<string name="Name">Index</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<Color3 name="PlaceholderColor3">
											<R>0.290196091</R>
											<G>0.290196091</G>
											<B>0.290196091</B>
										</Color3>
										<string name="PlaceholderText">Repository Name</string>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<bool name="ShowNativeInput">true</bool>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>50</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text"></string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextEditable">true</bool>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>1</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="UICorner" referent="RBX311BD8C1E78F4E5D9C62060B28ED2C3F">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<UDim name="CornerRadius">
											<S>0</S>
											<O>8</O>
										</UDim>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">UICorner</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBXA9161566C30A43799A42C50D9D8C63D7">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.0784313753</R>
										<G>0.0784313753</G>
										<B>0.0784313753</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0.164705887</R>
										<G>0.262745112</G>
										<B>0.329411775</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">true</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">Export</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">false</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIListLayout" referent="RBX2FB1200827D845EBB477533264468ADF">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<token name="FillDirection">1</token>
										<token name="HorizontalAlignment">1</token>
										<token name="HorizontalFlex">0</token>
										<token name="ItemLineAlignment">0</token>
										<string name="Name">UIGridLayout</string>
										<UDim name="Padding">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="SortOrder">2</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<token name="VerticalAlignment">1</token>
										<token name="VerticalFlex">0</token>
										<bool name="Wraps">false</bool>
									</Properties>
								</Item>
								<Item class="TextButton" referent="RBX001CDE28401D4B15BC4B094AB76026BD">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoButtonColor">true</bool>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.0784313753</R>
											<G>0.0784313753</G>
											<B>0.0784313753</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.0588235296</R>
											<G>0.0588235296</G>
											<B>0.0588235296</B>
										</Color3>
										<token name="BorderMode">2</token>
										<int name="BorderSizePixel">1</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Inconsolata.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Inconsolata-Regular.ttf</url></CachedFaceId>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<bool name="Modal">false</bool>
										<string name="Name">PackageFile</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<bool name="Selected">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>50</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
										<string name="Text">To Package File (.lua)</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>1</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="UICorner" referent="RBXAE19D18A3CA640EF97765C9337EBA109">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<UDim name="CornerRadius">
											<S>0</S>
											<O>8</O>
										</UDim>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">UICorner</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextButton" referent="RBX40ACDBFE05A54590A8616AEF05FD17F5">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoButtonColor">true</bool>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.0784313753</R>
											<G>0.0784313753</G>
											<B>0.0784313753</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.0588235296</R>
											<G>0.0588235296</G>
											<B>0.0588235296</B>
										</Color3>
										<token name="BorderMode">2</token>
										<int name="BorderSizePixel">1</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Inconsolata.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Inconsolata-Regular.ttf</url></CachedFaceId>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<bool name="Modal">false</bool>
										<string name="Name">PackageFileV2</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<bool name="Selected">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>50</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
										<string name="Text">To Package File (.lua) (V2)</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>1</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBXFC42933FB8CC43E89C0D85BBD4EB65DA">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.0784313753</R>
										<G>0.0784313753</G>
										<B>0.0784313753</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0.164705887</R>
										<G>0.262745112</G>
										<B>0.329411775</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">true</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">Import</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">false</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIListLayout" referent="RBX9BF1BDE232304FAFB87FCA96828B576B">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<token name="FillDirection">1</token>
										<token name="HorizontalAlignment">1</token>
										<token name="HorizontalFlex">0</token>
										<token name="ItemLineAlignment">0</token>
										<string name="Name">UIGridLayout</string>
										<UDim name="Padding">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="SortOrder">2</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<token name="VerticalAlignment">1</token>
										<token name="VerticalFlex">0</token>
										<bool name="Wraps">false</bool>
									</Properties>
								</Item>
								<Item class="TextButton" referent="RBX4F12466846B6469CA0759E433BE54ED4">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoButtonColor">true</bool>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.0784313753</R>
											<G>0.0784313753</G>
											<B>0.0784313753</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.0588235296</R>
											<G>0.0588235296</G>
											<B>0.0588235296</B>
										</Color3>
										<token name="BorderMode">2</token>
										<int name="BorderSizePixel">1</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Inconsolata.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Inconsolata-Regular.ttf</url></CachedFaceId>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<bool name="Modal">false</bool>
										<string name="Name">PackageFile</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<bool name="Selected">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>50</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
										<string name="Text">Via Package File</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>1</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="UICorner" referent="RBXC62F8CD9C30C4D208D0D327A734353F7">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<UDim name="CornerRadius">
											<S>0</S>
											<O>8</O>
										</UDim>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">UICorner</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBX0243BDACBCE84A02831C7FAB572790DC">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>1</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.0784313753</R>
										<G>0.0784313753</G>
										<B>0.0784313753</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0.164705887</R>
										<G>0.262745112</G>
										<B>0.329411775</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">true</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">Menu</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">false</bool>
									<int name="ZIndex">3</int>
								</Properties>
								<Item class="ScrollingFrame" referent="RBX8C44989EA8054E7D94960DAFA110B69D">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticCanvasSize">2</token>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.0784313753</R>
											<G>0.0784313753</G>
											<B>0.0784313753</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.164705887</R>
											<G>0.262745112</G>
											<B>0.329411775</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url></Content>
										<Vector2 name="CanvasPosition">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<UDim2 name="CanvasSize">
											<XS>0</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<token name="ElasticBehavior">0</token>
										<token name="HorizontalScrollBarInset">0</token>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
										<string name="Name">Menu</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<Color3 name="ScrollBarImageColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="ScrollBarImageTransparency">0</float>
										<int name="ScrollBarThickness">12</int>
										<token name="ScrollingDirection">2</token>
										<bool name="ScrollingEnabled">true</bool>
										<bool name="Selectable">true</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">true</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-top.png</url></Content>
										<token name="VerticalScrollBarInset">2</token>
										<token name="VerticalScrollBarPosition">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">4</int>
									</Properties>
									<Item class="UIListLayout" referent="RBX5FF8DE4683D940D883BB5CC6A60D9174">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<token name="FillDirection">1</token>
											<token name="HorizontalAlignment">1</token>
											<token name="HorizontalFlex">2</token>
											<token name="ItemLineAlignment">2</token>
											<string name="Name">UIGridLayout</string>
											<UDim name="Padding">
												<S>0</S>
												<O>0</O>
											</UDim>
											<token name="SortOrder">2</token>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<token name="VerticalAlignment">1</token>
											<token name="VerticalFlex">0</token>
											<bool name="Wraps">false</bool>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBX2A25BE27EB2E45D7B86FF53F75A04C95">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0784313753</R>
												<G>0.0784313753</G>
												<B>0.0784313753</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0.0588235296</R>
												<G>0.0588235296</G>
												<B>0.0588235296</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">1</int>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="ClipsDescendants">false</bool>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Draggable">false</bool>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Inconsolata.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Inconsolata-Regular.ttf</url></CachedFaceId>
											</Font>
											<bool name="Interactable">true</bool>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<string name="LocalizationMatchIdentifier"></string>
											<string name="LocalizationMatchedSourceText"></string>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">Import</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<string name="OpenTypeFeatures"></string>
											<UDim2 name="Position">
												<XS>1</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>0</XO>
												<YS>0</YS>
												<YO>50</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
											<string name="Text">Import</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="TextDirection">0</token>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">14</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>1</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">4</int>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBX40B33A4073B84218995E0E7723A8CA47">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0784313753</R>
												<G>0.0784313753</G>
												<B>0.0784313753</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0.0588235296</R>
												<G>0.0588235296</G>
												<B>0.0588235296</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">1</int>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="ClipsDescendants">false</bool>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Draggable">false</bool>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Inconsolata.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Inconsolata-Regular.ttf</url></CachedFaceId>
											</Font>
											<bool name="Interactable">true</bool>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<string name="LocalizationMatchIdentifier"></string>
											<string name="LocalizationMatchedSourceText"></string>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">Export</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<string name="OpenTypeFeatures"></string>
											<UDim2 name="Position">
												<XS>1</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>0</XO>
												<YS>0</YS>
												<YO>50</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
											<string name="Text">Export</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="TextDirection">0</token>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">14</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>1</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">4</int>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBXD14C3A587A22485E9A439672054D057B">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0784313753</R>
												<G>0.0784313753</G>
												<B>0.0784313753</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0.0588235296</R>
												<G>0.0588235296</G>
												<B>0.0588235296</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">1</int>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="ClipsDescendants">false</bool>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Draggable">false</bool>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Inconsolata.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Inconsolata-Regular.ttf</url></CachedFaceId>
											</Font>
											<bool name="Interactable">true</bool>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<string name="LocalizationMatchIdentifier"></string>
											<string name="LocalizationMatchedSourceText"></string>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">AddPackage</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<string name="OpenTypeFeatures"></string>
											<UDim2 name="Position">
												<XS>1</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>0</XO>
												<YS>0</YS>
												<YO>50</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
											<string name="Text">Add Package</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="TextDirection">0</token>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">14</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>1</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">4</int>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBX69B8E22905704AEFB9C6A0B923391EE0">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0784313753</R>
												<G>0.0784313753</G>
												<B>0.0784313753</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0.0588235296</R>
												<G>0.0588235296</G>
												<B>0.0588235296</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">1</int>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="ClipsDescendants">false</bool>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Draggable">false</bool>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Inconsolata.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Inconsolata-Regular.ttf</url></CachedFaceId>
											</Font>
											<bool name="Interactable">true</bool>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<string name="LocalizationMatchIdentifier"></string>
											<string name="LocalizationMatchedSourceText"></string>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">AddRepository</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<string name="OpenTypeFeatures"></string>
											<UDim2 name="Position">
												<XS>1</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>0</XO>
												<YS>0</YS>
												<YO>50</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
											<string name="Text">Add Repository</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="TextDirection">0</token>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">14</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>1</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">4</int>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBX440122C2E8A7401CAFF991FF50575244">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0784313753</R>
												<G>0.0784313753</G>
												<B>0.0784313753</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0.0588235296</R>
												<G>0.0588235296</G>
												<B>0.0588235296</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">1</int>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="ClipsDescendants">false</bool>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Draggable">false</bool>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Inconsolata.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Inconsolata-Regular.ttf</url></CachedFaceId>
											</Font>
											<bool name="Interactable">true</bool>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<string name="LocalizationMatchIdentifier"></string>
											<string name="LocalizationMatchedSourceText"></string>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">Library</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<string name="OpenTypeFeatures"></string>
											<UDim2 name="Position">
												<XS>1</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>0</XO>
												<YS>0</YS>
												<YO>50</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
											<string name="Text">Library</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="TextDirection">0</token>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">14</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>1</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">4</int>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBX52DF149F0E284FDD8E1A27FED5E85AC7">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0784313753</R>
												<G>0.0784313753</G>
												<B>0.0784313753</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0.0588235296</R>
												<G>0.0588235296</G>
												<B>0.0588235296</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">1</int>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="ClipsDescendants">false</bool>
											<bool name="DefinesCapabilities">false</bool>
											<bool name="Draggable">false</bool>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Inconsolata.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Inconsolata-Regular.ttf</url></CachedFaceId>
											</Font>
											<bool name="Interactable">true</bool>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<string name="LocalizationMatchIdentifier"></string>
											<string name="LocalizationMatchedSourceText"></string>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">PackageManager</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<string name="OpenTypeFeatures"></string>
											<UDim2 name="Position">
												<XS>1</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>0</XO>
												<YS>0</YS>
												<YO>50</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
											<string name="Text">PackageManager</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="TextDirection">0</token>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">14</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>1</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">4</int>
										</Properties>
									</Item>
								</Item>
								<Item class="UICorner" referent="RBX62404434035B42AAA2AC50036C9C45B9">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<UDim name="CornerRadius">
											<S>0</S>
											<O>8</O>
										</UDim>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">UICorner</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBX7B68D31E2D254EF68C0ECC12A789DC75">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.0784313753</R>
										<G>0.0784313753</G>
										<B>0.0784313753</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0.164705887</R>
										<G>0.262745112</G>
										<B>0.329411775</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="ClipsDescendants">true</bool>
									<bool name="DefinesCapabilities">false</bool>
									<bool name="Draggable">false</bool>
									<bool name="Interactable">true</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">PackageManager</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">false</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIListLayout" referent="RBXE1D7361CC9A943168D2AF8AD2F51F992">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<token name="FillDirection">1</token>
										<token name="HorizontalAlignment">1</token>
										<token name="HorizontalFlex">0</token>
										<token name="ItemLineAlignment">0</token>
										<string name="Name">UIGridLayout</string>
										<UDim name="Padding">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="SortOrder">2</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<token name="VerticalAlignment">1</token>
										<token name="VerticalFlex">0</token>
										<bool name="Wraps">false</bool>
									</Properties>
								</Item>
								<Item class="TextButton" referent="RBX1BE938CB193A4CE4B015FC320F2C6846">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoButtonColor">true</bool>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.0784313753</R>
											<G>0.0784313753</G>
											<B>0.0784313753</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.0588235296</R>
											<G>0.0588235296</G>
											<B>0.0588235296</B>
										</Color3>
										<token name="BorderMode">2</token>
										<int name="BorderSizePixel">1</int>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="ClipsDescendants">false</bool>
										<bool name="DefinesCapabilities">false</bool>
										<bool name="Draggable">false</bool>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Inconsolata.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Inconsolata-Regular.ttf</url></CachedFaceId>
										</Font>
										<bool name="Interactable">true</bool>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<string name="LocalizationMatchIdentifier"></string>
										<string name="LocalizationMatchedSourceText"></string>
										<int name="MaxVisibleGraphemes">-1</int>
										<bool name="Modal">false</bool>
										<string name="Name">CheckObject</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<string name="OpenTypeFeatures"></string>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<bool name="Selected">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>50</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags">X19oYXNDb21tb25DbGljaw==</BinaryString>
										<string name="Text">Check Object</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="TextDirection">0</token>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>1</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="UICorner" referent="RBXE125DC13CF684B2EA3105AF392943584">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<UDim name="CornerRadius">
											<S>0</S>
											<O>8</O>
										</UDim>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">UICorner</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX0545F1C643034CF188927D67C136C3CF">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Sounds</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Sound" referent="RBX86BAD9BC4A9440F5B4D6C804D499CCA6">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<NumberRange name="LoopRegion">0 60000 </NumberRange>
								<bool name="Looped">false</bool>
								<string name="Name">CommonClick</string>
								<bool name="PlayOnRemove">false</bool>
								<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
								<bool name="PlaybackRegionsEnabled">false</bool>
								<float name="PlaybackSpeed">1</float>
								<bool name="Playing">false</bool>
								<float name="RollOffMaxDistance">10000</float>
								<float name="RollOffMinDistance">10</float>
								<token name="RollOffMode">3</token>
								<Ref name="SoundGroup">null</Ref>
								<Content name="SoundId"><url>rbxassetid://9120411320</url></Content>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<double name="TimePosition">0</double>
								<float name="Volume">10</float>
							</Properties>
						</Item>
						<Item class="Sound" referent="RBXA2984E6298414AF983FCBCD95450A724">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<NumberRange name="LoopRegion">0 60000 </NumberRange>
								<bool name="Looped">false</bool>
								<string name="Name">Error</string>
								<bool name="PlayOnRemove">false</bool>
								<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
								<bool name="PlaybackRegionsEnabled">false</bool>
								<float name="PlaybackSpeed">1</float>
								<bool name="Playing">false</bool>
								<float name="RollOffMaxDistance">10000</float>
								<float name="RollOffMinDistance">10</float>
								<token name="RollOffMode">3</token>
								<Ref name="SoundGroup">null</Ref>
								<Content name="SoundId"><url>rbxassetid://6045346303</url></Content>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<double name="TimePosition">0</double>
								<float name="Volume">2.01600003</float>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXAE8333C787594ABDB7CFBDD738E85630">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PackageManager</string>
					<string name="ScriptGuid">{FF79E73A-9770-4854-A7E6-BEF72CF21558}</string>
					<ProtectedString name="Source"><![CDATA[--// TYPES
local Parent = script.Parent
local PMSC = require(Parent.PMStringifyCompiler)
local EventPackage = require(Parent.EventPackage)
local GithupApiBuilder = require(Parent["@CHL/GitHubApiInstanceBuilder"])
local Map = require(Parent["@CHL/Map"])

type dict<A> = Map.dictionary<A>

--// main object
export type object = {
	repositories: dict<Instance>;
	library: dict<package_struct>;
	exportOutput: {base_package};
	pmsc: PMSC.object;

	addPackageToLibrary: (self:object, base_package) -> ();
	loadPackage: (self:object, name: string, isroot: boolean?) -> ();
	addRepository: (self:object, index: string, Instance) -> ();
	unloadPackage: (self: object, name: string, isRoot: boolean?) -> ();
	reloadPackage: (self:object, name: string) -> ();

	__packageInstalled: EventPackage.package<string>;
	packageInstalled: EventPackage.event<string>;
	__packageUninstalled: EventPackage.package<string>;
	packageUninstalled: EventPackage.event<string>;
}

--// main object package struct
export type package_struct = {
	package: base_package;
	module: ModuleScript;
	isRoot: boolean;
	isInstalled: boolean;
};

--// package type
export type packageType = 'self' | 'url' | 'source' | 'module_asset_id' | 
	'instance_construct'

--// base package
export type base_package = {
	name: string;
	packageType: packageType;
	dependencies: {string}?;
	targetRepository: string;
}

--// internal type package, not used
type __self_package = {self_referral: Instance;} & base_package

--// url package: package obtained from url
export type url_package = {url: string} & base_package 

--// source package: package obtained from direct source
type __source_package_encrytion = 'none' -- | 'base64'
export type source_package = {
	source: string; 
	encryption: __source_package_encrytion
} & base_package

--// asset id package: package obtained from module id
export type module_asset_id_package = {
	asset_id: string | number
} & base_package

--// internal object construct package: package obtained from instances from tables
local InstanceConstruct = require(Parent.InstanceConstruct)
type __internal_object_construct_package = {
	params: InstanceConstruct.inputStruct;
} & base_package

export type git_hub_api_v2_package = {
	repo_set: string;
	hash: string;
	suffix: string;
} & base_package

-- implement
local disguise = require(Parent.LuaUTypes).disguise
local PMPS = require(Parent.PMPlaceSave)
local Dash = require(Parent["@CHL/DashSingular"])
local SourceMapBuilder = require(Parent["@CHL/SourceMapBuilder"])

HttpService = game:GetService('HttpService')

local module = {}
module.__index = module

function module.new()
	local self: object = disguise(setmetatable({}, module))
	
	self.repositories = {}
	self.library = {}
	self.exportOutput = {}
	self.pmsc = PMSC.new()
	self.__packageInstalled = EventPackage.new()
	self.packageInstalled = self.__packageInstalled.event
	self.__packageUninstalled = EventPackage.new()
	self.packageUninstalled = self.__packageUninstalled.event
	
	for _, v in next, PMPS.repositories.folder:GetChildren() do
		if not v:IsA('ObjectValue') then continue;end
		
		local w = v.Value
		if not (w and w:IsDescendantOf(game))then v:Destroy()continue;end
		
		self.repositories[v.Name] = w
	end
	
	return self
end

module.checkPackage = function(package:base_package)
	assert(
		type(package) == 'table', 
		`attempting to use a non table argument:{
		package
		}`
	)
	assert(not getmetatable(disguise(package)), 'attempting to use a metatable on a package')
	
	local name = package.name
	assert(type(name) == 'string', `bad name: {name}`)
	
	local pType = package.packageType
	assert(type(pType) == 'string', `bad packageType: {pType}`)
end

module.isPackage = function(b:base_package)
	return type(b) == 'table' and 
		not getmetatable(disguise(b)) and 
		type(b.name) == 'string' and 
		type(b.packageType) == 'string'
end

module.loadPackage = function(self:object, i: string, isRoot: boolean?)
	local package_struct = assert(self.library[i], `Missing package: {i}`)
	local package = package_struct.package
	local name = package.name
	local pointer = PMPS.packages:getPointer(name)
	
	isRoot = package_struct.isRoot or isRoot or false
	package_struct.isRoot = isRoot
	if pointer then pointer:SetAttribute('isNotRoot', not package_struct)end
	
	if package_struct.isInstalled then return end
	
	-- target
	local target = assert(
		self.repositories[package.targetRepository], 
		`attempting to use a non-existant repository: {package.targetRepository}`
	)

	local pType: packageType = package.packageType
	
	-- main
	local moduleScript
	if pType == 'self' then
		local self_referral = (package :: __self_package) .self_referral
		
		assert(
			script:IsAncestorOf(self_referral), 
			`attempting to refer to a script not parented under package manager: {
			self_referral:GetFullName()}`
		)
		
		moduleScript = self_referral:Clone()
	elseif pType == 'url' then
		local url = (package::url_package).url
		assert(type(url) == 'string')
		
		local source
		
		local didWork, err = pcall(function()
			source = HttpService:GetAsync(url)
		end)
		
		assert(source and didWork, `error: {err}`)
		moduleScript = Instance.new('ModuleScript')
		moduleScript.Name = name
		moduleScript.Source = source
	elseif pType == 'source' then
		local source = (package :: source_package).source
		if true then
			error('unimplemented')
		end
		
		moduleScript = Instance.new('ModuleScript')
		moduleScript.Name = name
		moduleScript.Source = source
	elseif pType == 'module_asset_id' then
		local assetId = `{(package::module_asset_id_package).asset_id}`
		
		assert(
			assetId:match('^%d+$'),
			`Attempting to use a non-number or a string of non-radix 10: {assetId}`
		)
		
		local objects = game:GetObjects(`rbxassetid://{assetId}`)
		
		assert(
			#objects == 1, 
			`Attempting to refer to a asset with an amount of base objects of not 1: {#objects}`
		)
		
		moduleScript = objects[1]
		
		assert(
			moduleScript:IsA('ModuleScript'),
			`Attempting to refer to a non-modulescript: {moduleScript.ClassName}`
		)
		
		moduleScript.Name = name
	elseif pType == 'instance_construct' then
		local params = (package:: __internal_object_construct_package).params
		
		local resultStruct = InstanceConstruct.convertToInstance(params)
		
		assert(#resultStruct.root == 1, 'Attempting to construct multiple instances')
		
		moduleScript = resultStruct.root[1]
		assert(moduleScript:IsA('ModuleScript'), `Invalid class name: {moduleScript.ClassName}`)
	elseif pType == 'sourcemapjson' then
		local url = (package::url_package).url
		assert(type(url) == 'string')

		local didWork, err = pcall(function()
			moduleScript = SourceMapBuilder.from.url(url)
		end)

		assert(didWork, `error: {err}`)
	elseif pType == 'git_api_v1' then
		local url = (package::url_package).url
		
		-- fingers crossed
		moduleScript = GithupApiBuilder.v1.from.url(url)
		--from.url(url)
		moduleScript.Name = package.name
		assert(moduleScript)
	elseif pType == 'git_api_v2' then
		local _p = package :: git_hub_api_v2_package
		moduleScript = GithupApiBuilder.v2.from.sha_hash(
			assert(_p.hash, 'missing hash'),
			assert(_p.repo_set, 'missing repo_set'),
			assert(_p.suffix, 'missing suffix')
		)
		moduleScript.Name = package.name
	else
		error(`bad packageType (not availible): {pType}`)
	end
	
	-- module script
	assert(moduleScript, 'internal error did not assign module script')
	
	moduleScript.Parent = target
	
	PMPS.packages:set(name, moduleScript)
	
	if package.dependencies then
		for _, v in next, package.dependencies do
			self:loadPackage(v);
		end
	end
	package_struct.isInstalled = true
	
	self.__packageInstalled:fire(name)
	
	if isRoot then
		package_struct.isRoot = true
	else
		local pointer = PMPS.packages:getPointer(name)
		pointer:SetAttribute('isNotRoot', true)

	end
end

module.addPackageToLibrary = function(self:object, package: base_package)
	-- pre
	module.checkPackage(package)
	
	-- main
	local name = package.name
	local lib = {
		package = package;
	} :: package_struct
	local value = PMPS.packages:getPointer(name)
	
	if value then 
		lib.isInstalled = true
		lib.isRoot = not (value:GetAttribute('isNotRoot'))
	end
	
	if self.library[name] then return end
	self.library[name] = lib
	
	table.insert(self.exportOutput, package)
	-- self.exportOutput[package.name] = package
end

module.addRepository = function(self:object, index: string, repo: Instance)
	if self.repositories[index] then return end
	
	self.repositories[index] = repo
	PMPS.repositories:set(index, repo)
end

module.unloadPackage = function(self: object, i: string, isRoot: boolean)
	-- pre
	local ps = self.library[i]
	
	if not ps then
		return warn(`Attempting to unload a package not in library: {i}`)
	end
	
	if not ps.isInstalled then return end
	
	if ps.isRoot ~= (not not isRoot) then return end; -- probably there for a reason btw
	
	-- main
	local modulescript = PMPS.packages:get(i)
	PMPS.packages:delete(i)
	
	ps.isRoot = false;
	ps.isInstalled = false
	
	self.__packageUninstalled:fire(ps.package.name)
	
	if modulescript then
		modulescript:Destroy()
	end
	
	-- rec
	if ps.package.dependencies then
		for _, v in next, ps.package.dependencies do
			self:unloadPackage(v)
		end
	end
end

module.reloadPackage = function(self:object, i: string)
	local ps = self.library[i]
	local isRoot = ps.isRoot
	
	if ps then
		self:unloadPackage(i, isRoot)
	end
	
	self:loadPackage(i, isRoot)
end

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX2DA73D58B17141F8B53F57AFC203D6DB">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">@CHL/UrlStruct</string>
					<string name="ScriptGuid">{8A47768F-7A8E-499B-837D-EEEA4860BAB9}</string>
					<ProtectedString name="Source"><![CDATA[local module = {}
local Objects = script.Parent

local Dash = require(Objects["@CHL/DashSingular"])

type map<I,V> = Dash.Map<I,V>

export type struct = {
	scheme: string;
	username: string?;
	password: string?;
	domain: string;
	domain_split: {string};
	port: number?;
	queries: map<string, string>?;
	fragment: string?;
	path: string;
	path_split: {string}
}

disguise = require(Objects.LuaUTypes).disguise
last = Dash.last

function module.parse(s: string): struct?
	local i = 1
	local j = 1
	local n = #s
	local result: struct = disguise{}

	-- scheme
	local slash_split = s:split('/')
	
	if not slash_split[1] then return end
	result.scheme = slash_split[1]:sub(1, -2)

	-- username and password pair
	if not slash_split[3] then return end
	local at_split = slash_split[3]:split('@')
	local other = at_split[1]
	
	if #at_split == 2 then
		result.username, result.password = unpack(at_split[1]:split(':'))
		other = at_split[2]
	end
	
	-- domain and port
	local colon_split = other:split(':')
	local domain = colon_split[1]
	
	result.domain = domain
	result.domain_split = domain:split('.')
	
	local port = colon_split[2]
	if port then
		result.port = tonumber(port)
		if not result.port then return;end
	end
	
	-- query and fragment
	local lastPath = last(slash_split)
	local question_mark_split = lastPath:split('?')
	
	local query = question_mark_split[2]
	local fragment
	
	if query then
		local queries = {}
		local amp_split = query:split('&')
		local amp_last = last(amp_split)
		
		local hash_split = amp_last:split('#')
		amp_split[#amp_split], fragment = unpack(hash_split)
		slash_split[#slash_split] = question_mark_split[1]
		
		for _, e in amp_split do
			local i, v = unpack(e:split('='))
			queries[i] = v
		end
		
		result.queries = queries
	else
		local hash_split = lastPath:split('#')
		slash_split[#slash_split], fragment = unpack(hash_split)
	end
	
	result.fragment = fragment
	
	-- path
	for i = 3, 1, -1 do
		table.remove(slash_split, i)
	end
	
	result.path_split = slash_split
	result.path = table.concat(slash_split, '/')
	
	
	return result
end

function module.toString(s: struct): string
	local result = `{s.scheme}:`
	
	if s.domain then
		result ..= '//'
		
		if s.username and s.password then
			result ..= `{s.username}:{s.password}@`
		end
		
		result ..= s.domain
		
		if s.port then
			result ..= `:{s.port}`
		end
	end
	
	result ..= `/{s.path}`
	
	if s.queries then
		result ..= '?'
		
		local i = next(s.queries)
		
		while i do
			result ..= `{i}={s.queries[i]}`
			
			i = next(s.queries, i)
			
			if i then
				result ..= '&'
			end
		end
	end
	
	if s.fragment then
		result ..= `#{s.fragment}`
	end
	
	return result
end

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX43CD829F82C1444FA5740A78A2646989">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Stack</string>
					<string name="ScriptGuid">{0F08D917-1379-430F-B53F-65599548EDFA}</string>
					<ProtectedString name="Source"><![CDATA[type __object<A> = {
	content: {A};

	isEmpty: (self:__object<A>) -> boolean;
	push: (self: __object<A>, ...A) -> nil;
	pop: (self:__object<A>) -> A;
	peek: (self:__object<A>) -> A;
	clear: (self:__object<A>) -> nil
}

export type object<A> = __object<A>

local module = {}
module.__index = module

local function disguise<A>(x) : A return x end

module.new = function<A>()
	local self: __object<A> = disguise(setmetatable({}, module))
	self.content = {}

	return self;
end

module.isEmpty = function<A>(self: __object<A>)return #self.content == 0 end

module.push = function<A>(self:__object<A>, ...: A)
	for i = 1, select('#', ...) do
		local e = select(i, ...)
		table.insert(self.content, e)
	end
end

module.peek = function<A>(self: __object<A>)
	assert(not self:isEmpty(), 'attempting to peek at an empty stack')
	return self.content[#self.content]
end

module.pop = function<A>(self: __object<A>)
	assert(not self:isEmpty(), 'attempting to pop an empty stack')
	return table.remove(self.content)
end

module.clear = function<A>(self: __object<A>)table.clear(self.content)end

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXB3243CE246884B25AE040A1DE6AF0933">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">UiStack</string>
					<string name="ScriptGuid">{3854098F-A4E6-4251-AF20-BE0A8813F5D2}</string>
					<ProtectedString name="Source"><![CDATA[-- type
local Class = require(script.Parent.Class)
local Stack = require(script.Parent.Stack)
local EventPackage = require(script.Parent.EventPackage)

type __object = {
	frame: Frame;
	updateToCurrentPage: (self:__object) -> nil;
	sizeMutated: EventPackage.event<number>;
	__sizeMutated: EventPackage.package<number>;
} & Class.subclass<Stack.object<Frame>>
export type object = __object

-- main
local disguise = require(script.Parent.LuaUTypes).disguise
local module = {}
module.__index = module

module.new = function(frame: Frame, uiP: UIPageLayout)
	local self: __object = disguise(Class.inherit(Stack.new(), module))
	self.frame = frame
	self.__sizeMutated = EventPackage.new()
	self.sizeMutated = self.__sizeMutated.event
	
	return self
end

module.push = function(self:__object, ...: Frame)
	if #self.content > 0 then
		self:peek().Visible = false
	end
	
	for i = 1, select('#',...)do
		local frame: Frame = select(i, ...)
		frame.Visible = false
		self.__super:push(frame)
	end
	
	self:peek().Visible = true
	self.__sizeMutated:fire(#self.content)
end

module.updateToCurrentPage = function(self:__object)
	for i = 1, #self.content do
		self.content[i].Visible = i == #self.content
	end
end

module.pop = function(self:__object)
	local lastFrame = self.__super:pop()
	if #self.content > 0 then
		self:peek().Visible = true
	end
	
	lastFrame.Visible = false
	self.__sizeMutated:fire(#self.content)
	return lastFrame
end

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="UIPageLayout" referent="RBXF1F762ACACAD4531957B411850E71609">
					<Properties>
						<bool name="Animated">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="Circular">false</bool>
						<bool name="DefinesCapabilities">false</bool>
						<token name="EasingDirection">1</token>
						<token name="EasingStyle">2</token>
						<token name="FillDirection">0</token>
						<bool name="GamepadInputEnabled">true</bool>
						<token name="HorizontalAlignment">1</token>
						<string name="Name">UIPageLayout</string>
						<UDim name="Padding">
							<S>0</S>
							<O>0</O>
						</UDim>
						<bool name="ScrollWheelInputEnabled">true</bool>
						<token name="SortOrder">2</token>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<bool name="TouchInputEnabled">true</bool>
						<float name="TweenTime">1</float>
						<token name="VerticalAlignment">1</token>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXEF7F389AFA6A44EBA6D3D124F10E09D8">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">FileExporter</string>
					<string name="ScriptGuid">{6B615FFA-1262-498E-B90F-938AB5058AF1}</string>
					<ProtectedString name="Source"><![CDATA[local module = {}

local disguise = require(script.Parent.LuaUTypes).disguise
local TableToString = require(script.Parent.TableToString)
local Selection = game:GetService('Selection')
local ServerStorage = game:GetService('ServerStorage')

module.exportFile = function(content: string): any?
	local scriptExport = ServerStorage:FindFirstChild('__package') or Instance.new('Script')
	scriptExport.Name = '__package'
	scriptExport.Source = content
	scriptExport.Parent = ServerStorage
	
	local lastSelection = Selection:Get()
	Selection:Set{scriptExport}
	assert(
		disguise(module).prompt, 
		'module function not set. Set module.prompt to a function which does the same as \z
		(plugin:PromptSaveSelection). It is not set due to some random limitation'
	)()
	
	-- plugin:PromptSaveSelection('lua')
	return Selection:Set(lastSelection)
end


module.exportFileFromTable = function(t: {[any]: any}): any?
	assert(not getmetatable(disguise(t)), 'attempting to use a metatable on a package')
	
	local result = `return {TableToString.table.toString(t, '\t')}`
	
	return module.exportFile(result)
end

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX2DF8699383424E6DB84CADEBF5B627D4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LuaTableImporter</string>
					<string name="ScriptGuid">{C0A10EC8-E3A0-46CC-9067-5455D998F450}</string>
					<ProtectedString name="Source"><![CDATA[type __table = {[any]: any}
export type anyTable = __table

local module = {}

local loadString = require(script.Parent.Loadstring)
local StudioService = game:GetService('StudioService')
local env = setmetatable({}, {
	__index = function(_, i)
		--print(debug.traceback())
		--error(`Attempting to use environment: {i}`)
		return nil
	end,
})

module.stringToTable = function(s: string): (boolean, __table | string)
	local success, val = pcall(function()
		return loadString(s, env)()
	end)
	
	if not success then
		warn(`Internal parsing fail: Source={s}|error={val}`)
	end
	
	return success, val
end

module.fileToTable = function(): (boolean, __table | string)
	local file: File = StudioService:PromptImportFile{'lua'}
	
	if not file then return false, 'No file selected' end;
	return module.stringToTable(file:GetBinaryContents())
end

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX0DA52DF01E41468FB2694BE753CDC13C">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">UiElements</string>
					<string name="ScriptGuid">{2083B3B3-68A1-435D-92EB-182CE567FEC1}</string>
					<ProtectedString name="Source"><![CDATA[--// TYPES
local Objects = script.Parent
local Switch = require(Objects["@CHL/Switch"])
local SelectionCollection = require(Objects["@CHL/SelectionCollection"])
local EventPackage = require(Objects.EventPackage)
local PackageManager = require(Objects.PackageManager)
local Class = require(Objects.Class)

--// MAIN
local module = {}
local disguise = require(Objects.LuaUTypes).disguise

--[[
#############################################################################################
#############################################################################################
#############################################################################################
--]]
type __libraryElement1State = 'pending' | 'error' | 'installed'
type __libraryElement1 = {
	frame: Frame;
	title: TextButton;
	installTB: TextButton;
	initSelect: ImageButton;
	state: __libraryElement1State;
	packageStruct: PackageManager.package_struct;
	canClick: boolean;
	__installed: EventPackage.package<>;
	installed: EventPackage.event<>;
	__installFailed: EventPackage.package<>;
	installFailed: EventPackage.event<>;
	__clicked: EventPackage.package<>;
	clicked: EventPackage.event<>;
	__selectInited: EventPackage.package<>;
	selectInited: EventPackage.event<>;

	changeState: (self: __libraryElement1, newState: __libraryElement1State) -> nil;
	install: (self: __libraryElement1) -> nil;
}
export type libraryElement1 = __libraryElement1

local LibraryElement1 = {}

module.packageManager = disguise() :: PackageManager.object
module.LibraryElement1 = LibraryElement1
LibraryElement1.referral = nil
LibraryElement1.__index = LibraryElement1
LibraryElement1.stateChanges = {
	pending = {
		text = 'Install';
		color = Color3.new(0,1);
	};
	['error'] = {
		text = 'Check Output';
		color = Color3.new(1)
	};
	installed = {
		text = 'Installed';
		color = Color3.new(0,0,1)
	}
}

function LibraryElement1.new(ps: PackageManager.package_struct): __libraryElement1
	local self: __libraryElement1 = disguise(setmetatable({}, LibraryElement1))
	local f = assert(LibraryElement1.referral, 'Forgot to set LIB_El1'):Clone()
	local g = disguise(f)
	
	self.frame = f
	self.packageStruct = ps;
	self.title = g.Title
	self.title.Text = ps.package.name
	self.initSelect = g.Select
	self.installTB = g.Install
	self.canClick = true
	self.__installed = EventPackage.new()
	self.installed = self.__installed.event
	self.__selectInited = EventPackage.new()
	self.selectInited = self.__selectInited.event
	self.__installFailed = EventPackage.new()
	self.installFailed = self.__installFailed.event
	self.__clicked = EventPackage.new()
	self.clicked = self.__installFailed.event
	
	self:changeState('pending')
	
	if ps.isInstalled then
		self:changeState('installed')
	end
	
	local fn = function()self:install()end
	
	self.installTB.MouseButton1Click:Connect(fn)
	self.title.MouseButton1Click:Connect(fn)
	
	module.packageManager.packageInstalled:Connect(function(i)
		if i == ps.package.name then
			self:changeState('installed')
		end
	end)
	
	module.packageManager.packageUninstalled:Connect(function(i)
		if i == ps.package.name then
			self:changeState('pending')
		end
	end)
	
	local fn2 = function()self.__selectInited:fire()end
	
	self.initSelect.MouseButton1Click:Connect(fn2)
	
	return self
end

LibraryElement1.changeState = function(self: __libraryElement1, state: __libraryElement1State)
	self.state = state
	
	local changes = LibraryElement1.stateChanges[state]
	local button = self.installTB
	button.Text = changes.text
	button.TextStrokeColor3 = changes.color
end

LibraryElement1.install = function(self: __libraryElement1)
	self.__clicked:fire()
	
	if self.packageStruct.isInstalled or not self.canClick then return end;
	self.canClick = false;
	
	local pm = assert(module.packageManager, 'Forgot to set pm')
	
	local s, e = pcall(function()pm:loadPackage(self.packageStruct.package.name, true) end)

	if e then warn(e)end

	if self.packageStruct.isInstalled then
		self.__installed:fire()
	else
		self.__installFailed:fire()
		self:changeState('error')
		wait(2)
		self:changeState('pending')
	end
	
	self.canClick = true
end

--[[
#############################################################################################
#############################################################################################
#############################################################################################
--]]
type __selectionBox = {
	frame: Frame;
	selected: GuiButton;
	unselected: GuiButton;
} & Class.subclass<Switch.object>
export type selectionBox = __selectionBox

local SelectionBox = {}
SelectionBox.__index = SelectionBox

function SelectionBox.new(f: Frame): __selectionBox
	local self: __selectionBox = disguise(Class.inherit(Switch.new(), SelectionBox))
	local g = disguise(f)
	
	self.frame = f
	self.selected = assert(g:FindFirstChild'Selected')
	self.unselected = assert(g:FindFirstChild('Unselected'))
	
	local fn = function()self:flick(not self.isOn)end
	self.selected.MouseButton1Click:Connect(fn)
	self.unselected.MouseButton1Click:Connect(fn)
	
	return self
end

SelectionBox.flick = function(self: __selectionBox, toBool: boolean)
	self.__super:flick(toBool)
	
	self.selected.Visible = self.isOn
	self.unselected.Visible = not self.isOn
end

module.SelectionBox = SelectionBox;

--[[
#############################################################################################
#############################################################################################
#############################################################################################
--]]
type __libraryElement2 = {
	selectBox: __selectionBox;
	frame: Frame;
	title: TextButton
}
export type libraryElement2 = __libraryElement2

local LibraryElement2 = {}
LibraryElement2.__index = LibraryElement2

LibraryElement2.referral = nil

function LibraryElement2.new(ps: PackageManager.package_struct): __libraryElement2
	local self: __libraryElement2 = disguise(setmetatable({}, LibraryElement2))
	local f = assert(LibraryElement2.referral, 'forgot to set this'):Clone()
	self.frame = f
	self.title = disguise(f:FindFirstChild('Title'))
	self.selectBox = SelectionBox.new(disguise(f).Select)
	
	self.title.Text = ps.package.name
	
	self.title.MouseButton1Click:Connect(function()self.selectBox:flick(disguise())end)
	self.selectBox.flicked:connect(function(isOn: boolean)
		self.frame.LayoutOrder = isOn and 0 or 1
	end)
	return self
end

module.LibraryElement2 = LibraryElement2

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX2EC3302CCDDF416DBD9CD1F6360438C4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">lxm</string>
					<string name="ScriptGuid">{EEA6B3F1-7912-471C-B5D2-CF387887D597}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Reading process:

	Parse header
	Decompress chunks
	Parse META and SSTR chunks
	Parse INST chunks
	Parse PROP chunks
	Parse PRNT chunk

	We parse this way to prevent eroneous chunk placement, whenever possible, break the script if something
	doesn't read correctly
]]

local HEADER = "<roblox!"
local RBXM_SIGNATURE = "\x89\xff\x0d\x0a\x1a\x0a"
local ZSTD_HEADER = "\x28\xB5\x2F\xFD"

local Buffer = require(script.Buffer)
local Types = require(script.Types)
local lz4 = require(script.lz4)
local zstd = require(script.zstd)
local Chunks = script.Chunks

local VALID_CHUNK_IDENTIFIERS = {
	["END\0"] = true,
	["INST"] = true,
	["META"] = true,
	["PRNT"] = true,
	["PROP"] = true,
	["SIGN"] = true,
	["SSTR"] = true
}
local CHUNK_MODULES = {
	INST = require(Chunks.INST),
	META = require(Chunks.META),
	PRNT = require(Chunks.PRNT),
	PROP = require(Chunks.PROP),
	SSTR = require(Chunks.SSTR)

	--END\0 and SIGN are not processed because they're irrelevant
}

local function Chunk(buffer: Types.Buffer, chunkIndex: number): Types.Chunk
	local chunk = {}
	chunk.InternalID = chunkIndex
	chunk.Header = buffer:read(4)

	if not VALID_CHUNK_IDENTIFIERS[chunk.Header] then
		print(string.byte(chunk.Header, 1, 4))
		error(`Invalid chunk identifier {chunk.Header} on chunk id {chunkIndex}`)
	end

	-- validate LZ4 header, though we can provide the buffer in directly, just used for checking for zstd
	local data

	local lz4Header = buffer:read(16, false)
	local compressed = string.unpack("<I4", string.sub(lz4Header, 1, 4))
	local decompressed = string.unpack("<I4", string.sub(lz4Header, 5, 8))
	local reserved = string.sub(lz4Header, 9, 12)
	local zstd_check = string.sub(lz4Header, 13, 16)

	if reserved ~= "\0\0\0\0" then
		error(`Invalid chunk header on chunk id {chunkIndex} of identifier {chunk.Header}`)
	end

	if compressed == 0 then
		data = buffer:read(decompressed + 12)
	else
		if zstd_check == ZSTD_HEADER then
			buffer:seek(12)
			data = zstd(buffer:read(compressed))
		else
			data = lz4(buffer:read(compressed + 12))
		end
	end

	chunk.Data = Buffer(data, false)

	function chunk:Error(msg)
		error(`[{self.Header}:{self.InternalID}]: {msg}`)
	end
	
	return chunk
end

local function procChunkType(chunkStore: {[string]: {Types.Chunk}}, id: string, rbxm: Types.Rbxm)
	local chunks = chunkStore[id]
	local f = CHUNK_MODULES[id]

	if chunks and f then
		for _, chunk in chunks do
			f(chunk, rbxm)
		end
	end
end

local function rbxm(buffer: string): Types.Rbxm
	local rbxmBuffer = Buffer(buffer, false)

	-- read signature data
	if
		rbxmBuffer:read(8) ~= HEADER
		or rbxmBuffer:read(6) ~= RBXM_SIGNATURE
	then
		error("Provided file does not match the header of an RBXM file.")
	end

	if rbxmBuffer:read(2) ~= "\0\0" then
		error("Invalid RBXM version, if Roblox has released a newer version (unlikely), please let me know.")
	end

	local rbxm = {}
	local classCount = rbxmBuffer:readNumber("<i4")
	local instCount = rbxmBuffer:readNumber("<i4")

	local classRefIds = table.create(classCount)
	local instRefIds = table.create(instCount)
	rbxm.ClassRefs = classRefIds
	rbxm.InstanceRefs = instRefIds
	rbxm.Tree = {}
	rbxm.Metadata = {}
	rbxm.Strings = {}

	local chunkInfo = {}
	for k in VALID_CHUNK_IDENTIFIERS do
		chunkInfo[k] = {}
	end

	if rbxmBuffer:read(8) ~= "\0\0\0\0\0\0\0\0" then
		error("Provided file does not match the header of an RBXM file.")
	end

	local index = 0
	repeat
		index+=1
		local last_chunk = Chunk(rbxmBuffer, index)
		local header = last_chunk.Header
		local chunkInfoSection = chunkInfo[header]
		table.insert(chunkInfoSection, last_chunk)
	until last_chunk.Header == "END\0"

	procChunkType(chunkInfo, "META", rbxm)
	procChunkType(chunkInfo, "SSTR", rbxm)
	procChunkType(chunkInfo, "INST", rbxm)
	procChunkType(chunkInfo, "PROP", rbxm)
	procChunkType(chunkInfo, "PRNT", rbxm)

	return rbxm
end

return rbxm]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXABFEAA87F1984D1C87870DF6A3CB5519">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">BasicTypes</string>
						<string name="ScriptGuid">{4AB610CF-C3E6-43C2-8ECD-45042D2E8EC1}</string>
						<ProtectedString name="Source"><![CDATA[-- Used for deserialising interleaving, strings, numbers and refs
-- Refs are held here since multiple chunks rely on it

local Types = require(script.Parent.Types)
local Buffer = require(script.Parent.Buffer)
local basicTypes = {}

local function transformInt(x: number): number
	-- cant use the bit method because bit32 (yay)
	return if x % 2 == 0
		then x / 2
		else -(x + 1) / 2
end

local function rbxF32(x: number): number
	x = bit32.rrotate(x, 1)
	return string.unpack(">f", string.pack(">I4", x))
end

function basicTypes.String(buffer: Types.Buffer): string
	return buffer:read(buffer:readNumber("<I4"))
end

function basicTypes.Int32(buffer: Types.Buffer): number
	return transformInt(buffer:readNumber(">I4"))
end

function basicTypes.Int64(buffer: Types.Buffer): number
	return transformInt(buffer:readNumber(">I8"))
end

function basicTypes.Float32(buffer: Types.Buffer): number
	return rbxF32(buffer:readNumber(">I4"))
end

function basicTypes.Float64(buffer: Types.Buffer): number --just use <d lol (here for completeness)
	return buffer:readNumber("<d")
end

-- my favourite function :D
function basicTypes.InterleaveArrayWithSize(buffer: Types.Buffer, count: number, sizeof: number): Types.Buffer
	if count < 0 then return Buffer("", false) end
	
	local stream = buffer:read(count * sizeof)
	local out = table.create(count)
	for i = 1, count do
		local chunk = table.create(sizeof)
		for s = 0, sizeof-1 do
			local bitPos = i + (count * s)
			chunk[s+1] = string.sub(stream, bitPos, bitPos)
		end
		out[i] = table.concat(chunk)
	end

	return Buffer(table.concat(out), false)
end

function basicTypes.unsignedIntArray(buffer: Types.Buffer, count: number): {number}
	if count < 1 then return {} end

	local o = table.create(count)
	local strings = basicTypes.InterleaveArrayWithSize(buffer, count, 4)
	for i = 1, count do
		o[i] = strings:readNumber("<I4")
	end

	return o
end

function basicTypes.Int32Array(buffer: Types.Buffer, count: number): {number}
	if count < 1 then return {} end

	local o = table.create(count)
	local strings = basicTypes.InterleaveArrayWithSize(buffer, count, 4)
	for i = 1, count do
		o[i] = basicTypes.Int32(strings)
	end

	return o
end

function basicTypes.Int64Array(buffer: Types.Buffer, count: number): {number}
	if count < 1 then return {} end

	local o = table.create(count)
	local strings = basicTypes.InterleaveArrayWithSize(buffer, count, 8)
	for i = 1, count do
		o[i] = basicTypes.Int64(strings)
	end

	return o
end

function basicTypes.RbxF32Array(buffer: Types.Buffer, count: number): {number}
	if count < 1 then return {} end

	local o = table.create(count)
	local strings = basicTypes.InterleaveArrayWithSize(buffer, count, 4)

	for i = 1, count do
		o[i] = basicTypes.Float32(strings)
	end

	return o
end

function basicTypes.RefArray(buffer: Types.Buffer, count: number): {number}
	if count < 1 then return {} end

	local o = table.create(count)
	local refs = basicTypes.Int32Array(buffer, count)

	local last = 0
	for i = 1, count do
		local ref = last + refs[i]
		o[i] = ref
		last = ref
	end

	return o
end

return basicTypes]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1B323C41494F4DBAAAEFD567251A77E7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Buffer</string>
						<string name="ScriptGuid">{7DFFB372-158C-4BF9-AE55-1EF3EC69521E}</string>
						<ProtectedString name="Source"><![CDATA[local Types = require(script.Parent.Types)

local function Buffer(str, allowOverflows): Types.Buffer
	local Stream = {}
	Stream.Offset = 0
	Stream.Source = str
	Stream.Length = string.len(str)
	Stream.IsFinished = false	
	Stream.LastUnreadBytes = 0
	Stream.AllowOverflows = if allowOverflows then allowOverflows else true

	function Stream.read(self: Types.Buffer, len: number?, shift: boolean?): string
		local len = len or 1
		local shift = if shift ~= nil then shift else true
		local dat = string.sub(self.Source, self.Offset + 1, self.Offset + len)

		local dataLength = string.len(dat)
		local unreadBytes = len - dataLength

		if unreadBytes > 0 and not self.AllowOverflows then
			error("Buffer went out of bounds and AllowOverflows is false")
		end

		if shift then
			self:seek(len)
		end

		self.LastUnreadBytes = unreadBytes
		return dat
	end

	function Stream.seek(self: Types.Buffer, len: number)
		local len = len or 1

		self.Offset = math.clamp(self.Offset + len, 0, self.Length)
		self.IsFinished = self.Offset >= self.Length
	end

	function Stream.append(self: Types.Buffer, newData: string)
		-- adds new data to the end of a stream
		self.Source ..= newData
		self.Length = string.len(self.Source)
		self:seek(0) --hacky but forces a recalculation of the isFinished flag
	end

	function Stream.toEnd(self: Types.Buffer)
		self:seek(self.Length)
	end

	function Stream.readNumber(self: Types.Buffer, fmt: string?, shift: boolean?): number
		fmt = fmt or "I1"
		local packsize = string.packsize(fmt)

		local chunk = self:read(packsize, shift)
		local n = string.unpack(fmt, chunk)
		return n
	end

	function Stream.readByte(self: Types.Buffer, shift: boolean?): number
		return string.byte(self:read(1, shift))
	end

	return Stream
end

return Buffer]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX578D71AC17AB4D4B855CBF530C6F8F03">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Chunks</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX47571603A3F344F7B49D382BF8BB9B7F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">INST</string>
							<string name="ScriptGuid">{40165658-4FBE-41C4-AA85-84272BAD1198}</string>
							<ProtectedString name="Source"><![CDATA[local Types = require(script.Parent.Parent.Types)
local BasicTypes = require(script.Parent.Parent.BasicTypes)

local function VirtualInstance(classID: number, className: string, ref: number): Types.VirtualInstance
	return {
		ClassId = classID,
		ClassName = className,
		Ref = ref,

		Properties = {},
		Children = {}
	}
end

local function INST(chunk: Types.Chunk, rbxm: Types.Rbxm)
	local buffer = chunk.Data
	-- creates virtual instances for each given instance
	-- this will reject service instances (errors)
	local ClassID = buffer:readNumber("<I4")
	local ClassName = BasicTypes.String(buffer)

	if buffer:read() == "\1" then
		chunk:Error("Attempt to insert binary model with services")
	end

	local count = buffer:readNumber("<I4")
	local refs = BasicTypes.RefArray(buffer, count)

	-- dont bother reading serivce markers since this does not support services
	-- map virtual instances and refs to RBXM
	rbxm.ClassRefs[ClassID] = {
		Name = ClassName,
		Sizeof = count,
		Refs = refs
	}

	for _, ref in refs do
		rbxm.InstanceRefs[ref] = VirtualInstance(ClassID, ClassName, ref)
	end
end

return INST]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXAC01E64E761C4BF89FBA6241CC37B362">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">META</string>
							<string name="ScriptGuid">{19DE25F6-EEE6-4A4A-B517-E3C14E9C450E}</string>
							<ProtectedString name="Source"><![CDATA[local Types = require(script.Parent.Parent.Types)
local BasicTypes = require(script.Parent.Parent.BasicTypes)

local function META(chunk: Types.Chunk, rbxm: Types.Rbxm)
	local buffer = chunk.Data
	for i = 1, buffer:readNumber("<I4") do
		local k = BasicTypes.String(buffer)
		local v = BasicTypes.String(buffer)

		rbxm.Metadata[k] = v
	end
end

return META]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX1FD089F80AB24CD8B803BE53E30A5708">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PRNT</string>
							<string name="ScriptGuid">{602808B6-3E64-4212-9AF2-CC82D3D185A0}</string>
							<ProtectedString name="Source"><![CDATA[local Types = require(script.Parent.Parent.Types)
local BasicTypes = require(script.Parent.Parent.BasicTypes)

local function PRNT(chunk: Types.Chunk, rbxm: Types.Rbxm)
	local buffer = chunk.Data
	--Builds the instance tree from the given PRNT structure

	local ver = buffer:read()
	if ver ~= "\0" then
		chunk:Error("Invalid PRNT version")
	end

	local count = buffer:readNumber("<I4")
	local child_refs = BasicTypes.RefArray(buffer, count)
	local parent_refs = BasicTypes.RefArray(buffer, count)

	for i = 1, count do
		local childID = child_refs[i]
		local parentID = parent_refs[i]

		local child = rbxm.InstanceRefs[childID]
		local parent = if parentID >= 0 then rbxm.InstanceRefs[parentID] else nil

		if not child then
			chunk:Error(`Could not parent {childID} to {parentID} because child {childID} was nil`)
		end

		if parentID >= 0 and not parent then
			chunk:Error(`Could not parent {childID} to {parentID} because parent {parentID} was nil`)
		end

		local parentTable = if parent then parent.Children else rbxm.Tree
		table.insert(parentTable, child)
	end
end

return PRNT]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX0AB17DDF213F4F44ACFA4FAFA62D6795">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PROP</string>
							<string name="ScriptGuid">{4B8FD11A-E27B-4F99-8E1E-50AC36E6CE1F}</string>
							<ProtectedString name="Source"><![CDATA[local Types = require(script.Parent.Parent.Types)
local BasicTypes = require(script.Parent.Parent.BasicTypes)

local FACES_BIT_FLAG = {
	Enum.NormalId.Right,
	Enum.NormalId.Top,
	Enum.NormalId.Back,
	Enum.NormalId.Left,
	Enum.NormalId.Bottom,
	Enum.NormalId.Front
}
local AXES_BIT_FLAG = {
	Enum.Axis.X,
	Enum.Axis.Y,
	Enum.Axis.Z
}

local function GetEnumValFromNumber(enum: Enum, num: number): EnumItem
	local enums = enum:GetEnumItems()

	for _, v in enums do
		if v.Value == num then
			return v
		end
	end

	return enums[1]
end

local function parseBitFlag<T>(byte: number, bitFlag: {T}): T
	local output = {}
	for i = 0, 7 do
		if bit32.extract(byte, i) ~= 0 then
			table.insert(output, bitFlag[i+1])
		end
	end

	return unpack(output)
end

local function PROP(chunk: Types.Chunk, rbxm: Types.Rbxm)
	local reader = chunk.Data
	local classID = reader:readNumber("<I4")
	local classref = rbxm.ClassRefs[classID]
	local refs = classref.Refs
	local sizeof = classref.Sizeof

	local name = BasicTypes.String(reader)
	local optTypeIdCheck = string.byte(reader:read(1, false)) == 0x1E
	if optTypeIdCheck then
		-- although its only be spotted for CFrame, i do believe 0x1E will be used for
		-- other optional types in the future, this future proofs that case
		reader:seek(1)
	end

	local typeID = string.byte(reader:read())

	local properties = {}

	if typeID == 0x01 then
		-- String, Bytecode
		for i = 1, sizeof do
			properties[i] = BasicTypes.String(reader)
		end

	elseif typeID == 0x02 then
		-- Boolean
		for i = 1, sizeof do
			properties[i] = reader:read() ~= "\0"
		end

	elseif typeID == 0x03 then
		-- Int32
		properties = BasicTypes.Int32Array(reader, sizeof)

	elseif typeID == 0x04 then
		-- RbxFloat32
		properties = BasicTypes.RbxF32Array(reader, sizeof)

	elseif typeID == 0x05 then
		-- Float64
		for i = 1, sizeof do
			properties[i] = BasicTypes.Float64(reader)
		end

	elseif typeID == 0x06 then
		-- UDim
		local scale = BasicTypes.RbxF32Array(reader, sizeof)
		local offset = BasicTypes.Int32Array(reader, sizeof)

		for i = 1, sizeof do
			properties[i] = UDim.new(scale[i], offset[i])
		end

	elseif typeID == 0x07 then
		-- UDim2
		local scaleX, scaleY = BasicTypes.RbxF32Array(reader, sizeof), BasicTypes.RbxF32Array(reader, sizeof)
		local offsetX, offsetY = BasicTypes.Int32Array(reader, sizeof), BasicTypes.Int32Array(reader, sizeof)

		for i = 1, sizeof do
			properties[i] = UDim2.new(scaleX[i], offsetX[i], scaleY[i], offsetY[i])
		end

	elseif typeID == 0x08 then
		-- Ray
		for i = 1, sizeof do
			properties[i] = Ray.new(
				Vector3.new(
					reader:readNumber("<f"),
					reader:readNumber("<f"),
					reader:readNumber("<f")
				),
				Vector3.new(
					reader:readNumber("<f"),
					reader:readNumber("<f"),
					reader:readNumber("<f")
				)
			)
		end

	elseif typeID == 0x09 then
		-- Faces
		for i = 1, sizeof do
			local byte = string.byte(reader:read())
			properties[i] = Faces.new(parseBitFlag(byte, FACES_BIT_FLAG))
		end

	elseif typeID == 0x0A then
		-- Axes
		for i = 1, sizeof do
			local byte = string.byte(reader:read())
			properties[i] = Axes.new(parseBitFlag(byte, AXES_BIT_FLAG))
		end

	elseif typeID == 0x0B then
		-- BrickColor
		local ints = BasicTypes.unsignedIntArray(reader, sizeof)
		for i = 1, sizeof do
			properties[i] = BrickColor.new(ints[i])
		end

	elseif typeID == 0x0C then
		-- Color3
		local r = BasicTypes.RbxF32Array(reader, sizeof)
		local g = BasicTypes.RbxF32Array(reader, sizeof)
		local b = BasicTypes.RbxF32Array(reader, sizeof)

		for i = 1, sizeof do
			properties[i] = Color3.new(r[i], g[i], b[i])
		end

	elseif typeID == 0x0D then
		-- Vector2
		local x = BasicTypes.RbxF32Array(reader, sizeof)
		local y = BasicTypes.RbxF32Array(reader, sizeof)

		for i = 1, sizeof do
			properties[i] = Vector2.new(x[i], y[i])
		end

	elseif typeID == 0x0E then
		-- Vector3
		local x = BasicTypes.RbxF32Array(reader, sizeof)
		local y = BasicTypes.RbxF32Array(reader, sizeof)
		local z = BasicTypes.RbxF32Array(reader, sizeof)

		for i = 1, sizeof do
			properties[i] = Vector3.new(x[i], y[i], z[i])
		end

	-- elseif typeID == 0x0F then
		-- Vector2int16?

	elseif typeID == 0x10 then
		--CFrame
		local matricies = table.create(sizeof)

		for i = 1, sizeof do
			local rawOrientation = string.byte(reader:read())
			if rawOrientation > 0 then
				local orientID = rawOrientation - 1
				local R0 = Vector3.fromNormalId(orientID / 6)
				local R1 = Vector3.fromNormalId(orientID % 6)
				local R2 =	R0:Cross(R1)

				matricies[i] = {R0, R1, R2}
			else
				local r00, r01, r02 = 
					reader:readNumber("<f"),
					reader:readNumber("<f"),
					reader:readNumber("<f")
				local r10, r11, r12 = 
					reader:readNumber("<f"),
					reader:readNumber("<f"),
					reader:readNumber("<f")
				local r20, r21, r22 = 
					reader:readNumber("<f"),
					reader:readNumber("<f"),
					reader:readNumber("<f")

				matricies[i] = {
					Vector3.new(r00, r10, r20),
					Vector3.new(r01, r11, r21),
					Vector3.new(r02, r12, r22)
				}
			end
		end

		-- map interleaved position
		local cfX = BasicTypes.RbxF32Array(reader, sizeof)
		local cfY = BasicTypes.RbxF32Array(reader, sizeof)
		local cfZ = BasicTypes.RbxF32Array(reader, sizeof)

		for i = 1, sizeof do
			local thisMatrix = matricies[i]
			local pos = Vector3.new(cfX[i], cfY[i], cfZ[i])
			properties[i] = CFrame.fromMatrix(pos, thisMatrix[1], thisMatrix[2], thisMatrix[3])
		end

	elseif typeID == 0x11 then
		-- Quaternion (i can be a little quicker here by handling it differently)
		local quaternions = {}
		for i = 1, sizeof do
			quaternions[i] = {
				x = reader:readNumber("<f"),
				y = reader:readNumber("<f"),
				z = reader:readNumber("<f"),
				w = reader:readNumber("<f")
			}
		end

		local cfX = BasicTypes.RbxF32Array(reader, sizeof)
		local cfY = BasicTypes.RbxF32Array(reader, sizeof)
		local cfZ = BasicTypes.RbxF32Array(reader, sizeof)

		for i = 1, sizeof do
			local q = quaternions[i]
			properties[i] = CFrame.new(cfX[i], cfY[i], cfZ[i], q.x, q.y, q.z, q.w)
		end

	elseif typeID == 0x12 then
		-- Enum
		properties = BasicTypes.unsignedIntArray(reader, sizeof)

	elseif typeID == 0x13 then
		-- Ref
		properties = BasicTypes.RefArray(reader, sizeof)

	elseif typeID == 0x14 then
		-- Vector3int16
		for i = 1, sizeof do
			properties[i] = Vector3int16.new(
				reader:readNumber("<i2"),
				reader:readNumber("<i2"),
				reader:readNumber("<i2")
			)
		end

	elseif typeID == 0x15 then
		-- NumberSequence
		for i = 1, sizeof do
			local kpCount = reader:readNumber("<I4")
			local kp = table.create(kpCount)

			for i = 1, kp do
				table.insert(kp, NumberSequenceKeypoint.new(
					reader:readNumber("<f"),
					reader:readNumber("<f"),
					reader:readNumber("<f")
				))
			end

			properties[i] = NumberSequence.new(kp)
		end

	elseif typeID == 0x16 then
		-- ColorSequence
		for i = 1, sizeof do
			local kpCount = reader:readNumber("<I4")
			local kp = table.create(kpCount)

			for i = 1, kp do
				table.insert(kp, ColorSequenceKeypoint.new(
					reader:readNumber("<f"),
					Color3.new(
						reader:readNumber("<f"),
						reader:readNumber("<f"),
						reader:readNumber("<f")
					)
				))

				reader:readNumber("<f")
			end

			properties[i] = ColorSequence.new(kp)
		end

	elseif typeID == 0x17 then
		-- NumberRange
		for i = 1, sizeof do
			properties[i] = NumberRange.new(
				reader:readNumber("<f"),
				reader:readNumber("<f")
			)
		end

	elseif typeID == 0x18 then
		-- Rect
		local xmn, ymn = BasicTypes.RbxF32Array(reader, sizeof), BasicTypes.RbxF32Array(reader, sizeof)
		local xmx, ymx = BasicTypes.RbxF32Array(reader, sizeof), BasicTypes.RbxF32Array(reader, sizeof)

		for i = 1, sizeof do
			properties[i] = Rect.new(
				Vector2.new(
					xmn[i], ymn[i]
				),
				Vector2.new(
					xmx[i], ymx[i]
				)
			)
		end

	elseif typeID == 0x19 then
		-- PhysicalProperties
		for i = 1, sizeof do
			if reader:read() == "\0" then continue end

			properties[i] = PhysicalProperties.new(
				reader:readNumber("<f"),
				reader:readNumber("<f"),
				reader:readNumber("<f"),
				reader:readNumber("<f"),
				reader:readNumber("<f")
			)
		end

	elseif typeID == 0x1A then
		-- Color3int8
		local r = string.split(reader:read(sizeof), "")
		local g = string.split(reader:read(sizeof), "")
		local b = string.split(reader:read(sizeof), "")

		for i = 1, sizeof do
			properties[i] = Color3.fromRGB(
				string.byte(r[i]),
				string.byte(g[i]),
				string.byte(b[i])
			)
		end

	elseif typeID == 0x1B then
		-- Int64
		properties = BasicTypes.Int64Array(reader, sizeof)

	elseif typeID == 0x1C then
		-- SharedString
		local strings = BasicTypes.unsignedIntArray(reader, sizeof)
		for i = 1, sizeof do
			local ref = strings[i] + 1
			properties[i] = rbxm.Strings[ref]
		end

	elseif typeID == 0x1D then
		-- Bytecode
		for i = 1, sizeof do
			properties[i] = buffer.fromstring(BasicTypes.String(reader))
		end

	elseif typeID == 0x20 then
		-- Font
		for i = 1, sizeof do
			local family = BasicTypes.String(reader)
			local weight = GetEnumValFromNumber(Enum.FontWeight, reader:readNumber("<I2"))
			local style = GetEnumValFromNumber(Enum.FontStyle, string.byte(reader:read()))
			
			BasicTypes.String(reader) --CachedFaceId

			properties[i] = Font.new(family, weight, style)
		end
	end

	-- perform optional prop handle
	if optTypeIdCheck then
		reader:read()

		for i = 1, sizeof do
			local archivable = reader:read() ~= "\0"
			if not archivable then
				-- null the key (hopefully if OptCFrame returns, it allows null as a prop)
				properties[i] = nil
			end
		end
	end

	-- map to referents
	for i, v in refs do
		local inst = rbxm.InstanceRefs[v]
		inst.Properties[name] = properties[i]
	end
end

return PROP]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXCC51E54577DA471F941BD9724AA1721D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SSTR</string>
							<string name="ScriptGuid">{75C28E86-C676-4462-9609-2DF0D63A5032}</string>
							<ProtectedString name="Source"><![CDATA[local Types = require(script.Parent.Parent.Types)
local BasicTypes = require(script.Parent.Parent.BasicTypes)

local function SSTR(chunk: Types.Chunk, rbxm: Types.Rbxm)
	local buffer = chunk.Data
	
	local ver = buffer:readNumber("<I4")
	if ver ~= 0 then
		chunk:Error("Invalid SSTR version")
	end

	for i = 1, buffer:readNumber("<I4") do
		buffer:read(16) --md5 hash (useless)
		rbxm.Strings[i] = BasicTypes.String(buffer)
	end
end

return SSTR]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX692620E956E3455380014A27735738B6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Types</string>
						<string name="ScriptGuid">{CC32364D-2D8A-4B22-A45C-F984D09E3E50}</string>
						<ProtectedString name="Source"><![CDATA[export type Buffer = {
	Offset: number,
	Source: string,
	Length: number,
	IsFinished: boolean,
	LastUnreadBytes: number,
	AllowOverflows: boolean,

	read: (Buffer, len: number?, shiftOffset: boolean?) -> string,
	readNumber: (Buffer, packfmt: string?, shift: boolean?) -> number,
	seek: (Buffer, len: number) -> (),
	append: (Buffer, newData: string) -> (),
	toEnd: (Buffer) -> (),
	readByte: (Buffer, shift: boolean?) -> number
}

export type Chunk = {
	InternalID: number,
	Header: "END\0"|"INST"|"META"|"PRNT"|"PROP"|"SIGN"|"SSTR",
	Data: Buffer,
	Error: (Chunk, string) -> ()
}

export type VirtualInstance = {
	ClassId: number,
	ClassName: string,
	Properties: {[string]: any},
	Ref: number,
	Children: {VirtualInstance}
}

export type Rbxm = {
	ClassRefs: {
		{
			Name: string,
			Sizeof: number,
			Refs: {number}
		}
	},
	InstanceRefs: {VirtualInstance},
	Tree: {VirtualInstance},
	Metadata: {[string]: string},
	Strings: {string}
}

return nil]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4CB99F40A9084DDBB602EDD6F6433898">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">lz4</string>
						<string name="ScriptGuid">{AD730CC4-6C71-439C-8F6F-2D09469EC717}</string>
						<ProtectedString name="Source"><![CDATA[--!strict
-- metatablecat 2022
local Buffer = require(script.Parent.Buffer)

local function lz4(lz4data: string): string
	local inputStream = Buffer(lz4data)

	local compressedLen = string.unpack("<I4", inputStream:read(4))
	local decompressedLen = string.unpack("<I4", inputStream:read(4))
	local reserved = string.unpack("<I4", inputStream:read(4))

	if reserved ~= 0 then
		error("provided chunk is not lz4 data")
	end

	if compressedLen == 0 then
		return inputStream:read(decompressedLen)
	end

	local outputStream = Buffer("")

	repeat
		local token = string.byte(inputStream:read())
		local litLen = bit32.rshift(token, 4)
		local matLen = bit32.band(token, 15) + 4

		if litLen >= 15 then
			repeat
				local nextByte = string.byte(inputStream:read())
				litLen += nextByte
			until nextByte ~= 0xFF
		end

		local literal = inputStream:read(litLen)
		outputStream:append(literal)
		outputStream:toEnd()
		if outputStream.Length < decompressedLen then
			--match
			local offset = string.unpack("<I2", inputStream:read(2))
			if matLen >= 19 then
				repeat
					local nextByte = string.byte(inputStream:read())
					matLen += nextByte
				until nextByte ~= 0xFF
			end

			outputStream:seek(-offset)
			local pos = outputStream.Offset
			local match = outputStream:read(matLen)
			local unreadBytes = outputStream.LastUnreadBytes
			local extra
			if unreadBytes then
				repeat
					outputStream.Offset = pos
					extra = outputStream:read(unreadBytes)
					unreadBytes = outputStream.LastUnreadBytes
					match ..= extra
				until unreadBytes <= 0
			end

			outputStream:append(match)
			outputStream:toEnd()
		end

	until outputStream.Length >= decompressedLen

	return outputStream.Source
end

return lz4
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX8592671D19AF4387A6BD936B82804185">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TableToString</string>
					<string name="ScriptGuid">{8948F8AB-D0FC-44EF-860E-A12D6457882D}</string>
					<ProtectedString name="Source"><![CDATA[local module = {}

module.string = {}

function module.string.luaStringify(str, args)
	-- returns lua string
	-- pre
	assert(type(str) == 'string', 'bad arg #1, not string')
	assert(type(args) == 'table', 'bad arg #2, not table')
	local typeArgs = module.table.getType(args);
	assert(typeArgs == 'dictionary', 'bad arg #2, not dictionary, got' .. typeArgs)
	local stringType = args.stringType
	assert(stringType == 'single' or stringType == 'multiLined', 'arg2.stringType is invalid, got' .. tostring(stringType))

	if stringType == 'single' then
		local token = args.token
		assert(token == '"' or token == "'", 'bad token')
		args.beginToken = token
		args.endToken = token
	elseif stringType == 'multiLined' then
		local equalSignLength = args.equalSignLength or 0

		assert(type(equalSignLength) == 'number', 'got bad type for equalsignlength')
		assert(equalSignLength >= 0, 'equalSignLength out of range, smaller than 0')
		assert(equalSignLength % 1 == 0, 'not an integer')

		args.beginToken = '[' .. ('='):rep(equalSignLength) .. '['
		args.endToken =   ']' .. ('='):rep(equalSignLength) .. ']'
	else
		error'how'
	end

	-- main
	local result = args.beginToken

	for i = 1, #str do
		local char = str:sub(i, i)

		if stringType == 'single' then
			char = 
				char == args.beginToken and '\\' .. args.beginToken or -- ', "
				char == '\n' 			 and '\\n' 					or -- \n
				char == '\\' 			and '\\\\'					or -- \
				char
		elseif stringType == 'multiLined' then
			-- this v
			-- ]====]
			if char == ']' and str:sub(i - #args.beginToken + 1, i) == args.endToken then
				char = '\\]'
			end
		end

		result ..= char
	end

	result ..= args.endToken

	return result
end

function module.string.compare(strA, strB) 
	-- pre
	assert(
		type(strA) == 'string' and 
			type(strB) == 'string'
	)

	strA = tostring(strA)
	strB = tostring(strB)

	-- main
	local result = false
	local lStr = #strA > #strB and strA or strB

	for i = 1, #lStr do
		local cA = strA:sub(i, i)
		local cB = strB:sub(i, i)
		local vA = cA == '' and -1 or cA:byte()
		local vB = cB == '' and -1 or cB:byte()

		if vA ~= vB then
			result = vA < vB
			break
		end
	end

	return result
end

module.table = {}

function module.table.getType(t)
	-- can return "array", "dictionary", "empty", "mixed" or "spotty array"
	assert(type(t) == 'table', 'BAD ARGUMENT: '.. debug.traceback())

	local result

	local stringIndexed = false
	local numberIndexed = false

	local iterations = 0

	for i in next, t do
		iterations += 1
		local typeI = type(i)

		if not stringIndexed and typeI == 'string'then
			stringIndexed = true
		elseif not numberIndexed and typeI == 'number'then
			numberIndexed = true
		end

		if numberIndexed and stringIndexed then
			-- both true, we got what we came for, break
			break
		end
	end

	-- assign result
	result = 
		result or
		numberIndexed and (
			stringIndexed and 'mixed' or 
			#t == iterations and 'array' or
			'spotty array'
		)or 
		stringIndexed and 'dictionary' or 
		'empty'

	assert(result, 'some how not met, nIndexed=' .. tostring(numberIndexed) .. ',sIndexed=' .. tostring(stringIndexed))

	return result
end

function module.table.indexN(t)
	local last
	local result = 0
	repeat
		last = next(t, last)
		result += 1
	until not last
	
	return result - 1
end

function module.table.isSugarIndex(str)
	-- pre
	assert(type(str) == 'string')

	-- main
	local c1 = str:sub(1,1)
	local suffix = str:sub(2)
	
	local result = c1:match('[%a_]') and (not suffix:match('[^%w_]') or suffix == '')

	return result
end

function module.table.toString(
	t: {[any]:any}, 
	indent_unit: string?,
	lvl: number?, 
	depth: number)
	-- displays content inside of the table
	-- pre
	depth = depth or 10
	assert(type(t) == 'table' and type(depth) == 'number')

	if depth <= 0 then return end
	lvl = lvl or 1
	assert(type(lvl) == 'number' and lvl >= 1)
	
	indent_unit = indent_unit or '    '
	assert(type(indent_unit) == 'string', `oops: {indent_unit}`)
	
	-- main
	local result = '{'

	local iterationRan = false

	local tableType = module.table.getType(t)
	local iterations = module.table.indexN(t)
	local currentIteration = 0

	local resultSections = {}

	for i,v in next, t do
		local ivStruct = {
			index = '';
			value = nil;
			precedingWhitespace = nil;
			separator = nil;
		}

		currentIteration += 1

		if not iterationRan then iterationRan = true end

		local tabs = (indent_unit :: string):rep(lvl)
		--local section = '\n' .. tabs
		ivStruct.precedingWhitespace = `\n{tabs}`

		-- handle indexes
		if tableType ~= 'array' then
			local isSugarIndex = type(i) == 'string' and 
				module.table.isSugarIndex(i) -- availble for indexes that comply with lua's sugar syntax for indexes

			if not isSugarIndex then -- possible bracket indication
				ivStruct.index ..= '['
			end

			ivStruct.index ..= (
				(isSugarIndex or type(i) == 'number') and 
					tostring(i) or 
					module.string.luaStringify(i, {
						stringType = 'single';
						token = "'"
					}
				)
			)

			if not isSugarIndex then
				ivStruct.index ..= ']'
			end

			--section = section .. ' = '
		end
		-- handle values

		local metatable = type(v) == 'table' and getmetatable(v)
		local tostringMeta = metatable and metatable.__tostring and metatable.__tostring()

		ivStruct.value = 
			type(v) == 'string' and 
				module.string.luaStringify(v, {
					stringType = v:match('[\n\t]') and 'multiLined' or 'single';
					token = "'"
				}) or 
			type(v) == 'table' and (
				tostringMeta and 
					table.concat(tostringMeta:split('\n'),`\n{tabs}`) or
					module.table.toString(v, indent_unit, lvl + 1, depth - 1) or 
					'(ended recursion, depth limit reached)'
				)or 
			tostring(v)

		-- concat
		--section = section .. printedValues .. 
		ivStruct.separator = 
			tableType == 'array' and ',' or 
			';'

		--result = result .. section

		table.insert(resultSections, ivStruct)
	end

	-- finallize and return
	if iterationRan then
		if tableType ~= 'array' then
			table.sort(resultSections, function (structA, structB)
				return module.string.compare(structA.index, structB.index)
			end)
		end
		local sections = ''

		for i, v in next, resultSections do
			sections ..= 
				v.precedingWhitespace .. 
				v.index .. 
				(tableType ~= 'array' and ' = ' or '') .. 
				v.value
			
			if i ~= #resultSections then
				
				sections ..= v.separator
			end
		end

		result ..=
			sections .. 
			'\n' .. 
			(indent_unit :: string):rep((lvl - 1))
	end

	result ..=  '}'
	return result
end


return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXC7679B7EF8224D5AA8E8E8DDCF85F085">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PMPlaceSave</string>
					<string name="ScriptGuid">{EBD61059-EB5C-4413-AE6F-82E22F275C67}</string>
					<ProtectedString name="Source"><![CDATA[--// TYPE
local Objects = script.Parent
local Class = require(Objects.Class)
local GRMap = require(Objects["@CHL/GameReferralMap"])

type __object = {
	mainFolder: Folder;
	repositories: GRMap.object<Instance>;
	packages: GRMap.object<ModuleScript>;
}
export type object = __object

--// MAIN
local disguise = require(Objects.LuaUTypes).disguise
local module: __object = disguise{}

local Dash = require(Objects["@CHL/DashSingular"])
local InstanceUtils = require(Objects["@CHL/InstanceUtils"])
local goc = InstanceUtils.getOrCreate

local mainFolder: Folder = goc(
	game:GetService('ServerStorage'), 
	'__packageManager',
	'Folder'
)
module.mainFolder = mainFolder

local f = Dash.compose(goc, GRMap.new)

module.repositories = f(mainFolder, 'Repositories', 'Folder')
module.packages = f(mainFolder, 'Packages', 'Folder')

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX2EB6496847EF45EAA92E828F5B505820">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">@CHL/InstanceUtils</string>
					<string name="ScriptGuid">{5E095503-AA07-4362-9FDD-C2E9E8BC110F}</string>
					<ProtectedString name="Source"><![CDATA[--// TYPES
type __module = {
	create: (<A>(class: string, properties: __properties<A>) -> A) | 
		(<A>(class: string) -> (props: __properties<A>) -> A);
	getOrCreate: <A>(
		parent: Instance, 
		name: string, 
		class: __className, 
		properties: __properties<A>?) -> A;
}
export type module = __module

type __className = string;
export type className = __className

type __properties<A> = {[string]: any};
export type properties<A> = __properties<A>

local Objects = script.Parent

local disguise = require(Objects.LuaUTypes).disguise
local TableUtils = require(Objects['@CHL/TableUtils'])

--// MAIN
local module: __module = disguise{}

function create<A>(className: __className, props: __properties<A>?)
	if not props then
		local inst = Instance.new(className)
		
		return function(props2: {[string]: any}?)
			return TableUtils.imprint(inst, disguise(props2), true)
		end
	end
	
	return create(className)(props)
end

module.create = create;

function getOrCreate<A>(
	parent: Instance, 
	name: string, 
	class:__className, 
	properties: __properties<A>?)

	local result = parent:FindFirstChild(name)
	
	if not result then
		local p = properties or {}
		p.Parent = parent;
		p.Name = name
		
		result = create(class, p)
	end
	
	return result
end

module.getOrCreate = getOrCreate

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXF3AADDFB274B452F949381592DB525AC">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Loadstring</string>
					<string name="ScriptGuid">{8F71F44A-F62C-4F93-ADBC-F96A83303CF4}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Credit to einsteinK.
	Credit to Stravant for LBI.
	
	Credit to the creators of all the other modules used in this.
	
	Sceleratis was here and decided modify some things.
	
	einsteinK was here again to fix a bug in LBI for if-statements
--]]

local waitDeps = {
	'FiOne';
	'LuaK';
	'LuaP';
	'LuaU';
	'LuaX';
	'LuaY';
	'LuaZ';
}

for _, v in ipairs(waitDeps) do 
	script:WaitForChild(v)
end

local luaX = require(script.LuaX)
local luaY = require(script.LuaY)
local luaZ = require(script.LuaZ)
local luaU = require(script.LuaU)
local fiOne = require(script.FiOne)

luaX:init()
local LuaState = {}

local gfenv = getfenv
getfenv().script = nil

return function(str,env)
	local f, writer, buff
	env = env or gfenv(2)
	local name = (env.script and env.script:GetFullName())
	local ran, error = pcall(function()
		local zio = luaZ:init(luaZ:make_getS(str), nil)
		if not zio then return error('zio became nil') end
		local func = luaY:parser(LuaState, zio, nil, name or "::Adonis::Loadstring::")
		writer, buff = luaU:make_setS()
		luaU:dump(LuaState, func, writer, buff)
		f = fiOne(buff.data, env)
	end)
	
	if ran then
		return f, buff.data
	else
		return nil, error
	end
end
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXADB5DC567F4446DEB5071E90D638FA29">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">LuaK</string>
						<string name="ScriptGuid">{B4346F0E-2B6C-4A09-80F7-5938435BBDCF}</string>
						<ProtectedString name="Source"><![CDATA[--# selene: allow(incorrect_standard_library_use, multiple_statements, shadowing, unused_variable, empty_if, divide_by_zero, unbalanced_assignments)
--[[--------------------------------------------------------------------

  lcode.lua
  Lua 5 code generator in Lua
  This file is part of Yueliang.

  Copyright (c) 2005-2007 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * one function manipulate a pointer argument with a simple data type
--   (can't be emulated by a table, ambiguous), now returns that value:
--   luaK:concat(fs, l1, l2)
-- * luaM_growvector uses the faux luaY:growvector, for limit checking
-- * some function parameters changed to boolean, additional code
--   translates boolean back to 1/0 for instruction fields
--
-- Not implemented:
-- * NOTE there is a failed assert in luaK:addk, a porting problem
--
-- Added:
-- * constant MAXSTACK from llimits.h
-- * luaK:ttisnumber(o) (from lobject.h)
-- * luaK:nvalue(o) (from lobject.h)
-- * luaK:setnilvalue(o) (from lobject.h)
-- * luaK:setnvalue(o, x) (from lobject.h)
-- * luaK:setbvalue(o, x) (from lobject.h)
-- * luaK:sethvalue(o, x) (from lobject.h), parameter L deleted
-- * luaK:setsvalue(o, x) (from lobject.h), parameter L deleted
-- * luaK:numadd, luaK:numsub, luaK:nummul, luaK:numdiv, luaK:nummod,
--   luaK:numpow, luaK:numunm, luaK:numisnan (from luaconf.h)
-- * copyexp(e1, e2) added in luaK:posfix to copy expdesc struct
--
-- Changed in 5.1.x:
-- * enum BinOpr has a new entry, OPR_MOD
-- * enum UnOpr has a new entry, OPR_LEN
-- * binopistest, unused in 5.0.x, has been deleted
-- * macro setmultret is new
-- * functions isnumeral, luaK_ret, boolK are new
-- * funcion nilK was named nil_constant in 5.0.x
-- * function interface changed: need_value, patchtestreg, concat
-- * TObject now a TValue
-- * functions luaK_setreturns, luaK_setoneret are new
-- * function luaK:setcallreturns deleted, to be replaced by:
--   luaK:setmultret, luaK:ret, luaK:setreturns, luaK:setoneret
-- * functions constfolding, codearith, codecomp are new
-- * luaK:codebinop has been deleted
-- * function luaK_setlist is new
-- * OPR_MULT renamed to OPR_MUL
----------------------------------------------------------------------]]

-- requires luaP, luaX, luaY
local luaY
local luaK = {}
local luaP = require(script.Parent.LuaP)
local luaX = require(script.Parent.LuaX)

------------------------------------------------------------------------
-- constants used by code generator
------------------------------------------------------------------------
-- maximum stack for a Lua function
luaK.MAXSTACK = 250  -- (from llimits.h)

--[[--------------------------------------------------------------------
-- other functions
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- emulation of TValue macros (these are from lobject.h)
-- * TValue is a table since lcode passes references around
-- * tt member field removed, using Lua's type() instead
-- * for setsvalue, sethvalue, parameter L (deleted here) in lobject.h
--   is used in an assert for testing, see checkliveness(g,obj)
------------------------------------------------------------------------
function luaK:ttisnumber(o)
  if o then return type(o.value) == "number" else return false end
end
function luaK:nvalue(o) return o.value end
function luaK:setnilvalue(o) o.value = nil end
function luaK:setsvalue(o, x) o.value = x end
luaK.setnvalue = luaK.setsvalue
luaK.sethvalue = luaK.setsvalue
luaK.setbvalue = luaK.setsvalue

------------------------------------------------------------------------
-- The luai_num* macros define the primitive operations over numbers.
-- * this is not the entire set of primitive operations from luaconf.h
-- * used in luaK:constfolding()
------------------------------------------------------------------------
function luaK:numadd(a, b) return a + b end
function luaK:numsub(a, b) return a - b end
function luaK:nummul(a, b) return a * b end
function luaK:numdiv(a, b) return a / b end
function luaK:nummod(a, b) return a % b end
  -- ((a) - floor((a)/(b))*(b)) /* actual, for reference */
function luaK:numpow(a, b) return a ^ b end
function luaK:numunm(a) return -a end
function luaK:numisnan(a) return not (a == a) end
  -- a NaN cannot equal another NaN

--[[--------------------------------------------------------------------
-- code generator functions
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- Marks the end of a patch list. It is an invalid value both as an absolute
-- address, and as a list link (would link an element to itself).
------------------------------------------------------------------------
luaK.NO_JUMP = -1

------------------------------------------------------------------------
-- grep "ORDER OPR" if you change these enums
------------------------------------------------------------------------
luaK.BinOpr = {
  OPR_ADD = 0, OPR_SUB = 1, OPR_MUL = 2, OPR_DIV = 3, OPR_MOD = 4, OPR_POW = 5,
  OPR_CONCAT = 6,
  OPR_NE = 7, OPR_EQ = 8,
  OPR_LT = 9, OPR_LE = 10, OPR_GT = 11, OPR_GE = 12,
  OPR_AND = 13, OPR_OR = 14,
  OPR_NOBINOPR = 15,
}

-- * UnOpr is used by luaK:prefix's op argument, but not directly used
--   because the function receives the symbols as strings, e.g. "OPR_NOT"
luaK.UnOpr = {
  OPR_MINUS = 0, OPR_NOT = 1, OPR_LEN = 2, OPR_NOUNOPR = 3
}

------------------------------------------------------------------------
-- returns the instruction object for given e (expdesc), was a macro
------------------------------------------------------------------------
function luaK:getcode(fs, e)
  return fs.f.code[e.info]
end

------------------------------------------------------------------------
-- codes an instruction with a signed Bx (sBx) field, was a macro
-- * used in luaK:jump(), (lparser) luaY:forbody()
------------------------------------------------------------------------
function luaK:codeAsBx(fs, o, A, sBx)
  return self:codeABx(fs, o, A, sBx + luaP.MAXARG_sBx)
end

------------------------------------------------------------------------
-- set the expdesc e instruction for multiple returns, was a macro
------------------------------------------------------------------------
function luaK:setmultret(fs, e)
  self:setreturns(fs, e, luaY.LUA_MULTRET)
end

------------------------------------------------------------------------
-- there is a jump if patch lists are not identical, was a macro
-- * used in luaK:exp2reg(), luaK:exp2anyreg(), luaK:exp2val()
------------------------------------------------------------------------
function luaK:hasjumps(e)
  return e.t ~= e.f
end

------------------------------------------------------------------------
-- true if the expression is a constant number (for constant folding)
-- * used in constfolding(), infix()
------------------------------------------------------------------------
function luaK:isnumeral(e)
  return e.k == "VKNUM" and e.t == self.NO_JUMP and e.f == self.NO_JUMP
end

------------------------------------------------------------------------
-- codes loading of nil, optimization done if consecutive locations
-- * used in luaK:discharge2reg(), (lparser) luaY:adjust_assign()
------------------------------------------------------------------------
function luaK:_nil(fs, from, n)
  if fs.pc > fs.lasttarget then  -- no jumps to current position?
    if fs.pc == 0 then  -- function start?
      if from >= fs.nactvar then
        return  -- positions are already clean
      end
    else
      local previous = fs.f.code[fs.pc - 1]
      if luaP:GET_OPCODE(previous) == "OP_LOADNIL" then
        local pfrom = luaP:GETARG_A(previous)
        local pto = luaP:GETARG_B(previous)
        if pfrom <= from and from <= pto + 1 then  -- can connect both?
          if from + n - 1 > pto then
            luaP:SETARG_B(previous, from + n - 1)
          end
          return
        end
      end
    end
  end
  self:codeABC(fs, "OP_LOADNIL", from, from + n - 1, 0)  -- else no optimization
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:jump(fs)
  local jpc = fs.jpc  -- save list of jumps to here
  fs.jpc = self.NO_JUMP
  local j = self:codeAsBx(fs, "OP_JMP", 0, self.NO_JUMP)
  j = self:concat(fs, j, jpc)  -- keep them on hold
  return j
end

------------------------------------------------------------------------
-- codes a RETURN instruction
-- * used in luaY:close_func(), luaY:retstat()
------------------------------------------------------------------------
function luaK:ret(fs, first, nret)
  self:codeABC(fs, "OP_RETURN", first, nret + 1, 0)
end

------------------------------------------------------------------------
--
-- * used in luaK:jumponcond(), luaK:codecomp()
------------------------------------------------------------------------
function luaK:condjump(fs, op, A, B, C)
  self:codeABC(fs, op, A, B, C)
  return self:jump(fs)
end

------------------------------------------------------------------------
--
-- * used in luaK:patchlistaux(), luaK:concat()
------------------------------------------------------------------------
function luaK:fixjump(fs, pc, dest)
  local jmp = fs.f.code[pc]
  local offset = dest - (pc + 1)
  assert(dest ~= self.NO_JUMP)
  if math.abs(offset) > luaP.MAXARG_sBx then
    luaX:syntaxerror(fs.ls, "control structure too long")
  end
  luaP:SETARG_sBx(jmp, offset)
end

------------------------------------------------------------------------
-- returns current 'pc' and marks it as a jump target (to avoid wrong
-- optimizations with consecutive instructions not in the same basic block).
-- * used in multiple locations
-- * fs.lasttarget tested only by luaK:_nil() when optimizing OP_LOADNIL
------------------------------------------------------------------------
function luaK:getlabel(fs)
  fs.lasttarget = fs.pc
  return fs.pc
end

------------------------------------------------------------------------
--
-- * used in luaK:need_value(), luaK:removevalues(), luaK:patchlistaux(),
--   luaK:concat()
------------------------------------------------------------------------
function luaK:getjump(fs, pc)
  local offset = luaP:GETARG_sBx(fs.f.code[pc])
  if offset == self.NO_JUMP then  -- point to itself represents end of list
    return self.NO_JUMP  -- end of list
  else
    return (pc + 1) + offset  -- turn offset into absolute position
  end
end

------------------------------------------------------------------------
--
-- * used in luaK:need_value(), luaK:patchtestreg(), luaK:invertjump()
------------------------------------------------------------------------
function luaK:getjumpcontrol(fs, pc)
  local pi = fs.f.code[pc]
  local ppi = fs.f.code[pc - 1]
  if pc >= 1 and luaP:testTMode(luaP:GET_OPCODE(ppi)) ~= 0 then
    return ppi
  else
    return pi
  end
end

------------------------------------------------------------------------
-- check whether list has any jump that do not produce a value
-- (or produce an inverted value)
-- * return value changed to boolean
-- * used only in luaK:exp2reg()
------------------------------------------------------------------------
function luaK:need_value(fs, list)
  while list ~= self.NO_JUMP do
    local i = self:getjumpcontrol(fs, list)
    if luaP:GET_OPCODE(i) ~= "OP_TESTSET" then return true end
    list = self:getjump(fs, list)
  end
  return false  -- not found
end

------------------------------------------------------------------------
--
-- * used in luaK:removevalues(), luaK:patchlistaux()
------------------------------------------------------------------------
function luaK:patchtestreg(fs, node, reg)
  local i = self:getjumpcontrol(fs, node)
  if luaP:GET_OPCODE(i) ~= "OP_TESTSET" then
    return false  -- cannot patch other instructions
  end
  if reg ~= luaP.NO_REG and reg ~= luaP:GETARG_B(i) then
    luaP:SETARG_A(i, reg)
  else  -- no register to put value or register already has the value
    -- due to use of a table as i, i cannot be replaced by another table
    -- so the following is required; there is no change to ARG_C
    luaP:SET_OPCODE(i, "OP_TEST")
    local b = luaP:GETARG_B(i)
    luaP:SETARG_A(i, b)
    luaP:SETARG_B(i, 0)
    -- *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i)); /* C */
  end
  return true
end

------------------------------------------------------------------------
--
-- * used only in luaK:codenot()
------------------------------------------------------------------------
function luaK:removevalues(fs, list)
  while list ~= self.NO_JUMP do
    self:patchtestreg(fs, list, luaP.NO_REG)
    list = self:getjump(fs, list)
  end
end

------------------------------------------------------------------------
--
-- * used in luaK:dischargejpc(), luaK:patchlist(), luaK:exp2reg()
------------------------------------------------------------------------
function luaK:patchlistaux(fs, list, vtarget, reg, dtarget)
  while list ~= self.NO_JUMP do
    local _next = self:getjump(fs, list)
    if self:patchtestreg(fs, list, reg) then
      self:fixjump(fs, list, vtarget)
    else
      self:fixjump(fs, list, dtarget)  -- jump to default target
    end
    list = _next
  end
end

------------------------------------------------------------------------
--
-- * used only in luaK:code()
------------------------------------------------------------------------
function luaK:dischargejpc(fs)
  self:patchlistaux(fs, fs.jpc, fs.pc, luaP.NO_REG, fs.pc)
  fs.jpc = self.NO_JUMP
end

------------------------------------------------------------------------
--
-- * used in (lparser) luaY:whilestat(), luaY:repeatstat(), luaY:forbody()
------------------------------------------------------------------------
function luaK:patchlist(fs, list, target)
  if target == fs.pc then
    self:patchtohere(fs, list)
  else
    assert(target < fs.pc)
    self:patchlistaux(fs, list, target, luaP.NO_REG, target)
  end
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:patchtohere(fs, list)
  self:getlabel(fs)
  fs.jpc = self:concat(fs, fs.jpc, list)
end

------------------------------------------------------------------------
-- * l1 was a pointer, now l1 is returned and callee assigns the value
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:concat(fs, l1, l2)
  if l2 == self.NO_JUMP then return l1
  elseif l1 == self.NO_JUMP then
    return l2
  else
    local list = l1
    local _next = self:getjump(fs, list)
    while _next ~= self.NO_JUMP do  -- find last element
      list = _next
      _next = self:getjump(fs, list)
    end
    self:fixjump(fs, list, l2)
  end
  return l1
end

------------------------------------------------------------------------
--
-- * used in luaK:reserveregs(), (lparser) luaY:forlist()
------------------------------------------------------------------------
function luaK:checkstack(fs, n)
  local newstack = fs.freereg + n
  if newstack > fs.f.maxstacksize then
    if newstack >= self.MAXSTACK then
      luaX:syntaxerror(fs.ls, "function or expression too complex")
    end
    fs.f.maxstacksize = newstack
  end
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:reserveregs(fs, n)
  self:checkstack(fs, n)
  fs.freereg = fs.freereg + n
end

------------------------------------------------------------------------
--
-- * used in luaK:freeexp(), luaK:dischargevars()
------------------------------------------------------------------------
function luaK:freereg(fs, reg)
  if not luaP:ISK(reg) and reg >= fs.nactvar then
    fs.freereg = fs.freereg - 1
    assert(reg == fs.freereg)
  end
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:freeexp(fs, e)
  if e.k == "VNONRELOC" then
    self:freereg(fs, e.info)
  end
end

------------------------------------------------------------------------
-- * TODO NOTE implementation is not 100% correct, since the assert fails
-- * luaH_set, setobj deleted; direct table access used instead
-- * used in luaK:stringK(), luaK:numberK(), luaK:boolK(), luaK:nilK()
------------------------------------------------------------------------
function luaK:addk(fs, k, v)
  local L = fs.L
  local idx = fs.h[k.value]
  --TValue *idx = luaH_set(L, fs->h, k); /* C */
  local f = fs.f
  if self:ttisnumber(idx) then
    --TODO this assert currently FAILS (last tested for 5.0.2)
    --assert(fs.f.k[self:nvalue(idx)] == v)
    --assert(luaO_rawequalObj(&fs->f->k[cast_int(nvalue(idx))], v)); /* C */
    return self:nvalue(idx)
  else -- constant not found; create a new entry
    idx = {}
    self:setnvalue(idx, fs.nk)
    fs.h[k.value] = idx
    -- setnvalue(idx, cast_num(fs->nk)); /* C */
    luaY:growvector(L, f.k, fs.nk, f.sizek, nil,
                    luaP.MAXARG_Bx, "constant table overflow")
    -- loop to initialize empty f.k positions not required
    f.k[fs.nk] = v
    -- setobj(L, &f->k[fs->nk], v); /* C */
    -- luaC_barrier(L, f, v); /* GC */
    local nk = fs.nk
    fs.nk = fs.nk + 1
    return nk
  end

end

------------------------------------------------------------------------
-- creates and sets a string object
-- * used in (lparser) luaY:codestring(), luaY:singlevar()
------------------------------------------------------------------------
function luaK:stringK(fs, s)
  local o = {}  -- TValue
  self:setsvalue(o, s)
  return self:addk(fs, o, o)
end

------------------------------------------------------------------------
-- creates and sets a number object
-- * used in luaK:prefix() for negative (or negation of) numbers
-- * used in (lparser) luaY:simpleexp(), luaY:fornum()
------------------------------------------------------------------------
function luaK:numberK(fs, r)
  local o = {}  -- TValue
  self:setnvalue(o, r)
  return self:addk(fs, o, o)
end

------------------------------------------------------------------------
-- creates and sets a boolean object
-- * used only in luaK:exp2RK()
------------------------------------------------------------------------
function luaK:boolK(fs, b)
  local o = {}  -- TValue
  self:setbvalue(o, b)
  return self:addk(fs, o, o)
end

------------------------------------------------------------------------
-- creates and sets a nil object
-- * used only in luaK:exp2RK()
------------------------------------------------------------------------
function luaK:nilK(fs)
  local k, v = {}, {}  -- TValue
  self:setnilvalue(v)
  -- cannot use nil as key; instead use table itself to represent nil
  self:sethvalue(k, fs.h)
  return self:addk(fs, k, v)
end

------------------------------------------------------------------------
--
-- * used in luaK:setmultret(), (lparser) luaY:adjust_assign()
------------------------------------------------------------------------
function luaK:setreturns(fs, e, nresults)
  if e.k == "VCALL" then  -- expression is an open function call?
    luaP:SETARG_C(self:getcode(fs, e), nresults + 1)
  elseif e.k == "VVARARG" then
    luaP:SETARG_B(self:getcode(fs, e), nresults + 1);
    luaP:SETARG_A(self:getcode(fs, e), fs.freereg);
    luaK:reserveregs(fs, 1)
  end
end

------------------------------------------------------------------------
--
-- * used in luaK:dischargevars(), (lparser) luaY:assignment()
------------------------------------------------------------------------
function luaK:setoneret(fs, e)
  if e.k == "VCALL" then  -- expression is an open function call?
    e.k = "VNONRELOC"
    e.info = luaP:GETARG_A(self:getcode(fs, e))
  elseif e.k == "VVARARG" then
    luaP:SETARG_B(self:getcode(fs, e), 2)
    e.k = "VRELOCABLE"  -- can relocate its simple result
  end
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:dischargevars(fs, e)
  local k = e.k
  if k == "VLOCAL" then
    e.k = "VNONRELOC"
  elseif k == "VUPVAL" then
    e.info = self:codeABC(fs, "OP_GETUPVAL", 0, e.info, 0)
    e.k = "VRELOCABLE"
  elseif k == "VGLOBAL" then
    e.info = self:codeABx(fs, "OP_GETGLOBAL", 0, e.info)
    e.k = "VRELOCABLE"
  elseif k == "VINDEXED" then
    self:freereg(fs, e.aux)
    self:freereg(fs, e.info)
    e.info = self:codeABC(fs, "OP_GETTABLE", 0, e.info, e.aux)
    e.k = "VRELOCABLE"
  elseif k == "VVARARG" or k == "VCALL" then
    self:setoneret(fs, e)
  else
    -- there is one value available (somewhere)
  end
end

------------------------------------------------------------------------
--
-- * used only in luaK:exp2reg()
------------------------------------------------------------------------
function luaK:code_label(fs, A, b, jump)
  self:getlabel(fs)  -- those instructions may be jump targets
  return self:codeABC(fs, "OP_LOADBOOL", A, b, jump)
end

------------------------------------------------------------------------
--
-- * used in luaK:discharge2anyreg(), luaK:exp2reg()
------------------------------------------------------------------------
function luaK:discharge2reg(fs, e, reg)
  self:dischargevars(fs, e)
  local k = e.k
  if k == "VNIL" then
    self:_nil(fs, reg, 1)
  elseif k == "VFALSE" or k == "VTRUE" then
    self:codeABC(fs, "OP_LOADBOOL", reg, (e.k == "VTRUE") and 1 or 0, 0)
  elseif k == "VK" then
    self:codeABx(fs, "OP_LOADK", reg, e.info)
  elseif k == "VKNUM" then
    self:codeABx(fs, "OP_LOADK", reg, self:numberK(fs, e.nval))
  elseif k == "VRELOCABLE" then
    local pc = self:getcode(fs, e)
    luaP:SETARG_A(pc, reg)
  elseif k == "VNONRELOC" then
    if reg ~= e.info then
      self:codeABC(fs, "OP_MOVE", reg, e.info, 0)
    end
  else
    assert(e.k == "VVOID" or e.k == "VJMP")
    return  -- nothing to do...
  end
  e.info = reg
  e.k = "VNONRELOC"
end

------------------------------------------------------------------------
--
-- * used in luaK:jumponcond(), luaK:codenot()
------------------------------------------------------------------------
function luaK:discharge2anyreg(fs, e)
  if e.k ~= "VNONRELOC" then
    self:reserveregs(fs, 1)
    self:discharge2reg(fs, e, fs.freereg - 1)
  end
end

------------------------------------------------------------------------
--
-- * used in luaK:exp2nextreg(), luaK:exp2anyreg(), luaK:storevar()
------------------------------------------------------------------------
function luaK:exp2reg(fs, e, reg)
  self:discharge2reg(fs, e, reg)
  if e.k == "VJMP" then
    e.t = self:concat(fs, e.t, e.info)  -- put this jump in 't' list
  end
  if self:hasjumps(e) then
    local final  -- position after whole expression
    local p_f = self.NO_JUMP  -- position of an eventual LOAD false
    local p_t = self.NO_JUMP  -- position of an eventual LOAD true
    if self:need_value(fs, e.t) or self:need_value(fs, e.f) then
      local fj = (e.k == "VJMP") and self.NO_JUMP or self:jump(fs)
      p_f = self:code_label(fs, reg, 0, 1)
      p_t = self:code_label(fs, reg, 1, 0)
      self:patchtohere(fs, fj)
    end
    final = self:getlabel(fs)
    self:patchlistaux(fs, e.f, final, reg, p_f)
    self:patchlistaux(fs, e.t, final, reg, p_t)
  end
  e.f, e.t = self.NO_JUMP, self.NO_JUMP
  e.info = reg
  e.k = "VNONRELOC"
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:exp2nextreg(fs, e)
  self:dischargevars(fs, e)
  self:freeexp(fs, e)
  self:reserveregs(fs, 1)
  self:exp2reg(fs, e, fs.freereg - 1)
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:exp2anyreg(fs, e)
  self:dischargevars(fs, e)
  if e.k == "VNONRELOC" then
    if not self:hasjumps(e) then  -- exp is already in a register
      return e.info
    end
    if e.info >= fs.nactvar then  -- reg. is not a local?
      self:exp2reg(fs, e, e.info)  -- put value on it
      return e.info
    end
  end
  self:exp2nextreg(fs, e)  -- default
  return e.info
end

------------------------------------------------------------------------
--
-- * used in luaK:exp2RK(), luaK:prefix(), luaK:posfix()
-- * used in (lparser) luaY:yindex()
------------------------------------------------------------------------
function luaK:exp2val(fs, e)
  if self:hasjumps(e) then
    self:exp2anyreg(fs, e)
  else
    self:dischargevars(fs, e)
  end
end

------------------------------------------------------------------------
--
-- * used in multiple locations
------------------------------------------------------------------------
function luaK:exp2RK(fs, e)
  self:exp2val(fs, e)
  local k = e.k
  if k == "VKNUM" or k == "VTRUE" or k == "VFALSE" or k == "VNIL" then
    if fs.nk <= luaP.MAXINDEXRK then  -- constant fit in RK operand?
      -- converted from a 2-deep ternary operator expression
      if e.k == "VNIL" then
        e.info = self:nilK(fs)
      else
        e.info = (e.k == "VKNUM") and self:numberK(fs, e.nval)
                                  or self:boolK(fs, e.k == "VTRUE")
      end
      e.k = "VK"
      return luaP:RKASK(e.info)
    end
  elseif k == "VK" then
    if e.info <= luaP.MAXINDEXRK then  -- constant fit in argC?
      return luaP:RKASK(e.info)
    end
  else
    -- default
  end
  -- not a constant in the right range: put it in a register
  return self:exp2anyreg(fs, e)
end

------------------------------------------------------------------------
--
-- * used in (lparser) luaY:assignment(), luaY:localfunc(), luaY:funcstat()
------------------------------------------------------------------------
function luaK:storevar(fs, var, ex)
  local k = var.k
  if k == "VLOCAL" then
    self:freeexp(fs, ex)
    self:exp2reg(fs, ex, var.info)
    return
  elseif k == "VUPVAL" then
    local e = self:exp2anyreg(fs, ex)
    self:codeABC(fs, "OP_SETUPVAL", e, var.info, 0)
  elseif k == "VGLOBAL" then
    local e = self:exp2anyreg(fs, ex)
    self:codeABx(fs, "OP_SETGLOBAL", e, var.info)
  elseif k == "VINDEXED" then
    local e = self:exp2RK(fs, ex)
    self:codeABC(fs, "OP_SETTABLE", var.info, var.aux, e)
  else
    assert(0)  -- invalid var kind to store
  end
  self:freeexp(fs, ex)
end

------------------------------------------------------------------------
--
-- * used only in (lparser) luaY:primaryexp()
------------------------------------------------------------------------
function luaK:_self(fs, e, key)
  self:exp2anyreg(fs, e)
  self:freeexp(fs, e)
  local func = fs.freereg
  self:reserveregs(fs, 2)
  self:codeABC(fs, "OP_SELF", func, e.info, self:exp2RK(fs, key))
  self:freeexp(fs, key)
  e.info = func
  e.k = "VNONRELOC"
end

------------------------------------------------------------------------
--
-- * used in luaK:goiftrue(), luaK:codenot()
------------------------------------------------------------------------
function luaK:invertjump(fs, e)
  local pc = self:getjumpcontrol(fs, e.info)
  assert(luaP:testTMode(luaP:GET_OPCODE(pc)) ~= 0 and
             luaP:GET_OPCODE(pc) ~= "OP_TESTSET" and
             luaP:GET_OPCODE(pc) ~= "OP_TEST")
  luaP:SETARG_A(pc, (luaP:GETARG_A(pc) == 0) and 1 or 0)
end

------------------------------------------------------------------------
--
-- * used in luaK:goiftrue(), luaK:goiffalse()
------------------------------------------------------------------------
function luaK:jumponcond(fs, e, cond)
  if e.k == "VRELOCABLE" then
    local ie = self:getcode(fs, e)
    if luaP:GET_OPCODE(ie) == "OP_NOT" then
      fs.pc = fs.pc - 1  -- remove previous OP_NOT
      return self:condjump(fs, "OP_TEST", luaP:GETARG_B(ie), 0, cond and 0 or 1)
    end
    -- else go through
  end
  self:discharge2anyreg(fs, e)
  self:freeexp(fs, e)
  return self:condjump(fs, "OP_TESTSET", luaP.NO_REG, e.info, cond and 1 or 0)
end

------------------------------------------------------------------------
--
-- * used in luaK:infix(), (lparser) luaY:cond()
------------------------------------------------------------------------
function luaK:goiftrue(fs, e)
  local pc  -- pc of last jump
  self:dischargevars(fs, e)
  local k = e.k
  if k == "VK" or k == "VKNUM" or k == "VTRUE" then
    pc = self.NO_JUMP  -- always true; do nothing
  elseif k == "VFALSE" then
    pc = self:jump(fs)  -- always jump
  elseif k == "VJMP" then
    self:invertjump(fs, e)
    pc = e.info
  else
    pc = self:jumponcond(fs, e, false)
  end
  e.f = self:concat(fs, e.f, pc)  -- insert last jump in `f' list
  self:patchtohere(fs, e.t)
  e.t = self.NO_JUMP
end

------------------------------------------------------------------------
--
-- * used in luaK:infix()
------------------------------------------------------------------------
function luaK:goiffalse(fs, e)
  local pc  -- pc of last jump
  self:dischargevars(fs, e)
  local k = e.k
  if k == "VNIL" or k == "VFALSE"then
    pc = self.NO_JUMP  -- always false; do nothing
  elseif k == "VTRUE" then
    pc = self:jump(fs)  -- always jump
  elseif k == "VJMP" then
    pc = e.info
  else
    pc = self:jumponcond(fs, e, true)
  end
  e.t = self:concat(fs, e.t, pc)  -- insert last jump in `t' list
  self:patchtohere(fs, e.f)
  e.f = self.NO_JUMP
end

------------------------------------------------------------------------
--
-- * used only in luaK:prefix()
------------------------------------------------------------------------
function luaK:codenot(fs, e)
  self:dischargevars(fs, e)
  local k = e.k
  if k == "VNIL" or k == "VFALSE" then
    e.k = "VTRUE"
  elseif k == "VK" or k == "VKNUM" or k == "VTRUE" then
    e.k = "VFALSE"
  elseif k == "VJMP" then
    self:invertjump(fs, e)
  elseif k == "VRELOCABLE" or k == "VNONRELOC" then
    self:discharge2anyreg(fs, e)
    self:freeexp(fs, e)
    e.info = self:codeABC(fs, "OP_NOT", 0, e.info, 0)
    e.k = "VRELOCABLE"
  else
    assert(0)  -- cannot happen
  end
  -- interchange true and false lists
  e.f, e.t = e.t, e.f
  self:removevalues(fs, e.f)
  self:removevalues(fs, e.t)
end

------------------------------------------------------------------------
--
-- * used in (lparser) luaY:field(), luaY:primaryexp()
------------------------------------------------------------------------
function luaK:indexed(fs, t, k)
  t.aux = self:exp2RK(fs, k)
  t.k = "VINDEXED"
end

------------------------------------------------------------------------
--
-- * used only in luaK:codearith()
------------------------------------------------------------------------
function luaK:constfolding(op, e1, e2)
  local r
  if not self:isnumeral(e1) or not self:isnumeral(e2) then return false end
  local v1 = e1.nval
  local v2 = e2.nval
  if op == "OP_ADD" then
    r = self:numadd(v1, v2)
  elseif op == "OP_SUB" then
    r = self:numsub(v1, v2)
  elseif op == "OP_MUL" then
    r = self:nummul(v1, v2)
  elseif op == "OP_DIV" then
    if v2 == 0 then return false end  -- do not attempt to divide by 0
    r = self:numdiv(v1, v2)
  elseif op == "OP_MOD" then
    if v2 == 0 then return false end  -- do not attempt to divide by 0
    r = self:nummod(v1, v2)
  elseif op == "OP_POW" then
    r = self:numpow(v1, v2)
  elseif op == "OP_UNM" then
    r = self:numunm(v1)
  elseif op == "OP_LEN" then
    return false  -- no constant folding for 'len'
  else
    assert(0)
    r = 0
  end
  if self:numisnan(r) then return false end  -- do not attempt to produce NaN
  e1.nval = r
  return true
end

------------------------------------------------------------------------
--
-- * used in luaK:prefix(), luaK:posfix()
------------------------------------------------------------------------
function luaK:codearith(fs, op, e1, e2)
  if self:constfolding(op, e1, e2) then
    return
  else
    local o2 = (op ~= "OP_UNM" and op ~= "OP_LEN") and self:exp2RK(fs, e2) or 0
    local o1 = self:exp2RK(fs, e1)
    if o1 > o2 then
      self:freeexp(fs, e1)
      self:freeexp(fs, e2)
    else
      self:freeexp(fs, e2)
      self:freeexp(fs, e1)
    end
    e1.info = self:codeABC(fs, op, 0, o1, o2)
    e1.k = "VRELOCABLE"
  end
end

------------------------------------------------------------------------
--
-- * used only in luaK:posfix()
------------------------------------------------------------------------
function luaK:codecomp(fs, op, cond, e1, e2)
  local o1 = self:exp2RK(fs, e1)
  local o2 = self:exp2RK(fs, e2)
  self:freeexp(fs, e2)
  self:freeexp(fs, e1)
  if cond == 0 and op ~= "OP_EQ" then
    -- exchange args to replace by `<' or `<='
    o1, o2 = o2, o1  -- o1 <==> o2
    cond = 1
  end
  e1.info = self:condjump(fs, op, cond, o1, o2)
  e1.k = "VJMP"
end

------------------------------------------------------------------------
--
-- * used only in (lparser) luaY:subexpr()
------------------------------------------------------------------------
function luaK:prefix(fs, op, e)
  local e2 = {}  -- expdesc
  e2.t, e2.f = self.NO_JUMP, self.NO_JUMP
  e2.k = "VKNUM"
  e2.nval = 0
  if op == "OPR_MINUS" then
    if not self:isnumeral(e) then
      self:exp2anyreg(fs, e)  -- cannot operate on non-numeric constants
    end
    self:codearith(fs, "OP_UNM", e, e2)
  elseif op == "OPR_NOT" then
    self:codenot(fs, e)
  elseif op == "OPR_LEN" then
    self:exp2anyreg(fs, e)  -- cannot operate on constants
    self:codearith(fs, "OP_LEN", e, e2)
  else
    assert(0)
  end
end

------------------------------------------------------------------------
--
-- * used only in (lparser) luaY:subexpr()
------------------------------------------------------------------------
function luaK:infix(fs, op, v)
  if op == "OPR_AND" then
    self:goiftrue(fs, v)
  elseif op == "OPR_OR" then
    self:goiffalse(fs, v)
  elseif op == "OPR_CONCAT" then
    self:exp2nextreg(fs, v)  -- operand must be on the 'stack'
  elseif op == "OPR_ADD" or op == "OPR_SUB" or
         op == "OPR_MUL" or op == "OPR_DIV" or
         op == "OPR_MOD" or op == "OPR_POW" then
    if not self:isnumeral(v) then self:exp2RK(fs, v) end
  else
    self:exp2RK(fs, v)
  end
end

------------------------------------------------------------------------
--
-- * used only in (lparser) luaY:subexpr()
------------------------------------------------------------------------
-- table lookups to simplify testing
luaK.arith_op = {
  OPR_ADD = "OP_ADD", OPR_SUB = "OP_SUB", OPR_MUL = "OP_MUL",
  OPR_DIV = "OP_DIV", OPR_MOD = "OP_MOD", OPR_POW = "OP_POW",
}
luaK.comp_op = {
  OPR_EQ = "OP_EQ", OPR_NE = "OP_EQ", OPR_LT = "OP_LT",
  OPR_LE = "OP_LE", OPR_GT = "OP_LT", OPR_GE = "OP_LE",
}
luaK.comp_cond = {
  OPR_EQ = 1, OPR_NE = 0, OPR_LT = 1,
  OPR_LE = 1, OPR_GT = 0, OPR_GE = 0,
}
function luaK:posfix(fs, op, e1, e2)
  -- needed because e1 = e2 doesn't copy values...
  -- * in 5.0.x, only k/info/aux/t/f copied, t for AND, f for OR
  --   but here, all elements are copied for completeness' sake
  local function copyexp(e1, e2)
    e1.k = e2.k
    e1.info = e2.info; e1.aux = e2.aux
    e1.nval = e2.nval
    e1.t = e2.t; e1.f = e2.f
  end
  if op == "OPR_AND" then
    assert(e1.t == self.NO_JUMP)  -- list must be closed
    self:dischargevars(fs, e2)
    e2.f = self:concat(fs, e2.f, e1.f)
    copyexp(e1, e2)
  elseif op == "OPR_OR" then
    assert(e1.f == self.NO_JUMP)  -- list must be closed
    self:dischargevars(fs, e2)
    e2.t = self:concat(fs, e2.t, e1.t)
    copyexp(e1, e2)
  elseif op == "OPR_CONCAT" then
    self:exp2val(fs, e2)
    if e2.k == "VRELOCABLE" and luaP:GET_OPCODE(self:getcode(fs, e2)) == "OP_CONCAT" then
      assert(e1.info == luaP:GETARG_B(self:getcode(fs, e2)) - 1)
      self:freeexp(fs, e1)
      luaP:SETARG_B(self:getcode(fs, e2), e1.info)
      e1.k = "VRELOCABLE"
      e1.info = e2.info
    else
      self:exp2nextreg(fs, e2)  -- operand must be on the 'stack'
      self:codearith(fs, "OP_CONCAT", e1, e2)
    end
  else
    -- the following uses a table lookup in place of conditionals
    local arith = self.arith_op[op]
    if arith then
      self:codearith(fs, arith, e1, e2)
    else
      local comp = self.comp_op[op]
      if comp then
        self:codecomp(fs, comp, self.comp_cond[op], e1, e2)
      else
        assert(0)
      end
    end--if arith
  end--if op
end

------------------------------------------------------------------------
-- adjusts debug information for last instruction written, in order to
-- change the line where item comes into existence
-- * used in (lparser) luaY:funcargs(), luaY:forbody(), luaY:funcstat()
------------------------------------------------------------------------
function luaK:fixline(fs, line)
  fs.f.lineinfo[fs.pc - 1] = line
end

------------------------------------------------------------------------
-- general function to write an instruction into the instruction buffer,
-- sets debug information too
-- * used in luaK:codeABC(), luaK:codeABx()
-- * called directly by (lparser) luaY:whilestat()
------------------------------------------------------------------------
function luaK:code(fs, i, line)
  local f = fs.f
  self:dischargejpc(fs)  -- 'pc' will change
  -- put new instruction in code array
  luaY:growvector(fs.L, f.code, fs.pc, f.sizecode, nil,
                  luaY.MAX_INT, "code size overflow")
  f.code[fs.pc] = i
  -- save corresponding line information
  luaY:growvector(fs.L, f.lineinfo, fs.pc, f.sizelineinfo, nil,
                  luaY.MAX_INT, "code size overflow")
  f.lineinfo[fs.pc] = line
  local pc = fs.pc
  fs.pc = fs.pc + 1
  return pc
end

------------------------------------------------------------------------
-- writes an instruction of type ABC
-- * calls luaK:code()
------------------------------------------------------------------------
function luaK:codeABC(fs, o, a, b, c)
  assert(luaP:getOpMode(o) == luaP.OpMode.iABC)
  assert(luaP:getBMode(o) ~= luaP.OpArgMask.OpArgN or b == 0)
  assert(luaP:getCMode(o) ~= luaP.OpArgMask.OpArgN or c == 0)
  return self:code(fs, luaP:CREATE_ABC(o, a, b, c), fs.ls.lastline)
end

------------------------------------------------------------------------
-- writes an instruction of type ABx
-- * calls luaK:code(), called by luaK:codeAsBx()
------------------------------------------------------------------------
function luaK:codeABx(fs, o, a, bc)
  assert(luaP:getOpMode(o) == luaP.OpMode.iABx or
             luaP:getOpMode(o) == luaP.OpMode.iAsBx)
  assert(luaP:getCMode(o) == luaP.OpArgMask.OpArgN)
  return self:code(fs, luaP:CREATE_ABx(o, a, bc), fs.ls.lastline)
end

------------------------------------------------------------------------
--
-- * used in (lparser) luaY:closelistfield(), luaY:lastlistfield()
------------------------------------------------------------------------
function luaK:setlist(fs, base, nelems, tostore)
  local c = math.floor((nelems - 1)/luaP.LFIELDS_PER_FLUSH) + 1
  local b = (tostore == luaY.LUA_MULTRET) and 0 or tostore
  assert(tostore ~= 0)
  if c <= luaP.MAXARG_C then
    self:codeABC(fs, "OP_SETLIST", base, b, c)
  else
    self:codeABC(fs, "OP_SETLIST", base, b, 0)
    self:code(fs, luaP:CREATE_Inst(c), fs.ls.lastline)
  end
  fs.freereg = base + 1  -- free registers with list values
end

return function(a) luaY = a return luaK end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9C72F977809C41CABE0A02BDD8ACA2C6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">LuaP</string>
						<string name="ScriptGuid">{6F1E0D85-8E63-4EF6-AAFE-846BA8B96A53}</string>
						<ProtectedString name="Source"><![CDATA[--# selene: allow(incorrect_standard_library_use, multiple_statements, shadowing, unused_variable, empty_if, divide_by_zero, unbalanced_assignments)
--[[--------------------------------------------------------------------

  lopcodes.lua
  Lua 5 virtual machine opcodes in Lua
  This file is part of Yueliang.

  Copyright (c) 2006 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * an Instruction is a table with OP, A, B, C, Bx elements; this
--   makes the code easy to follow and should allow instruction handling
--   to work with doubles and ints
-- * WARNING luaP:Instruction outputs instructions encoded in little-
--   endian form and field size and positions are hard-coded
--
-- Not implemented:
-- *
--
-- Added:
-- * luaP:CREATE_Inst(c): create an inst from a number (for OP_SETLIST)
-- * luaP:Instruction(i): convert field elements to a 4-char string
-- * luaP:DecodeInst(x): convert 4-char string into field elements
--
-- Changed in 5.1.x:
-- * POS_OP added, instruction field positions changed
-- * some symbol names may have changed, e.g. LUAI_BITSINT
-- * new operators for RK indices: BITRK, ISK(x), INDEXK(r), RKASK(x)
-- * OP_MOD, OP_LEN is new
-- * OP_TEST is now OP_TESTSET, OP_TEST is new
-- * OP_FORLOOP, OP_TFORLOOP adjusted, OP_FORPREP is new
-- * OP_TFORPREP deleted
-- * OP_SETLIST and OP_SETLISTO merged and extended
-- * OP_VARARG is new
-- * many changes to implementation of OpMode data
----------------------------------------------------------------------]]

local luaP = {}

--[[
===========================================================================
  We assume that instructions are unsigned numbers.
  All instructions have an opcode in the first 6 bits.
  Instructions can have the following fields:
        'A' : 8 bits
        'B' : 9 bits
        'C' : 9 bits
        'Bx' : 18 bits ('B' and 'C' together)
        'sBx' : signed Bx

  A signed argument is represented in excess K; that is, the number
  value is the unsigned value minus K. K is exactly the maximum value
  for that argument (so that -max is represented by 0, and +max is
  represented by 2*max), which is half the maximum for the corresponding
  unsigned argument.
===========================================================================
--]]

luaP.OpMode = { iABC = 0, iABx = 1, iAsBx = 2 }  -- basic instruction format

------------------------------------------------------------------------
-- size and position of opcode arguments.
-- * WARNING size and position is hard-coded elsewhere in this script
------------------------------------------------------------------------
luaP.SIZE_C  = 9
luaP.SIZE_B  = 9
luaP.SIZE_Bx = luaP.SIZE_C + luaP.SIZE_B
luaP.SIZE_A  = 8

luaP.SIZE_OP = 6

luaP.POS_OP = 0
luaP.POS_A  = luaP.POS_OP + luaP.SIZE_OP
luaP.POS_C  = luaP.POS_A + luaP.SIZE_A
luaP.POS_B  = luaP.POS_C + luaP.SIZE_C
luaP.POS_Bx = luaP.POS_C

------------------------------------------------------------------------
-- limits for opcode arguments.
-- we use (signed) int to manipulate most arguments,
-- so they must fit in LUAI_BITSINT-1 bits (-1 for sign)
------------------------------------------------------------------------
-- removed "#if SIZE_Bx < BITS_INT-1" test, assume this script is
-- running on a Lua VM with double or int as LUA_NUMBER

luaP.MAXARG_Bx  = math.ldexp(1, luaP.SIZE_Bx) - 1
luaP.MAXARG_sBx = math.floor(luaP.MAXARG_Bx / 2)  -- 'sBx' is signed

luaP.MAXARG_A = math.ldexp(1, luaP.SIZE_A) - 1
luaP.MAXARG_B = math.ldexp(1, luaP.SIZE_B) - 1
luaP.MAXARG_C = math.ldexp(1, luaP.SIZE_C) - 1

-- creates a mask with 'n' 1 bits at position 'p'
-- MASK1(n,p) deleted, not required
-- creates a mask with 'n' 0 bits at position 'p'
-- MASK0(n,p) deleted, not required

--[[--------------------------------------------------------------------
  Visual representation for reference:

   31    |    |     |            0      bit position
    +-----+-----+-----+----------+
    |  B  |  C  |  A  |  Opcode  |      iABC format
    +-----+-----+-----+----------+
    -  9  -  9  -  8  -    6     -      field sizes
    +-----+-----+-----+----------+
    |   [s]Bx   |  A  |  Opcode  |      iABx | iAsBx format
    +-----+-----+-----+----------+

----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- the following macros help to manipulate instructions
-- * changed to a table object representation, very clean compared to
--   the [nightmare] alternatives of using a number or a string
-- * Bx is a separate element from B and C, since there is never a need
--   to split Bx in the parser or code generator
------------------------------------------------------------------------

-- these accept or return opcodes in the form of string names
function luaP:GET_OPCODE(i) return self.ROpCode[i.OP] end
function luaP:SET_OPCODE(i, o) i.OP = self.OpCode[o] end

function luaP:GETARG_A(i) return i.A end
function luaP:SETARG_A(i, u) i.A = u end

function luaP:GETARG_B(i) return i.B end
function luaP:SETARG_B(i, b) i.B = b end

function luaP:GETARG_C(i) return i.C end
function luaP:SETARG_C(i, b) i.C = b end

function luaP:GETARG_Bx(i) return i.Bx end
function luaP:SETARG_Bx(i, b) i.Bx = b end

function luaP:GETARG_sBx(i) return i.Bx - self.MAXARG_sBx end
function luaP:SETARG_sBx(i, b) i.Bx = b + self.MAXARG_sBx end

function luaP:CREATE_ABC(o,a,b,c)
  return {OP = self.OpCode[o], A = a, B = b, C = c}
end

function luaP:CREATE_ABx(o,a,bc)
  return {OP = self.OpCode[o], A = a, Bx = bc}
end

------------------------------------------------------------------------
-- create an instruction from a number (for OP_SETLIST)
------------------------------------------------------------------------
function luaP:CREATE_Inst(c)
  local o = c % 64
  c = (c - o) / 64
  local a = c % 256
  c = (c - a) / 256
  return self:CREATE_ABx(o, a, c)
end

------------------------------------------------------------------------
-- returns a 4-char string little-endian encoded form of an instruction
------------------------------------------------------------------------
function luaP:Instruction(i)
  if i.Bx then
    -- change to OP/A/B/C format
    i.C = i.Bx % 512
    i.B = (i.Bx - i.C) / 512
  end
  local I = i.A * 64 + i.OP
  local c0 = I % 256
  I = i.C * 64 + (I - c0) / 256  -- 6 bits of A left
  local c1 = I % 256
  I = i.B * 128 + (I - c1) / 256  -- 7 bits of C left
  local c2 = I % 256
  local c3 = (I - c2) / 256
  return string.char(c0, c1, c2, c3)
end

------------------------------------------------------------------------
-- decodes a 4-char little-endian string into an instruction struct
------------------------------------------------------------------------
function luaP:DecodeInst(x)
  local byte = string.byte
  local i = {}
  local I = byte(x, 1)
  local op = I % 64
  i.OP = op
  I = byte(x, 2) * 4 + (I - op) / 64  -- 2 bits of c0 left
  local a = I % 256
  i.A = a
  I = byte(x, 3) * 4 + (I - a) / 256  -- 2 bits of c1 left
  local c = I % 512
  i.C = c
  i.B = byte(x, 4) * 2 + (I - c) / 512 -- 1 bits of c2 left
  local opmode = self.OpMode[tonumber(string.sub(self.opmodes[op + 1], 7, 7))]
  if opmode ~= "iABC" then
    i.Bx = i.B * 512 + i.C
  end
  return i
end

------------------------------------------------------------------------
-- Macros to operate RK indices
-- * these use arithmetic instead of bit ops
------------------------------------------------------------------------

-- this bit 1 means constant (0 means register)
luaP.BITRK = math.ldexp(1, luaP.SIZE_B - 1)

-- test whether value is a constant
function luaP:ISK(x) return x >= self.BITRK end

-- gets the index of the constant
function luaP:INDEXK(x) return x - self.BITRK end

luaP.MAXINDEXRK = luaP.BITRK - 1

-- code a constant index as a RK value
function luaP:RKASK(x) return x + self.BITRK end

------------------------------------------------------------------------
-- invalid register that fits in 8 bits
------------------------------------------------------------------------
luaP.NO_REG = luaP.MAXARG_A

------------------------------------------------------------------------
-- R(x) - register
-- Kst(x) - constant (in constant table)
-- RK(x) == if ISK(x) then Kst(INDEXK(x)) else R(x)
------------------------------------------------------------------------

------------------------------------------------------------------------
-- grep "ORDER OP" if you change these enums
------------------------------------------------------------------------

--[[--------------------------------------------------------------------
Lua virtual machine opcodes (enum OpCode):
------------------------------------------------------------------------
name          args    description
------------------------------------------------------------------------
OP_MOVE       A B     R(A) := R(B)
OP_LOADK      A Bx    R(A) := Kst(Bx)
OP_LOADBOOL   A B C   R(A) := (Bool)B; if (C) pc++
OP_LOADNIL    A B     R(A) := ... := R(B) := nil
OP_GETUPVAL   A B     R(A) := UpValue[B]
OP_GETGLOBAL  A Bx    R(A) := Gbl[Kst(Bx)]
OP_GETTABLE   A B C   R(A) := R(B)[RK(C)]
OP_SETGLOBAL  A Bx    Gbl[Kst(Bx)] := R(A)
OP_SETUPVAL   A B     UpValue[B] := R(A)
OP_SETTABLE   A B C   R(A)[RK(B)] := RK(C)
OP_NEWTABLE   A B C   R(A) := {} (size = B,C)
OP_SELF       A B C   R(A+1) := R(B); R(A) := R(B)[RK(C)]
OP_ADD        A B C   R(A) := RK(B) + RK(C)
OP_SUB        A B C   R(A) := RK(B) - RK(C)
OP_MUL        A B C   R(A) := RK(B) * RK(C)
OP_DIV        A B C   R(A) := RK(B) / RK(C)
OP_MOD        A B C   R(A) := RK(B) % RK(C)
OP_POW        A B C   R(A) := RK(B) ^ RK(C)
OP_UNM        A B     R(A) := -R(B)
OP_NOT        A B     R(A) := not R(B)
OP_LEN        A B     R(A) := length of R(B)
OP_CONCAT     A B C   R(A) := R(B).. ... ..R(C)
OP_JMP        sBx     pc+=sBx
OP_EQ         A B C   if ((RK(B) == RK(C)) ~= A) then pc++
OP_LT         A B C   if ((RK(B) <  RK(C)) ~= A) then pc++
OP_LE         A B C   if ((RK(B) <= RK(C)) ~= A) then pc++
OP_TEST       A C     if not (R(A) <=> C) then pc++
OP_TESTSET    A B C   if (R(B) <=> C) then R(A) := R(B) else pc++
OP_CALL       A B C   R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1))
OP_TAILCALL   A B C   return R(A)(R(A+1), ... ,R(A+B-1))
OP_RETURN     A B     return R(A), ... ,R(A+B-2)  (see note)
OP_FORLOOP    A sBx   R(A)+=R(A+2);
                      if R(A) <?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }
OP_FORPREP    A sBx   R(A)-=R(A+2); pc+=sBx
OP_TFORLOOP   A C     R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2));
                      if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++
OP_SETLIST    A B C   R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B
OP_CLOSE      A       close all variables in the stack up to (>=) R(A)
OP_CLOSURE    A Bx    R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))
OP_VARARG     A B     R(A), R(A+1), ..., R(A+B-1) = vararg
----------------------------------------------------------------------]]

luaP.opnames = {}  -- opcode names
luaP.OpCode = {}   -- lookup name -> number
luaP.ROpCode = {}  -- lookup number -> name

------------------------------------------------------------------------
-- ORDER OP
------------------------------------------------------------------------
local i = 0
for v in string.gmatch([[
MOVE LOADK LOADBOOL LOADNIL GETUPVAL
GETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE
NEWTABLE SELF ADD SUB MUL
DIV MOD POW UNM NOT
LEN CONCAT JMP EQ LT
LE TEST TESTSET CALL TAILCALL
RETURN FORLOOP FORPREP TFORLOOP SETLIST
CLOSE CLOSURE VARARG
]], "%S+") do
  local n = "OP_"..v
  luaP.opnames[i] = v
  luaP.OpCode[n] = i
  luaP.ROpCode[i] = n
  i = i + 1
end
luaP.NUM_OPCODES = i

--[[
===========================================================================
  Notes:
  (*) In OP_CALL, if (B == 0) then B = top. C is the number of returns - 1,
      and can be 0: OP_CALL then sets 'top' to last_result+1, so
      next open instruction (OP_CALL, OP_RETURN, OP_SETLIST) may use 'top'.
  (*) In OP_VARARG, if (B == 0) then use actual number of varargs and
      set top (like in OP_CALL with C == 0).
  (*) In OP_RETURN, if (B == 0) then return up to 'top'
  (*) In OP_SETLIST, if (B == 0) then B = 'top';
      if (C == 0) then next 'instruction' is real C
  (*) For comparisons, A specifies what condition the test should accept
      (true or false).
  (*) All 'skips' (pc++) assume that next instruction is a jump
===========================================================================
--]]

--[[--------------------------------------------------------------------
  masks for instruction properties. The format is:
  bits 0-1: op mode
  bits 2-3: C arg mode
  bits 4-5: B arg mode
  bit 6: instruction set register A
  bit 7: operator is a test

  for OpArgMask:
  OpArgN - argument is not used
  OpArgU - argument is used
  OpArgR - argument is a register or a jump offset
  OpArgK - argument is a constant or register/constant
----------------------------------------------------------------------]]

-- was enum OpArgMask
luaP.OpArgMask = { OpArgN = 0, OpArgU = 1, OpArgR = 2, OpArgK = 3 }

------------------------------------------------------------------------
-- e.g. to compare with symbols, luaP:getOpMode(...) == luaP.OpCode.iABC
-- * accepts opcode parameter as strings, e.g. "OP_MOVE"
------------------------------------------------------------------------

function luaP:getOpMode(m)
  return self.opmodes[self.OpCode[m]] % 4
end

function luaP:getBMode(m)
  return math.floor(self.opmodes[self.OpCode[m]] / 16) % 4
end

function luaP:getCMode(m)
  return math.floor(self.opmodes[self.OpCode[m]] / 4) % 4
end

function luaP:testAMode(m)
  return math.floor(self.opmodes[self.OpCode[m]] / 64) % 2
end

function luaP:testTMode(m)
  return math.floor(self.opmodes[self.OpCode[m]] / 128)
end

-- luaP_opnames[] is set above, as the luaP.opnames table

-- number of list items to accumulate before a SETLIST instruction
luaP.LFIELDS_PER_FLUSH = 50

------------------------------------------------------------------------
-- build instruction properties array
-- * deliberately coded to look like the C equivalent
------------------------------------------------------------------------
local function opmode(t, a, b, c, m)
  local luaP = luaP
  return t * 128 + a * 64 +
         luaP.OpArgMask[b] * 16 + luaP.OpArgMask[c] * 4 + luaP.OpMode[m]
end

-- ORDER OP
luaP.opmodes = {
-- T A B C mode opcode
  opmode(0, 1, "OpArgK", "OpArgN", "iABx"),     -- OP_LOADK
  opmode(0, 1, "OpArgU", "OpArgU", "iABC"),     -- OP_LOADBOOL
  opmode(0, 1, "OpArgR", "OpArgN", "iABC"),     -- OP_LOADNIL
  opmode(0, 1, "OpArgU", "OpArgN", "iABC"),     -- OP_GETUPVAL
  opmode(0, 1, "OpArgK", "OpArgN", "iABx"),     -- OP_GETGLOBAL
  opmode(0, 1, "OpArgR", "OpArgK", "iABC"),     -- OP_GETTABLE
  opmode(0, 0, "OpArgK", "OpArgN", "iABx"),     -- OP_SETGLOBAL
  opmode(0, 0, "OpArgU", "OpArgN", "iABC"),     -- OP_SETUPVAL
  opmode(0, 0, "OpArgK", "OpArgK", "iABC"),     -- OP_SETTABLE
  opmode(0, 1, "OpArgU", "OpArgU", "iABC"),     -- OP_NEWTABLE
  opmode(0, 1, "OpArgR", "OpArgK", "iABC"),     -- OP_SELF
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_ADD
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_SUB
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_MUL
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_DIV
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_MOD
  opmode(0, 1, "OpArgK", "OpArgK", "iABC"),     -- OP_POW
  opmode(0, 1, "OpArgR", "OpArgN", "iABC"),     -- OP_UNM
  opmode(0, 1, "OpArgR", "OpArgN", "iABC"),     -- OP_NOT
  opmode(0, 1, "OpArgR", "OpArgN", "iABC"),     -- OP_LEN
  opmode(0, 1, "OpArgR", "OpArgR", "iABC"),     -- OP_CONCAT
  opmode(0, 0, "OpArgR", "OpArgN", "iAsBx"),    -- OP_JMP
  opmode(1, 0, "OpArgK", "OpArgK", "iABC"),     -- OP_EQ
  opmode(1, 0, "OpArgK", "OpArgK", "iABC"),     -- OP_LT
  opmode(1, 0, "OpArgK", "OpArgK", "iABC"),     -- OP_LE
  opmode(1, 1, "OpArgR", "OpArgU", "iABC"),     -- OP_TEST
  opmode(1, 1, "OpArgR", "OpArgU", "iABC"),     -- OP_TESTSET
  opmode(0, 1, "OpArgU", "OpArgU", "iABC"),     -- OP_CALL
  opmode(0, 1, "OpArgU", "OpArgU", "iABC"),     -- OP_TAILCALL
  opmode(0, 0, "OpArgU", "OpArgN", "iABC"),     -- OP_RETURN
  opmode(0, 1, "OpArgR", "OpArgN", "iAsBx"),    -- OP_FORLOOP
  opmode(0, 1, "OpArgR", "OpArgN", "iAsBx"),    -- OP_FORPREP
  opmode(1, 0, "OpArgN", "OpArgU", "iABC"),     -- OP_TFORLOOP
  opmode(0, 0, "OpArgU", "OpArgU", "iABC"),     -- OP_SETLIST
  opmode(0, 0, "OpArgN", "OpArgN", "iABC"),     -- OP_CLOSE
  opmode(0, 1, "OpArgU", "OpArgN", "iABx"),     -- OP_CLOSURE
  opmode(0, 1, "OpArgU", "OpArgN", "iABC"),     -- OP_VARARG
}
-- an awkward way to set a zero-indexed table...
luaP.opmodes[0] =
  opmode(0, 1, "OpArgR", "OpArgN", "iABC")      -- OP_MOVE

return luaP]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3FE892565D384F3AB7B4135332690F8F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">LuaU</string>
						<string name="ScriptGuid">{0FC81BC2-AC94-4710-9C35-33820CD15F50}</string>
						<ProtectedString name="Source"><![CDATA[--# selene: allow(incorrect_standard_library_use, multiple_statements, shadowing, unused_variable, empty_if, divide_by_zero, unbalanced_assignments)
--[[--------------------------------------------------------------------

  ldump.lua
  Save precompiled Lua chunks
  This file is part of Yueliang.

  Copyright (c) 2006 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * WARNING! byte order (little endian) and data type sizes for header
--   signature values hard-coded; see luaU:header
-- * chunk writer generators are included, see below
-- * one significant difference is that instructions are still in table
--   form (with OP/A/B/C/Bx fields) and luaP:Instruction() is needed to
--   convert them into 4-char strings
--
-- Not implemented:
-- * DumpVar, DumpMem has been removed
-- * DumpVector folded into folded into DumpDebug, DumpCode
--
-- Added:
-- * for convenience, the following two functions have been added:
--   luaU:make_setS: create a chunk writer that writes to a string
--   luaU:make_setF: create a chunk writer that writes to a file
--   (lua.h contains a typedef for lua_Writer/lua_Chunkwriter, and
--    a Lua-based implementation exists, writer() in lstrlib.c)
-- * luaU:ttype(o) (from lobject.h)
-- * for converting number types to its binary equivalent:
--   luaU:from_double(x): encode double value for writing
--   luaU:from_int(x): encode integer value for writing
--     (error checking is limited for these conversion functions)
--     (double conversion does not support denormals or NaNs)
--
-- Changed in 5.1.x:
-- * the dumper was mostly rewritten in Lua 5.1.x, so notes on the
--   differences between 5.0.x and 5.1.x is limited
-- * LUAC_VERSION bumped to 0x51, LUAC_FORMAT added
-- * developer is expected to adjust LUAC_FORMAT in order to identify
--   non-standard binary chunk formats
-- * header signature code is smaller, has been simplified, and is
--   tested as a single unit; its logic is shared with the undumper
-- * no more endian conversion, invalid endianness mean rejection
-- * opcode field sizes are no longer exposed in the header
-- * code moved to front of a prototype, followed by constants
-- * debug information moved to the end of the binary chunk, and the
--   relevant functions folded into a single function
-- * luaU:dump returns a writer status code
-- * chunk writer now implements status code because dumper uses it
-- * luaU:endianness removed
----------------------------------------------------------------------]]

--requires luaP
local luaU = {}
local luaP = require(script.Parent.LuaP)

-- mark for precompiled code ('<esc>Lua') (from lua.h)
luaU.LUA_SIGNATURE = "\27Lua"

-- constants used by dumper (from lua.h)
luaU.LUA_TNUMBER  = 3
luaU.LUA_TSTRING  = 4
luaU.LUA_TNIL     = 0
luaU.LUA_TBOOLEAN = 1
luaU.LUA_TNONE    = -1

-- constants for header of binary files (from lundump.h)
luaU.LUAC_VERSION    = 0x51     -- this is Lua 5.1
luaU.LUAC_FORMAT     = 0        -- this is the official format
luaU.LUAC_HEADERSIZE = 12       -- size of header of binary files

--[[--------------------------------------------------------------------
-- Additional functions to handle chunk writing
-- * to use make_setS and make_setF, see test_ldump.lua elsewhere
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- create a chunk writer that writes to a string
-- * returns the writer function and a table containing the string
-- * to get the final result, look in buff.data
------------------------------------------------------------------------
function luaU:make_setS()
  local buff = {}
        buff.data = ""
  local writer =
    function(s, buff)  -- chunk writer
      if not s then return 0 end
      buff.data = buff.data..s
      return 0
    end
  return writer, buff
end

------------------------------------------------------------------------
-- create a chunk writer that writes to a file
-- * returns the writer function and a table containing the file handle
-- * if a nil is passed, then writer should close the open file
------------------------------------------------------------------------

--[[
function luaU:make_setF(filename)
  local buff = {}
        buff.h = io.open(filename, "wb")
  if not buff.h then return nil end
  local writer =
    function(s, buff)  -- chunk writer
      if not buff.h then return 0 end
      if not s then
        if buff.h:close() then return 0 end
      else
        if buff.h:write(s) then return 0 end
      end
      return 1
    end
  return writer, buff
end--]]

------------------------------------------------------------------------
-- works like the lobject.h version except that TObject used in these
-- scripts only has a 'value' field, no 'tt' field (native types used)
------------------------------------------------------------------------
function luaU:ttype(o)
  local tt = type(o.value)
  if tt == "number" then return self.LUA_TNUMBER
  elseif tt == "string" then return self.LUA_TSTRING
  elseif tt == "nil" then return self.LUA_TNIL
  elseif tt == "boolean" then return self.LUA_TBOOLEAN
  else
    return self.LUA_TNONE  -- the rest should not appear
  end
end

-----------------------------------------------------------------------
-- converts a IEEE754 double number to an 8-byte little-endian string
-- * luaU:from_double() and luaU:from_int() are adapted from ChunkBake
-- * supports +/- Infinity, but not denormals or NaNs
-----------------------------------------------------------------------
function luaU:from_double(x)
  local function grab_byte(v)
    local c = v % 256
    return (v - c) / 256, string.char(c)
  end
  local sign = 0
  if x < 0 then sign = 1; x = -x end
  local mantissa, exponent = math.frexp(x)
  if x == 0 then -- zero
    mantissa, exponent = 0, 0
  elseif x == 1/0 then
    mantissa, exponent = 0, 2047
  else
    mantissa = (mantissa * 2 - 1) * math.ldexp(0.5, 53)
    exponent = exponent + 1022
  end
  local v, byte = "", nil -- convert to bytes
  x = math.floor(mantissa)
  for i = 1,6 do
    x, byte = grab_byte(x); v = v..byte -- 47:0
  end
  x, byte = grab_byte(exponent * 16 + x); v = v..byte -- 55:48
  x, byte = grab_byte(sign * 128 + x); v = v..byte -- 63:56
  return v
end

-----------------------------------------------------------------------
-- converts a number to a little-endian 32-bit integer string
-- * input value assumed to not overflow, can be signed/unsigned
-----------------------------------------------------------------------
function luaU:from_int(x)
  local v = ""
  x = math.floor(x)
  if x < 0 then x = 4294967296 + x end  -- ULONG_MAX+1
  for i = 1, 4 do
    local c = x % 256
    v = v..string.char(c); x = math.floor(x / 256)
  end
  return v
end

--[[--------------------------------------------------------------------
-- Functions to make a binary chunk
-- * many functions have the size parameter removed, since output is
--   in the form of a string and some sizes are implicit or hard-coded
----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- struct DumpState:
--   L  -- lua_State (not used in this script)
--   writer  -- lua_Writer (chunk writer function)
--   data  -- void* (chunk writer context or data already written)
--   strip  -- if true, don't write any debug information
--   status  -- if non-zero, an error has occured
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- dumps a block of bytes
-- * lua_unlock(D.L), lua_lock(D.L) unused
------------------------------------------------------------------------
function luaU:DumpBlock(b, D)
  if D.status == 0 then
    -- lua_unlock(D->L);
    D.status = D.write(b, D.data)
    -- lua_lock(D->L);
  end
end

------------------------------------------------------------------------
-- dumps a char
------------------------------------------------------------------------
function luaU:DumpChar(y, D)
  self:DumpBlock(string.char(y), D)
end

------------------------------------------------------------------------
-- dumps a 32-bit signed or unsigned integer (for int) (hard-coded)
------------------------------------------------------------------------
function luaU:DumpInt(x, D)
  self:DumpBlock(self:from_int(x), D)
end

------------------------------------------------------------------------
-- dumps a lua_Number (hard-coded as a double)
------------------------------------------------------------------------
function luaU:DumpNumber(x, D)
  self:DumpBlock(self:from_double(x), D)
end

------------------------------------------------------------------------
-- dumps a Lua string (size type is hard-coded)
------------------------------------------------------------------------
function luaU:DumpString(s, D)
  if s == nil then
    self:DumpInt(0, D)
  else
    s = s.."\0"  -- include trailing '\0'
    self:DumpInt(#s, D)
    self:DumpBlock(s, D)
  end
end

------------------------------------------------------------------------
-- dumps instruction block from function prototype
------------------------------------------------------------------------
function luaU:DumpCode(f, D)
  local n = f.sizecode
  --was DumpVector
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    self:DumpBlock(luaP:Instruction(f.code[i]), D)
  end
end

------------------------------------------------------------------------
-- dump constant pool from function prototype
-- * bvalue(o), nvalue(o) and rawtsvalue(o) macros removed
------------------------------------------------------------------------
function luaU:DumpConstants(f, D)
  local n = f.sizek
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    local o = f.k[i]  -- TValue
    local tt = self:ttype(o)
    self:DumpChar(tt, D)
    if tt == self.LUA_TNIL then
    elseif tt == self.LUA_TBOOLEAN then
      self:DumpChar(o.value and 1 or 0, D)
    elseif tt == self.LUA_TNUMBER then
      self:DumpNumber(o.value, D)
    elseif tt == self.LUA_TSTRING then
      self:DumpString(o.value, D)
    else
      --lua_assert(0)  -- cannot happen
    end
  end
  n = f.sizep
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    self:DumpFunction(f.p[i], f.source, D)
  end
end

------------------------------------------------------------------------
-- dump debug information
------------------------------------------------------------------------
function luaU:DumpDebug(f, D)
  local n
  n = D.strip and 0 or f.sizelineinfo           -- dump line information
  --was DumpVector
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    self:DumpInt(f.lineinfo[i], D)
  end
  n = D.strip and 0 or f.sizelocvars            -- dump local information
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    self:DumpString(f.locvars[i].varname, D)
    self:DumpInt(f.locvars[i].startpc, D)
    self:DumpInt(f.locvars[i].endpc, D)
  end
  n = D.strip and 0 or f.sizeupvalues           -- dump upvalue information
  self:DumpInt(n, D)
  for i = 0, n - 1 do
    self:DumpString(f.upvalues[i], D)
  end
end

------------------------------------------------------------------------
-- dump child function prototypes from function prototype
------------------------------------------------------------------------
function luaU:DumpFunction(f, p, D)
  local source = f.source
  if source == p or D.strip then source = nil end
  self:DumpString(source, D)
  self:DumpInt(f.lineDefined, D)
  self:DumpInt(f.lastlinedefined, D)
  self:DumpChar(f.nups, D)
  self:DumpChar(f.numparams, D)
  self:DumpChar(f.is_vararg, D)
  self:DumpChar(f.maxstacksize, D)
  self:DumpCode(f, D)
  self:DumpConstants(f, D)
  self:DumpDebug(f, D)
end

------------------------------------------------------------------------
-- dump Lua header section (some sizes hard-coded)
------------------------------------------------------------------------
function luaU:DumpHeader(D)
  local h = self:header()
  assert(#h == self.LUAC_HEADERSIZE) -- fixed buffer now an assert
  self:DumpBlock(h, D)
end

------------------------------------------------------------------------
-- make header (from lundump.c)
-- returns the header string
------------------------------------------------------------------------
function luaU:header()
 local x = 1
 return self.LUA_SIGNATURE..
        string.char(
          self.LUAC_VERSION,
          self.LUAC_FORMAT,
          x,                    -- endianness (1=little)
          4,                    -- sizeof(int)
          4,                    -- sizeof(size_t)
          4,                    -- sizeof(Instruction)
          8,                    -- sizeof(lua_Number)
          0)                    -- is lua_Number integral?
end

------------------------------------------------------------------------
-- dump Lua function as precompiled chunk
-- (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip)
-- * w, data are created from make_setS, make_setF
------------------------------------------------------------------------
function luaU:dump(L, f, w, data, strip)
  local D = {}  -- DumpState
  D.L = L
  D.write = w
  D.data = data
  D.strip = strip
  D.status = 0
  self:DumpHeader(D)
  self:DumpFunction(f, nil, D)
  -- added: for a chunk writer writing to a file, this final call with
  -- nil data is to indicate to the writer to close the file
  D.write(nil, D.data)
  return D.status
end

return luaU]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD5A1353D3F76474883C551E25727CC1E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">LuaX</string>
						<string name="ScriptGuid">{54C36675-F404-41EB-AA9C-9DEC28B9134F}</string>
						<ProtectedString name="Source"><![CDATA[--# selene: allow(incorrect_standard_library_use, multiple_statements, shadowing, unused_variable, empty_if, divide_by_zero, unbalanced_assignments)
--[[--------------------------------------------------------------------

  llex.lua
  Lua lexical analyzer in Lua
  This file is part of Yueliang.

  Copyright (c) 2005-2006 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * intended to 'imitate' llex.c code; performance is not a concern
-- * tokens are strings; code structure largely retained
-- * deleted stuff (compared to llex.c) are noted, comments retained
-- * nextc() returns the currently read character to simplify coding
--   here; next() in llex.c does not return anything
-- * compatibility code is marked with "--#" comments
--
-- Added:
-- * luaX:chunkid (function luaO_chunkid from lobject.c)
-- * luaX:str2d (function luaO_str2d from lobject.c)
-- * luaX.LUA_QS used in luaX:lexerror (from luaconf.h)
-- * luaX.LUA_COMPAT_LSTR in luaX:read_long_string (from luaconf.h)
-- * luaX.MAX_INT used in luaX:inclinenumber (from llimits.h)
--
-- To use the lexer:
-- (1) luaX:init() to initialize the lexer
-- (2) luaX:setinput() to set the input stream to lex
-- (3) call luaX:next() or luaX:luaX:lookahead() to get tokens,
--     until "TK_EOS": luaX:next()
-- * since EOZ is returned as a string, be careful when regexp testing
--
-- Not implemented:
-- * luaX_newstring: not required by this Lua implementation
-- * buffer MAX_SIZET size limit (from llimits.h) test not implemented
--   in the interest of performance
-- * locale-aware number handling is largely redundant as Lua's
--   tonumber() function is already capable of this
--
-- Changed in 5.1.x:
-- * TK_NAME token order moved down
-- * string representation for TK_NAME, TK_NUMBER, TK_STRING changed
-- * token struct renamed to lower case (LS -> ls)
-- * LexState struct: removed nestlevel, added decpoint
-- * error message functions have been greatly simplified
-- * token2string renamed to luaX_tokens, exposed in llex.h
-- * lexer now handles all kinds of newlines, including CRLF
-- * shbang first line handling removed from luaX:setinput;
--   it is now done in lauxlib.c (luaL_loadfile)
-- * next(ls) macro renamed to nextc(ls) due to new luaX_next function
-- * EXTRABUFF and MAXNOCHECK removed due to lexer changes
-- * checkbuffer(ls, len) macro deleted
-- * luaX:read_numeral now has 3 support functions: luaX:trydecpoint,
--   luaX:buffreplace and (luaO_str2d from lobject.c) luaX:str2d
-- * luaX:read_numeral is now more promiscuous in slurping characters;
--   hexadecimal numbers was added, locale-aware decimal points too
-- * luaX:skip_sep is new; used by luaX:read_long_string
-- * luaX:read_long_string handles new-style long blocks, with some
--   optional compatibility code
-- * luaX:llex: parts changed to support new-style long blocks
-- * luaX:llex: readname functionality has been folded in
-- * luaX:llex: removed test for control characters
--
--------------------------------------------------------------------]]

local luaZ = require(script.Parent.LuaZ)

local luaX = {}

-- FIRST_RESERVED is not required as tokens are manipulated as strings
-- TOKEN_LEN deleted; maximum length of a reserved word not needed

------------------------------------------------------------------------
-- "ORDER RESERVED" deleted; enumeration in one place: luaX.RESERVED
------------------------------------------------------------------------

-- terminal symbols denoted by reserved words: TK_AND to TK_WHILE
-- other terminal symbols: TK_NAME to TK_EOS
luaX.RESERVED = [[
TK_AND and
TK_BREAK break
TK_DO do
TK_ELSE else
TK_ELSEIF elseif
TK_END end
TK_FALSE false
TK_FOR for
TK_FUNCTION function
TK_IF if
TK_IN in
TK_LOCAL local
TK_NIL nil
TK_NOT not
TK_OR or
TK_REPEAT repeat
TK_RETURN return
TK_THEN then
TK_TRUE true
TK_UNTIL until
TK_WHILE while
TK_CONCAT ..
TK_DOTS ...
TK_EQ ==
TK_GE >=
TK_LE <=
TK_NE ~=
TK_NAME <name>
TK_NUMBER <number>
TK_STRING <string>
TK_EOS <eof>]]

-- NUM_RESERVED is not required; number of reserved words

--[[--------------------------------------------------------------------
-- Instead of passing seminfo, the Token struct (e.g. ls.t) is passed
-- so that lexer functions can use its table element, ls.t.seminfo
--
-- SemInfo (struct no longer needed, a mixed-type value is used)
--
-- Token (struct of ls.t and ls.lookahead):
--   token  -- token symbol
--   seminfo  -- semantics information
--
-- LexState (struct of ls; ls is initialized by luaX:setinput):
--   current  -- current character (charint)
--   linenumber  -- input line counter
--   lastline  -- line of last token 'consumed'
--   t  -- current token (table: struct Token)
--   lookahead  -- look ahead token (table: struct Token)
--   fs  -- 'FuncState' is private to the parser
--   L -- LuaState
--   z  -- input stream
--   buff  -- buffer for tokens
--   source  -- current source name
--   decpoint -- locale decimal point
--   nestlevel  -- level of nested non-terminals
----------------------------------------------------------------------]]

-- luaX.tokens (was luaX_tokens) is now a hash; see luaX:init

luaX.MAXSRC = 80
luaX.MAX_INT = 2147483645       -- constants from elsewhere (see above)
luaX.LUA_QS = "'%s'"
luaX.LUA_COMPAT_LSTR = 1
--luaX.MAX_SIZET = 4294967293

--[[
##############################################################################################
##############################################################################################
##############################################################################################
--]]
function same(...)return...end
function disguise<A...>(...):A...return same(...)end

------------------------------------------------------------------------
-- initialize lexer
-- * original luaX_init has code to create and register token strings
-- * luaX.tokens: TK_* -> token
-- * luaX.enums:  token -> TK_* (used in luaX:llex)
------------------------------------------------------------------------
function luaX:init()
  local tokens, enums = {}, {}
  for v in string.gmatch(self.RESERVED, "[^\n]+") do
    local _, _, tok, str = string.find(v, "(%S+)%s+(%S+)")
    tokens[tok] = str
    enums[str] = tok
  end
  self.tokens = tokens
  self.enums = enums
end

------------------------------------------------------------------------
-- returns a suitably-formatted chunk name or id
-- * from lobject.c, used in llex.c and ldebug.c
-- * the result, out, is returned (was first argument)
------------------------------------------------------------------------
function luaX:chunkid(source, bufflen)
  local out
  local first = string.sub(source, 1, 1)
  if first == "=" then
    out = string.sub(source, 2, bufflen)  -- remove first char
  else  -- out = "source", or "...source"
    if first == "@" then
      source = string.sub(source, 2)  -- skip the '@'
      bufflen = bufflen - #" '...' "
      local l = #source
      out = ""
      if l > bufflen then
        source = string.sub(source, 1 + l - bufflen)  -- get last part of file name
        out = out.."..."
      end
      out = out..source
    else  -- out = [string "string"]
      local len = string.find(source, "[\n\r]")  -- stop at first newline
      len = len and (len - 1) or #source
      bufflen = bufflen - #(" [string \"...\"] ")
      if len > bufflen then len = bufflen end
      out = "[string \""
      if len < #source then  -- must truncate?
        out = out..string.sub(source, 1, len).."..."
      else
        out = out..source
      end
      out = out.."\"]"
    end
  end
  return out
end

--[[--------------------------------------------------------------------
-- Support functions for lexer
-- * all lexer errors eventually reaches lexerror:
     syntaxerror -> lexerror
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- look up token and return keyword if found (also called by parser)
------------------------------------------------------------------------
function luaX:token2str(ls, token)
  if string.sub(token, 1, 3) ~= "TK_" then
    if string.find(token, "%c") then
      return string.format("char(%d)", string.byte(token))
    end
    return token
  else
  end
    return self.tokens[token]
end

------------------------------------------------------------------------
-- throws a lexer error
-- * txtToken has been made local to luaX:lexerror
-- * can't communicate LUA_ERRSYNTAX, so it is unimplemented
------------------------------------------------------------------------
function luaX:lexerror(ls, msg, token)
  local function txtToken(ls, token)
    if token == "TK_NAME" or
       token == "TK_STRING" or
       token == "TK_NUMBER" then
      return ls.buff
    else
      return self:token2str(ls, token)
    end
  end
  local buff = self:chunkid(ls.source, self.MAXSRC)
  local msg = string.format("%s:%d: %s", buff, ls.linenumber, msg)
  if token then
    msg = string.format("%s near "..self.LUA_QS, msg, txtToken(ls, token))
  end
  -- luaD_throw(ls->L, LUA_ERRSYNTAX)
  error(msg)
end

------------------------------------------------------------------------
-- throws a syntax error (mainly called by parser)
-- * ls.t.token has to be set by the function calling luaX:llex
--   (see luaX:next and luaX:lookahead elsewhere in this file)
------------------------------------------------------------------------
function luaX:syntaxerror(ls, msg)
  self:lexerror(ls, msg, ls.t.token)
end

------------------------------------------------------------------------
-- move on to next line
------------------------------------------------------------------------
function luaX:currIsNewline(ls)
  return ls.current == "\n" or ls.current == "\r"
end

function luaX:inclinenumber(ls)
  local old = ls.current
  -- lua_assert(currIsNewline(ls))
  self:nextc(ls)  -- skip '\n' or '\r'
  if self:currIsNewline(ls) and ls.current ~= old then
    self:nextc(ls)  -- skip '\n\r' or '\r\n'
  end
  ls.linenumber = ls.linenumber + 1
  if ls.linenumber >= self.MAX_INT then
    self:syntaxerror(ls, "chunk has too many lines")
  end
end

------------------------------------------------------------------------
-- initializes an input stream for lexing
-- * if ls (the lexer state) is passed as a table, then it is filled in,
--   otherwise it has to be retrieved as a return value
-- * LUA_MINBUFFER not used; buffer handling not required any more
------------------------------------------------------------------------
function luaX:setinput(L, ls, z, source)
  if not ls then ls = {} end  -- create struct
  if not ls.lookahead then ls.lookahead = {} end
  if not ls.t then ls.t = {} end
  ls.decpoint = "."
  ls.L = L
  ls.lookahead.token = "TK_EOS"  -- no look-ahead token
  ls.z = z
  ls.fs = nil
  ls.linenumber = 1
  ls.lastline = 1
  ls.source = source
  self:nextc(ls)  -- read first char
end

--[[--------------------------------------------------------------------
-- LEXICAL ANALYZER
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- checks if current character read is found in the set 'set'
------------------------------------------------------------------------
function luaX:check_next(ls, set)
  if not string.find(set, ls.current, 1, true) then
    return false
  end
  self:save_and_next(ls)
  return true
end

------------------------------------------------------------------------
-- retrieve next token, checking the lookahead buffer if necessary
-- * note that the macro next(ls) in llex.c is now luaX:nextc
-- * utilized used in lparser.c (various places)
------------------------------------------------------------------------
function luaX:next(ls)
  ls.lastline = ls.linenumber
  if ls.lookahead.token ~= "TK_EOS" then  -- is there a look-ahead token?
    -- this must be copy-by-value
    ls.t.seminfo = ls.lookahead.seminfo  -- use this one
    ls.t.token = ls.lookahead.token
    ls.lookahead.token = "TK_EOS"  -- and discharge it
  else
    ls.t.token = self:llex(ls, ls.t)  -- read next token
  end
end

------------------------------------------------------------------------
-- fill in the lookahead buffer
-- * utilized used in lparser.c:constructor
------------------------------------------------------------------------
function luaX:lookahead(ls)
  -- lua_assert(ls.lookahead.token == "TK_EOS")
  ls.lookahead.token = self:llex(ls, ls.lookahead)
end

------------------------------------------------------------------------
-- gets the next character and returns it
-- * this is the next() macro in llex.c; see notes at the beginning
------------------------------------------------------------------------
function luaX:nextc(ls)
  local c = luaZ:zgetc(ls.z)
  ls.current = c
  return c
end

------------------------------------------------------------------------
-- saves the given character into the token buffer
-- * buffer handling code removed, not used in this implementation
-- * test for maximum token buffer length not used, makes things faster
------------------------------------------------------------------------

function luaX:save(ls, c)
  local buff = ls.buff
  -- if you want to use this, please uncomment luaX.MAX_SIZET further up
  --if #buff > self.MAX_SIZET then
  --  self:lexerror(ls, "lexical element too long")
  --end
  ls.buff = buff..c
end

------------------------------------------------------------------------
-- save current character into token buffer, grabs next character
-- * like luaX:nextc, returns the character read for convenience
------------------------------------------------------------------------
function luaX:save_and_next(ls)
  self:save(ls, ls.current)
  return self:nextc(ls)
end

------------------------------------------------------------------------
-- LUA_NUMBER
-- * luaX:read_numeral is the main lexer function to read a number
-- * luaX:str2d, luaX:buffreplace, luaX:trydecpoint are support functions
------------------------------------------------------------------------

------------------------------------------------------------------------
-- string to number converter (was luaO_str2d from lobject.c)
-- * returns the number, nil if fails (originally returns a boolean)
-- * conversion function originally lua_str2number(s,p), a macro which
--   maps to the strtod() function by default (from luaconf.h)
------------------------------------------------------------------------
function luaX:str2d(s)
  local result = tonumber(s)
  if result then return result end
  -- conversion failed
  if string.lower(string.sub(s, 1, 2)) == "0x" then  -- maybe an hexadecimal constant?
    result = tonumber(s, 16)
    if result then return result end  -- most common case
    -- Was: invalid trailing characters?
    -- In C, this function then skips over trailing spaces.
    -- true is returned if nothing else is found except for spaces.
    -- If there is still something else, then it returns a false.
    -- All this is not necessary using Lua's tonumber.
  end
  return nil
end

------------------------------------------------------------------------
-- single-character replacement, for locale-aware decimal points
------------------------------------------------------------------------
function luaX:buffreplace(ls, from, to)
  local result, buff = "", ls.buff
  for p = 1, #buff do
    local c = string.sub(buff, p, p)
    if c == from then c = to end
    result = result..c
  end
  ls.buff = result
end

------------------------------------------------------------------------
-- Attempt to convert a number by translating '.' decimal points to
-- the decimal point character used by the current locale. This is not
-- needed in Yueliang as Lua's tonumber() is already locale-aware.
-- Instead, the code is here in case the user implements localeconv().
------------------------------------------------------------------------
function luaX:trydecpoint(ls, Token)
  -- format error: try to update decimal point separator
  local old = ls.decpoint
  -- translate the following to Lua if you implement localeconv():
  -- struct lconv *cv = localeconv();
  -- ls->decpoint = (cv ? cv->decimal_point[0] : '.');
  self:buffreplace(ls, old, ls.decpoint)  -- try updated decimal separator
  local seminfo = self:str2d(ls.buff)
  Token.seminfo = seminfo
  if not seminfo then
    -- format error with correct decimal point: no more options
    self:buffreplace(ls, ls.decpoint, ".")  -- undo change (for error message)
    self:lexerror(ls, "malformed number", "TK_NUMBER")
  end
end

------------------------------------------------------------------------
-- main number conversion function
-- * "^%w$" needed in the scan in order to detect "EOZ"
------------------------------------------------------------------------
function luaX:read_numeral(ls, Token)
  -- lua_assert(string.find(ls.current, "%d"))
  repeat
    self:save_and_next(ls)
  until string.find(ls.current, "%D") and ls.current ~= "."
  if self:check_next(ls, "Ee") then  -- 'E'?
    self:check_next(ls, "+-")  -- optional exponent sign
  end
  while string.find(ls.current, "^%w$") or ls.current == "_" do
    self:save_and_next(ls)
  end
  self:buffreplace(ls, ".", ls.decpoint)  -- follow locale for decimal point
  local seminfo = self:str2d(ls.buff)
  Token.seminfo = seminfo
  if not seminfo then  -- format error?
    self:trydecpoint(ls, Token) -- try to update decimal point separator
  end
end

------------------------------------------------------------------------
-- count separators ("=") in a long string delimiter
-- * used by luaX:read_long_string
------------------------------------------------------------------------
function luaX:skip_sep(ls)
  local count = 0
  local s = ls.current
  -- lua_assert(s == "[" or s == "]")
  self:save_and_next(ls)
  while ls.current == "=" do
    self:save_and_next(ls)
    count = count + 1
  end
  return (ls.current == s) and count or (-count) - 1
end

------------------------------------------------------------------------
-- reads a long string or long comment
------------------------------------------------------------------------
function luaX:read_long_string(ls, Token, sep)
  local cont = 0
  self:save_and_next(ls)  -- skip 2nd '['
  if self:currIsNewline(ls) then  -- string starts with a newline?
    self:inclinenumber(ls)  -- skip it
  end
  while true do
    local c = ls.current
    if c == "EOZ" then
      self:lexerror(ls, Token and "unfinished long string" or
                    "unfinished long comment", "TK_EOS")
    elseif c == "[" then
      --# compatibility code start
      if self.LUA_COMPAT_LSTR then
        if self:skip_sep(ls) == sep then
          self:save_and_next(ls)  -- skip 2nd '['
          cont = cont + 1
          --# compatibility code start
          if self.LUA_COMPAT_LSTR == 1 then
            if sep == 0 then
              self:lexerror(ls, "nesting of [[...]] is deprecated", "[")
            end
          end
          --# compatibility code end
        end
      end
      --# compatibility code end
    elseif c == "]" then
      if self:skip_sep(ls) == sep then
        self:save_and_next(ls)  -- skip 2nd ']'
        --# compatibility code start
        if self.LUA_COMPAT_LSTR and self.LUA_COMPAT_LSTR == 2 then
          cont = cont - 1
          if sep == 0 and cont >= 0 then break end
        end
        --# compatibility code end
        break
      end
    elseif self:currIsNewline(ls) then
      self:save(ls, "\n")
      self:inclinenumber(ls)
      if not Token then ls.buff = "" end -- avoid wasting space
    else  -- default
      if Token then
        self:save_and_next(ls)
      else
        self:nextc(ls)
      end
    end--if c
  end--while
  if Token then
    local p = 3 + sep
    Token.seminfo = string.sub(ls.buff, p, -p)
  end
end

------------------------------------------------------------------------
-- reads a string
-- * has been restructured significantly compared to the original C code
------------------------------------------------------------------------

function luaX:read_string(ls, del, Token)
  self:save_and_next(ls)
  while ls.current ~= del do
    local c = ls.current
    if c == "EOZ" then
      self:lexerror(ls, "unfinished string", "TK_EOS")
    elseif self:currIsNewline(ls) then
      self:lexerror(ls, "unfinished string", "TK_STRING")
    elseif c == "\\" then
      c = self:nextc(ls)  -- do not save the '\'
      if self:currIsNewline(ls) then  -- go through
        self:save(ls, "\n")
        self:inclinenumber(ls)
      elseif disguise(c) ~= "EOZ" then -- will raise an error next loop
        -- escapes handling greatly simplified here:
        local i = string.find("abfnrtv", c, 1, true)
        if i then
          self:save(ls, string.sub("\a\b\f\n\r\t\v", i, i))
          self:nextc(ls)
        elseif not string.find(c, "%d") then
          self:save_and_next(ls)  -- handles \\, \", \', and \?
        else  -- \xxx
          c, i = 0, 0
          local __c = disguise(c)
          repeat
            c = 10 * __c + ls.current
            self:nextc(ls)
            i = i + 1
          until i >= 3 or not string.find(ls.current, "%d")
          if __c > 255 then  -- UCHAR_MAX
            self:lexerror(ls, "escape sequence too large", "TK_STRING")
          end
          self:save(ls, string.char(__c))
        end
      end
    else
      self:save_and_next(ls)
    end--if c
  end--while
  self:save_and_next(ls)  -- skip delimiter
  Token.seminfo = string.sub(ls.buff, 2, -2)
end

------------------------------------------------------------------------
-- main lexer function
------------------------------------------------------------------------
function luaX:llex(ls, Token)
  ls.buff = ""
  while true do
    local c = ls.current
    ----------------------------------------------------------------
    if self:currIsNewline(ls) then
      self:inclinenumber(ls)
    ----------------------------------------------------------------
    elseif c == "-" then
      c = self:nextc(ls)
      if c ~= "-" then return "-" end
      -- else is a comment
      local sep = -1
      if self:nextc(ls) == '[' then
        sep = self:skip_sep(ls)
        ls.buff = ""  -- 'skip_sep' may dirty the buffer
      end
      if sep >= 0 then
        self:read_long_string(ls, nil, sep)  -- long comment
        ls.buff = ""
      else  -- else short comment
        while not self:currIsNewline(ls) and ls.current ~= "EOZ" do
          self:nextc(ls)
        end
      end
    ----------------------------------------------------------------
    elseif c == "[" then
      local sep = self:skip_sep(ls)
      if sep >= 0 then
        self:read_long_string(ls, Token, sep)
        return "TK_STRING"
      elseif sep == -1 then
        return "["
      else
        self:lexerror(ls, "invalid long string delimiter", "TK_STRING")
      end
    ----------------------------------------------------------------
    elseif c == "=" then
      c = self:nextc(ls)
      if c ~= "=" then return "="
      else self:nextc(ls); return "TK_EQ" end
    ----------------------------------------------------------------
    elseif c == "<" then
      c = self:nextc(ls)
      if disguise(c) ~= "=" then return "<"
      else self:nextc(ls); return "TK_LE" end
    ----------------------------------------------------------------
    elseif c == ">" then
      c = self:nextc(ls)
      if disguise(c) ~= "=" then return ">"
      else self:nextc(ls); return "TK_GE" end
    ----------------------------------------------------------------
    elseif c == "~" then
      c = self:nextc(ls)
      if disguise(c) ~= "=" then return "~"
      else self:nextc(ls); return "TK_NE" end
    ----------------------------------------------------------------
    elseif c == "\"" or c == "'" then
      self:read_string(ls, c, Token)
      return "TK_STRING"
    ----------------------------------------------------------------
    elseif c == "." then
      c = self:save_and_next(ls)
      if self:check_next(ls, ".") then
        if self:check_next(ls, ".") then
          return "TK_DOTS"   -- ...
        else return "TK_CONCAT"   -- ..
        end
      elseif not string.find(c, "%d") then
        return "."
      else
        self:read_numeral(ls, Token)
        return "TK_NUMBER"
      end
    ----------------------------------------------------------------
    elseif c == "EOZ" then
      return "TK_EOS"
    ----------------------------------------------------------------
    else  -- default
      if string.find(c, "%s") then
        -- lua_assert(self:currIsNewline(ls))
        self:nextc(ls)
      elseif string.find(c, "%d") then
        self:read_numeral(ls, Token)
        return "TK_NUMBER"
      elseif string.find(c, "[_%a]") then
        -- identifier or reserved word
        repeat
          c = self:save_and_next(ls)
        until c == "EOZ" or not string.find(c, "[_%w]")
        local ts = ls.buff
        local tok = self.enums[ts]
        if tok then return tok end  -- reserved word?
        Token.seminfo = ts
        return "TK_NAME"
      else
        self:nextc(ls)
        return c  -- single-char tokens (+ - / ...)
      end
    ----------------------------------------------------------------
    end--if c
  end--while
end

return luaX]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8B9970498352464397E68D8F9AE04F93">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">LuaY</string>
						<string name="ScriptGuid">{E3CD5F1E-06A2-4F35-9A2D-069B507073B8}</string>
						<ProtectedString name="Source"><![CDATA[--# selene: allow(incorrect_standard_library_use, multiple_statements, shadowing, unused_variable, empty_if, divide_by_zero, unbalanced_assignments)
--[[--------------------------------------------------------------------

  lparser.lua
  Lua 5 parser in Lua
  This file is part of Yueliang.

  Copyright (c) 2005-2007 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * some unused C code that were not converted are kept as comments
-- * LUA_COMPAT_VARARG option changed into a comment block
-- * for value/size specific code added, look for 'NOTE: '
--
-- Not implemented:
-- * luaX_newstring not needed by this Lua implementation
-- * luaG_checkcode() in assert is not currently implemented
--
-- Added:
-- * some constants added from various header files
-- * luaY.LUA_QS used in error_expected, check_match (from luaconf.h)
-- * luaY:LUA_QL needed for error messages (from luaconf.h)
-- * luaY:growvector (from lmem.h) -- skeleton only, limit checking
-- * luaY.SHRT_MAX (from <limits.h>) for registerlocalvar
-- * luaY:newproto (from lfunc.c)
-- * luaY:int2fb (from lobject.c)
-- * NOTE: HASARG_MASK, for implementing a VARARG_HASARG bit operation
-- * NOTE: value-specific code for VARARG_NEEDSARG to replace a bitop
--
-- Changed in 5.1.x:
-- * various code changes are not detailed...
-- * names of constants may have changed, e.g. added a LUAI_ prefix
-- * struct expkind: added VKNUM, VVARARG; VCALL's info changed?
-- * struct expdesc: added nval
-- * struct FuncState: upvalues data type changed to upvaldesc
-- * macro hasmultret is new
-- * function checklimit moved to parser from lexer
-- * functions anchor_token, errorlimit, checknext are new
-- * checknext is new, equivalent to 5.0.x's check, see check too
-- * luaY:next and luaY:lookahead moved to lexer
-- * break keyword no longer skipped in luaY:breakstat
-- * function new_localvarstr replaced by new_localvarliteral
-- * registerlocalvar limits local variables to SHRT_MAX
-- * create_local deleted, new_localvarliteral used instead
-- * constant LUAI_MAXUPVALUES increased to 60
-- * constants MAXPARAMS, LUA_MAXPARSERLEVEL, MAXSTACK removed
-- * function interface changed: singlevaraux, singlevar
-- * enterlevel and leavelevel uses nCcalls to track call depth
-- * added a name argument to main entry function, luaY:parser
-- * function luaY_index changed to yindex
-- * luaY:int2fb()'s table size encoding format has been changed
-- * luaY:log2() no longer needed for table constructors
-- * function code_params deleted, functionality folded in parlist
-- * vararg flags handling (is_vararg) changes; also see VARARG_*
-- * LUA_COMPATUPSYNTAX section for old-style upvalues removed
-- * repeatstat() calls chunk() instead of block()
-- * function interface changed: cond, test_then_block
-- * while statement implementation considerably simplified; MAXEXPWHILE
--   and EXTRAEXP no longer required, no limits to the complexity of a
--   while condition
-- * repeat, forbody statement implementation has major changes,
--   mostly due to new scoping behaviour of local variables
-- * OPR_MULT renamed to OPR_MUL
----------------------------------------------------------------------]]

--requires luaP, luaX, luaK
local luaY = {}
local luaX = require(script.Parent.LuaX)
local luaK = require(script.Parent.LuaK)(luaY)
local luaP = require(script.Parent.LuaP)

--[[--------------------------------------------------------------------
-- Expression descriptor
-- * expkind changed to string constants; luaY:assignment was the only
--   function to use a relational operator with this enumeration
-- VVOID       -- no value
-- VNIL        -- no value
-- VTRUE       -- no value
-- VFALSE      -- no value
-- VK          -- info = index of constant in 'k'
-- VKNUM       -- nval = numerical value
-- VLOCAL      -- info = local register
-- VUPVAL,     -- info = index of upvalue in 'upvalues'
-- VGLOBAL     -- info = index of table; aux = index of global name in 'k'
-- VINDEXED    -- info = table register; aux = index register (or 'k')
-- VJMP        -- info = instruction pc
-- VRELOCABLE  -- info = instruction pc
-- VNONRELOC   -- info = result register
-- VCALL       -- info = instruction pc
-- VVARARG     -- info = instruction pc
} ----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- * expdesc in Lua 5.1.x has a union u and another struct s; this Lua
--   implementation ignores all instances of u and s usage
-- struct expdesc:
--   k  -- (enum: expkind)
--   info, aux -- (int, int)
--   nval -- (lua_Number)
--   t  -- patch list of 'exit when true'
--   f  -- patch list of 'exit when false'
----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- struct upvaldesc:
--   k  -- (lu_byte)
--   info -- (lu_byte)
----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- state needed to generate code for a given function
-- struct FuncState:
--   f  -- current function header (table: Proto)
--   h  -- table to find (and reuse) elements in 'k' (table: Table)
--   prev  -- enclosing function (table: FuncState)
--   ls  -- lexical state (table: LexState)
--   L  -- copy of the Lua state (table: lua_State)
--   bl  -- chain of current blocks (table: BlockCnt)
--   pc  -- next position to code (equivalent to 'ncode')
--   lasttarget   -- 'pc' of last 'jump target'
--   jpc  -- list of pending jumps to 'pc'
--   freereg  -- first free register
--   nk  -- number of elements in 'k'
--   np  -- number of elements in 'p'
--   nlocvars  -- number of elements in 'locvars'
--   nactvar  -- number of active local variables
--   upvalues[LUAI_MAXUPVALUES]  -- upvalues (table: upvaldesc)
--   actvar[LUAI_MAXVARS]  -- declared-variable stack
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- constants used by parser
-- * picks up duplicate values from luaX if required
------------------------------------------------------------------------

luaY.LUA_QS = luaX.LUA_QS or "'%s'"  -- (from luaconf.h)

luaY.SHRT_MAX = 32767 -- (from <limits.h>)
luaY.LUAI_MAXVARS = 200  -- (luaconf.h)
luaY.LUAI_MAXUPVALUES = 60  -- (luaconf.h)
luaY.MAX_INT = luaX.MAX_INT or 2147483645  -- (from llimits.h)
  -- * INT_MAX-2 for 32-bit systems
luaY.LUAI_MAXCCALLS = 200  -- (from luaconf.h)

luaY.VARARG_HASARG = 1  -- (from lobject.h)
-- NOTE: HASARG_MASK is value-specific
luaY.HASARG_MASK = 2 -- this was added for a bitop in parlist()
luaY.VARARG_ISVARARG = 2
-- NOTE: there is some value-specific code that involves VARARG_NEEDSARG
luaY.VARARG_NEEDSARG = 4

luaY.LUA_MULTRET = -1  -- (lua.h)

--[[--------------------------------------------------------------------
-- other functions
----------------------------------------------------------------------]]

--[[
##############################################################################################
##############################################################################################
##############################################################################################
--]]
function same(...)return...end
function disguise<A...>(...):A...return same(...)end

------------------------------------------------------------------------
-- LUA_QL describes how error messages quote program elements.
-- CHANGE it if you want a different appearance. (from luaconf.h)
------------------------------------------------------------------------
function luaY:LUA_QL(x)
  return "'"..x.."'"
end

------------------------------------------------------------------------
-- this is a stripped-down luaM_growvector (from lmem.h) which is a
-- macro based on luaM_growaux (in lmem.c); all the following does is
-- reproduce the size limit checking logic of the original function
-- so that error behaviour is identical; all arguments preserved for
-- convenience, even those which are unused
-- * set the t field to nil, since this originally does a sizeof(t)
-- * size (originally a pointer) is never updated, their final values
--   are set by luaY:close_func(), so overall things should still work
------------------------------------------------------------------------
function luaY:growvector(L, v, nelems, size, t, limit, e)
  if nelems >= limit then
    error(e)  -- was luaG_runerror
  end
end

------------------------------------------------------------------------
-- initialize a new function prototype structure (from lfunc.c)
-- * used only in open_func()
------------------------------------------------------------------------
function luaY:newproto(L)
  local f = {} -- Proto
  -- luaC_link(L, obj2gco(f), LUA_TPROTO); /* GC */
  f.k = {}
  f.sizek = 0
  f.p = {}
  f.sizep = 0
  f.code = {}
  f.sizecode = 0
  f.sizelineinfo = 0
  f.sizeupvalues = 0
  f.nups = 0
  f.upvalues = {}
  f.numparams = 0
  f.is_vararg = 0
  f.maxstacksize = 0
  f.lineinfo = {}
  f.sizelocvars = 0
  f.locvars = {}
  f.lineDefined = 0
  f.lastlinedefined = 0
  f.source = nil
  return f
end

------------------------------------------------------------------------
-- converts an integer to a "floating point byte", represented as
-- (eeeeexxx), where the real value is (1xxx) * 2^(eeeee - 1) if
-- eeeee != 0 and (xxx) otherwise.
------------------------------------------------------------------------
function luaY:int2fb(x)
  local e = 0  -- exponent
  while x >= 16 do
    x = math.floor((x + 1) / 2)
    e = e + 1
  end
  if x < 8 then
    return x
  else
    return ((e + 1) * 8) + (x - 8)
  end
end

--[[--------------------------------------------------------------------
-- parser functions
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- true of the kind of expression produces multiple return values
------------------------------------------------------------------------
function luaY:hasmultret(k)
  return k == "VCALL" or k == "VVARARG"
end

------------------------------------------------------------------------
-- convenience function to access active local i, returns entry
------------------------------------------------------------------------
function luaY:getlocvar(fs, i)
  return fs.f.locvars[ fs.actvar[i] ]
end

------------------------------------------------------------------------
-- check a limit, string m provided as an error message
------------------------------------------------------------------------
function luaY:checklimit(fs, v, l, m)
  if v > l then self:errorlimit(fs, l, m) end
end

--[[--------------------------------------------------------------------
-- nodes for block list (list of active blocks)
-- struct BlockCnt:
--   previous  -- chain (table: BlockCnt)
--   breaklist  -- list of jumps out of this loop
--   nactvar  -- # active local variables outside the breakable structure
--   upval  -- true if some variable in the block is an upvalue (boolean)
--   isbreakable  -- true if 'block' is a loop (boolean)
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- prototypes for recursive non-terminal functions
------------------------------------------------------------------------
-- prototypes deleted; not required in Lua

------------------------------------------------------------------------
-- reanchor if last token is has a constant string, see close_func()
-- * used only in close_func()
------------------------------------------------------------------------
function luaY:anchor_token(ls)
  if ls.t.token == "TK_NAME" or ls.t.token == "TK_STRING" then
    -- not relevant to Lua implementation of parser
    -- local ts = ls.t.seminfo
    -- luaX_newstring(ls, getstr(ts), ts->tsv.len); /* C */
  end
end

------------------------------------------------------------------------
-- throws a syntax error if token expected is not there
------------------------------------------------------------------------
function luaY:error_expected(ls, token)
  luaX:syntaxerror(ls,
    string.format(self.LUA_QS.." expected", luaX:token2str(ls, token)))
end

------------------------------------------------------------------------
-- prepares error message for display, for limits exceeded
-- * used only in checklimit()
------------------------------------------------------------------------
function luaY:errorlimit(fs, limit, what)
  local msg = (fs.f.linedefined == 0) and
    string.format("main function has more than %d %s", limit, what) or
    string.format("function at line %d has more than %d %s",
                  fs.f.linedefined, limit, what)
  luaX:lexerror(fs.ls, msg, 0)
end

------------------------------------------------------------------------
-- tests for a token, returns outcome
-- * return value changed to boolean
------------------------------------------------------------------------
function luaY:testnext(ls, c)
  if ls.t.token == c then
    luaX:next(ls)
    return true
  else
    return false
  end
end

------------------------------------------------------------------------
-- check for existence of a token, throws error if not found
------------------------------------------------------------------------
function luaY:check(ls, c)
  if ls.t.token ~= c then
    self:error_expected(ls, c)
  end
end

------------------------------------------------------------------------
-- verify existence of a token, then skip it
------------------------------------------------------------------------
function luaY:checknext(ls, c)
  self:check(ls, c)
  luaX:next(ls)
end

------------------------------------------------------------------------
-- throws error if condition not matched
------------------------------------------------------------------------
function luaY:check_condition(ls, c, msg)
  if not c then luaX:syntaxerror(ls, msg) end
end

------------------------------------------------------------------------
-- verifies token conditions are met or else throw error
------------------------------------------------------------------------
function luaY:check_match(ls, what, who, where)
  if not self:testnext(ls, what) then
    if where == ls.linenumber then
      self:error_expected(ls, what)
    else
      luaX:syntaxerror(ls, string.format(
        self.LUA_QS.." expected (to close "..self.LUA_QS.." at line %d)",
        luaX:token2str(ls, what), luaX:token2str(ls, who), where))
    end
  end
end

------------------------------------------------------------------------
-- expect that token is a name, return the name
------------------------------------------------------------------------
function luaY:str_checkname(ls)
  self:check(ls, "TK_NAME")
  local ts = ls.t.seminfo
  luaX:next(ls)
  return ts
end

------------------------------------------------------------------------
-- initialize a struct expdesc, expression description data structure
------------------------------------------------------------------------
function luaY:init_exp(e, k, i)
  e.f, e.t = luaK.NO_JUMP, luaK.NO_JUMP
  e.k = k
  e.info = i
end

------------------------------------------------------------------------
-- adds given string s in string pool, sets e as VK
------------------------------------------------------------------------
function luaY:codestring(ls, e, s)
  self:init_exp(e, "VK", luaK:stringK(ls.fs, s))
end

------------------------------------------------------------------------
-- consume a name token, adds it to string pool, sets e as VK
------------------------------------------------------------------------
function luaY:checkname(ls, e)
  self:codestring(ls, e, self:str_checkname(ls))
end

------------------------------------------------------------------------
-- creates struct entry for a local variable
-- * used only in new_localvar()
------------------------------------------------------------------------
function luaY:registerlocalvar(ls, varname)
  local fs = ls.fs
  local f = fs.f
  self:growvector(ls.L, f.locvars, fs.nlocvars, f.sizelocvars,
                  nil, self.SHRT_MAX, "too many local variables")
  -- loop to initialize empty f.locvar positions not required
  f.locvars[fs.nlocvars] = {} -- LocVar
  f.locvars[fs.nlocvars].varname = varname
  -- luaC_objbarrier(ls.L, f, varname) /* GC */
  local nlocvars = fs.nlocvars
  fs.nlocvars = fs.nlocvars + 1
  return nlocvars
end

------------------------------------------------------------------------
-- creates a new local variable given a name and an offset from nactvar
-- * used in fornum(), forlist(), parlist(), body()
------------------------------------------------------------------------
function luaY:new_localvarliteral(ls, v, n)
  self:new_localvar(ls, v, n)
end

------------------------------------------------------------------------
-- register a local variable, set in active variable list
------------------------------------------------------------------------
function luaY:new_localvar(ls, name, n)
  local fs = ls.fs
  self:checklimit(fs, fs.nactvar + n + 1, self.LUAI_MAXVARS, "local variables")
  fs.actvar[fs.nactvar + n] = self:registerlocalvar(ls, name)
end

------------------------------------------------------------------------
-- adds nvars number of new local variables, set debug information
------------------------------------------------------------------------
function luaY:adjustlocalvars(ls, nvars)
  local fs = ls.fs
  fs.nactvar = fs.nactvar + nvars
  for i = nvars, 1, -1 do
    self:getlocvar(fs, fs.nactvar - i).startpc = fs.pc
  end
end

------------------------------------------------------------------------
-- removes a number of locals, set debug information
------------------------------------------------------------------------
function luaY:removevars(ls, tolevel)
  local fs = ls.fs
  while fs.nactvar > tolevel do
    fs.nactvar = fs.nactvar - 1
    self:getlocvar(fs, fs.nactvar).endpc = fs.pc
  end
end

------------------------------------------------------------------------
-- returns an existing upvalue index based on the given name, or
-- creates a new upvalue struct entry and returns the new index
-- * used only in singlevaraux()
------------------------------------------------------------------------
function luaY:indexupvalue(fs, name, v)
  local f = fs.f
  for i = 0, f.nups - 1 do
    if fs.upvalues[i].k == v.k and fs.upvalues[i].info == v.info then
      assert(f.upvalues[i] == name)
      return i
    end
  end
  -- new one
  self:checklimit(fs, f.nups + 1, self.LUAI_MAXUPVALUES, "upvalues")
  self:growvector(fs.L, f.upvalues, f.nups, f.sizeupvalues,
                  nil, self.MAX_INT, "")
  -- loop to initialize empty f.upvalues positions not required
  f.upvalues[f.nups] = name
  -- luaC_objbarrier(fs->L, f, name); /* GC */
  assert(v.k == "VLOCAL" or v.k == "VUPVAL")
  -- this is a partial copy; only k & info fields used
  fs.upvalues[f.nups] = { k = v.k, info = v.info }
  local nups = f.nups
  f.nups = f.nups + 1
  return nups
end

------------------------------------------------------------------------
-- search the local variable namespace of the given fs for a match
-- * used only in singlevaraux()
------------------------------------------------------------------------
function luaY:searchvar(fs, n)
  for i = fs.nactvar - 1, 0, -1 do
    if n == self:getlocvar(fs, i).varname then
      return i
    end
  end
  return -1  -- not found
end

------------------------------------------------------------------------
-- * mark upvalue flags in function states up to a given level
-- * used only in singlevaraux()
------------------------------------------------------------------------
function luaY:markupval(fs, level)
  local bl = fs.bl
  while bl and bl.nactvar > level do bl = bl.previous end
  if bl then bl.upval = true end
end

------------------------------------------------------------------------
-- handle locals, globals and upvalues and related processing
-- * search mechanism is recursive, calls itself to search parents
-- * used only in singlevar()
------------------------------------------------------------------------
function luaY:singlevaraux(fs, n, var, base)
  if fs == nil then  -- no more levels?
    self:init_exp(var, "VGLOBAL", luaP.NO_REG)  -- default is global variable
    return "VGLOBAL"
  else
    local v = self:searchvar(fs, n)  -- look up at current level
    if v >= 0 then
      self:init_exp(var, "VLOCAL", v)
      if base == 0 then
        self:markupval(fs, v)  -- local will be used as an upval
      end
      return "VLOCAL"
    else  -- not found at current level; try upper one
      if self:singlevaraux(fs.prev, n, var, 0) == "VGLOBAL" then
        return "VGLOBAL"
      end
      var.info = self:indexupvalue(fs, n, var)  -- else was LOCAL or UPVAL
      var.k = "VUPVAL"  -- upvalue in this level
      return "VUPVAL"
    end--if v
  end--if fs
end

------------------------------------------------------------------------
-- consume a name token, creates a variable (global|local|upvalue)
-- * used in prefixexp(), funcname()
------------------------------------------------------------------------
function luaY:singlevar(ls, var)
  local varname = self:str_checkname(ls)
  local fs = ls.fs
  if self:singlevaraux(fs, varname, var, 1) == "VGLOBAL" then
    var.info = luaK:stringK(fs, varname)  -- info points to global name
  end
end

------------------------------------------------------------------------
-- adjust RHS to match LHS in an assignment
-- * used in assignment(), forlist(), localstat()
------------------------------------------------------------------------
function luaY:adjust_assign(ls, nvars, nexps, e)
  local fs = ls.fs
  local extra = nvars - nexps
  if self:hasmultret(e.k) then
    extra = extra + 1  -- includes call itself
    if extra <= 0 then extra = 0 end
    luaK:setreturns(fs, e, extra)  -- last exp. provides the difference
    if extra > 1 then luaK:reserveregs(fs, extra - 1) end
  else
    if e.k ~= "VVOID" then luaK:exp2nextreg(fs, e) end  -- close last expression
    if extra > 0 then
      local reg = fs.freereg
      luaK:reserveregs(fs, extra)
      luaK:_nil(fs, reg, extra)
    end
  end
end

------------------------------------------------------------------------
-- tracks and limits parsing depth, assert check at end of parsing
------------------------------------------------------------------------
function luaY:enterlevel(ls)
  ls.L.nCcalls = ls.L.nCcalls + 1
  if ls.L.nCcalls > self.LUAI_MAXCCALLS then
    luaX:lexerror(ls, "chunk has too many syntax levels", 0)
  end
end

------------------------------------------------------------------------
-- tracks parsing depth, a pair with luaY:enterlevel()
------------------------------------------------------------------------
function luaY:leavelevel(ls)
  ls.L.nCcalls = ls.L.nCcalls - 1
end

------------------------------------------------------------------------
-- enters a code unit, initializes elements
------------------------------------------------------------------------
function luaY:enterblock(fs, bl, isbreakable)
  bl.breaklist = luaK.NO_JUMP
  bl.isbreakable = isbreakable
  bl.nactvar = fs.nactvar
  bl.upval = false
  bl.previous = fs.bl
  fs.bl = bl
  assert(fs.freereg == fs.nactvar)
end

------------------------------------------------------------------------
-- leaves a code unit, close any upvalues
------------------------------------------------------------------------
function luaY:leaveblock(fs)
  local bl = fs.bl
  fs.bl = bl.previous
  self:removevars(fs.ls, bl.nactvar)
  if bl.upval then
    luaK:codeABC(fs, "OP_CLOSE", bl.nactvar, 0, 0)
  end
  -- a block either controls scope or breaks (never both)
  assert(not bl.isbreakable or not bl.upval)
  assert(bl.nactvar == fs.nactvar)
  fs.freereg = fs.nactvar  -- free registers
  luaK:patchtohere(fs, bl.breaklist)
end

------------------------------------------------------------------------
-- implement the instantiation of a function prototype, append list of
-- upvalues after the instantiation instruction
-- * used only in body()
------------------------------------------------------------------------
function luaY:pushclosure(ls, func, v)
  local fs = ls.fs
  local f = fs.f
  self:growvector(ls.L, f.p, fs.np, f.sizep, nil,
                  luaP.MAXARG_Bx, "constant table overflow")
  -- loop to initialize empty f.p positions not required
  f.p[fs.np] = func.f
  fs.np = fs.np + 1
  -- luaC_objbarrier(ls->L, f, func->f); /* C */
  self:init_exp(v, "VRELOCABLE", luaK:codeABx(fs, "OP_CLOSURE", 0, fs.np - 1))
  for i = 0, func.f.nups - 1 do
    local o = (func.upvalues[i].k == "VLOCAL") and "OP_MOVE" or "OP_GETUPVAL"
    luaK:codeABC(fs, o, 0, func.upvalues[i].info, 0)
  end
end

------------------------------------------------------------------------
-- opening of a function
------------------------------------------------------------------------
function luaY:open_func(ls, fs)
  local L = ls.L
  local f = self:newproto(ls.L)
  fs.f = f
  fs.prev = ls.fs  -- linked list of funcstates
  fs.ls = ls
  fs.L = L
  ls.fs = fs
  fs.pc = 0
  fs.lasttarget = -1
  fs.jpc = luaK.NO_JUMP
  fs.freereg = 0
  fs.nk = 0
  fs.np = 0
  fs.nlocvars = 0
  fs.nactvar = 0
  fs.bl = nil
  f.source = ls.source
  f.maxstacksize = 2  -- registers 0/1 are always valid
  fs.h = {}  -- constant table; was luaH_new call
  -- anchor table of constants and prototype (to avoid being collected)
  -- sethvalue2s(L, L->top, fs->h); incr_top(L); /* C */
  -- setptvalue2s(L, L->top, f); incr_top(L);
end

------------------------------------------------------------------------
-- closing of a function
------------------------------------------------------------------------
function luaY:close_func(ls)
  local L = ls.L
  local fs = ls.fs
  local f = fs.f
  self:removevars(ls, 0)
  luaK:ret(fs, 0, 0)  -- final return
  -- luaM_reallocvector deleted for f->code, f->lineinfo, f->k, f->p,
  -- f->locvars, f->upvalues; not required for Lua table arrays
  f.sizecode = fs.pc
  f.sizelineinfo = fs.pc
  f.sizek = fs.nk
  f.sizep = fs.np
  f.sizelocvars = fs.nlocvars
  f.sizeupvalues = f.nups
  --assert(luaG_checkcode(f))  -- currently not implemented
  assert(fs.bl == nil)
  ls.fs = fs.prev
  -- the following is not required for this implementation; kept here
  -- for completeness
  -- L->top -= 2;  /* remove table and prototype from the stack */
  -- last token read was anchored in defunct function; must reanchor it
  if fs then self:anchor_token(ls) end
end

------------------------------------------------------------------------
-- parser initialization function
-- * note additional sub-tables needed for LexState, FuncState
------------------------------------------------------------------------
function luaY:parser(L, z, buff, name)
  local lexstate = disguise{}  -- LexState
        lexstate.t = {}
        lexstate.lookahead = {}
  local funcstate = disguise{}  -- FuncState
        funcstate.upvalues = {}
        funcstate.actvar = {}
  -- the following nCcalls initialization added for convenience
  L.nCcalls = 0
  lexstate.buff = buff
  luaX:setinput(L, lexstate, z, name)
  self:open_func(lexstate, funcstate)
  funcstate.f.is_vararg = self.VARARG_ISVARARG  -- main func. is always vararg
  luaX:next(lexstate)  -- read first token
  self:chunk(lexstate)
  self:check(lexstate, "TK_EOS")
  self:close_func(lexstate)
  assert(funcstate.prev == nil)
  assert(funcstate.f.nups == 0)
  assert(lexstate.fs == nil)
  return funcstate.f
end

--[[--------------------------------------------------------------------
-- GRAMMAR RULES
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- parse a function name suffix, for function call specifications
-- * used in primaryexp(), funcname()
------------------------------------------------------------------------
function luaY:field(ls, v)
  -- field -> ['.' | ':'] NAME
  local fs = ls.fs
  local key = {}  -- expdesc
  luaK:exp2anyreg(fs, v)
  luaX:next(ls)  -- skip the dot or colon
  self:checkname(ls, key)
  luaK:indexed(fs, v, key)
end

------------------------------------------------------------------------
-- parse a table indexing suffix, for constructors, expressions
-- * used in recfield(), primaryexp()
------------------------------------------------------------------------
function luaY:yindex(ls, v)
  -- index -> '[' expr ']'
  luaX:next(ls)  -- skip the '['
  self:expr(ls, v)
  luaK:exp2val(ls.fs, v)
  self:checknext(ls, "]")
end

--[[--------------------------------------------------------------------
-- Rules for Constructors
----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- struct ConsControl:
--   v  -- last list item read (table: struct expdesc)
--   t  -- table descriptor (table: struct expdesc)
--   nh  -- total number of 'record' elements
--   na  -- total number of array elements
--   tostore  -- number of array elements pending to be stored
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- parse a table record (hash) field
-- * used in constructor()
------------------------------------------------------------------------
function luaY:recfield(ls, cc)
  -- recfield -> (NAME | '['exp1']') = exp1
  local fs = ls.fs
  local reg = ls.fs.freereg
  local key, val = {}, {}  -- expdesc
  if ls.t.token == "TK_NAME" then
    self:checklimit(fs, cc.nh, self.MAX_INT, "items in a constructor")
    self:checkname(ls, key)
  else  -- ls->t.token == '['
    self:yindex(ls, key)
  end
  cc.nh = cc.nh + 1
  self:checknext(ls, "=")
  local rkkey = luaK:exp2RK(fs, key)
  self:expr(ls, val)
  luaK:codeABC(fs, "OP_SETTABLE", cc.t.info, rkkey, luaK:exp2RK(fs, val))
  fs.freereg = reg  -- free registers
end

------------------------------------------------------------------------
-- emit a set list instruction if enough elements (LFIELDS_PER_FLUSH)
-- * used in constructor()
------------------------------------------------------------------------
function luaY:closelistfield(fs, cc)
  if cc.v.k == "VVOID" then return end  -- there is no list item
  luaK:exp2nextreg(fs, cc.v)
  cc.v.k = "VVOID"
  if cc.tostore == luaP.LFIELDS_PER_FLUSH then
    luaK:setlist(fs, cc.t.info, cc.na, cc.tostore)  -- flush
    cc.tostore = 0  -- no more items pending
  end
end

------------------------------------------------------------------------
-- emit a set list instruction at the end of parsing list constructor
-- * used in constructor()
------------------------------------------------------------------------
function luaY:lastlistfield(fs, cc)
  if cc.tostore == 0 then return end
  if self:hasmultret(cc.v.k) then
    luaK:setmultret(fs, cc.v)
    luaK:setlist(fs, cc.t.info, cc.na, self.LUA_MULTRET)
    cc.na = cc.na - 1  -- do not count last expression (unknown number of elements)
  else
    if cc.v.k ~= "VVOID" then
      luaK:exp2nextreg(fs, cc.v)
    end
    luaK:setlist(fs, cc.t.info, cc.na, cc.tostore)
  end
end

------------------------------------------------------------------------
-- parse a table list (array) field
-- * used in constructor()
------------------------------------------------------------------------
function luaY:listfield(ls, cc)
  self:expr(ls, cc.v)
  self:checklimit(ls.fs, cc.na, self.MAX_INT, "items in a constructor")
  cc.na = cc.na + 1
  cc.tostore = cc.tostore + 1
end

------------------------------------------------------------------------
-- parse a table constructor
-- * used in funcargs(), simpleexp()
------------------------------------------------------------------------
function luaY:constructor(ls, t)
  -- constructor -> '{' [ field { fieldsep field } [ fieldsep ] ] '}'
  -- field -> recfield | listfield
  -- fieldsep -> ',' | ';'
  local fs = ls.fs
  local line = ls.linenumber
  local pc = luaK:codeABC(fs, "OP_NEWTABLE", 0, 0, 0)
  local cc = {}  -- ConsControl
        cc.v = {}
  cc.na, cc.nh, cc.tostore = 0, 0, 0
  cc.t = t
  self:init_exp(t, "VRELOCABLE", pc)
  self:init_exp(cc.v, "VVOID", 0)  -- no value (yet)
  luaK:exp2nextreg(ls.fs, t)  -- fix it at stack top (for gc)
  self:checknext(ls, "{")
  repeat
    assert(cc.v.k == "VVOID" or cc.tostore > 0)
    if ls.t.token == "}" then break end
    self:closelistfield(fs, cc)
    local c = ls.t.token

    if c == "TK_NAME" then  -- may be listfields or recfields
      luaX:lookahead(ls)
      if ls.lookahead.token ~= "=" then  -- expression?
        self:listfield(ls, cc)
      else
        self:recfield(ls, cc)
      end
    elseif c == "[" then  -- constructor_item -> recfield
      self:recfield(ls, cc)
    else  -- constructor_part -> listfield
      self:listfield(ls, cc)
    end
  until not self:testnext(ls, ",") and not self:testnext(ls, ";")
  self:check_match(ls, "}", "{", line)
  self:lastlistfield(fs, cc)
  luaP:SETARG_B(fs.f.code[pc], self:int2fb(cc.na)) -- set initial array size
  luaP:SETARG_C(fs.f.code[pc], self:int2fb(cc.nh)) -- set initial table size
end

-- }======================================================================

------------------------------------------------------------------------
-- parse the arguments (parameters) of a function declaration
-- * used in body()
------------------------------------------------------------------------
function luaY:parlist(ls)
  -- parlist -> [ param { ',' param } ]
  local fs = ls.fs
  local f = fs.f
  local nparams = 0
  f.is_vararg = 0
  if ls.t.token ~= ")" then  -- is 'parlist' not empty?
    repeat
      local c = ls.t.token
      if c == "TK_NAME" then  -- param -> NAME
        self:new_localvar(ls, self:str_checkname(ls), nparams)
        nparams = nparams + 1
      elseif c == "TK_DOTS" then  -- param -> `...'
        luaX:next(ls)
-- [[
-- #if defined(LUA_COMPAT_VARARG)
        -- use `arg' as default name
        self:new_localvarliteral(ls, "arg", nparams)
        nparams = nparams + 1
        f.is_vararg = self.VARARG_HASARG + self.VARARG_NEEDSARG
-- #endif
--]]
        f.is_vararg = f.is_vararg + self.VARARG_ISVARARG
      else
        luaX:syntaxerror(ls, "<name> or "..self:LUA_QL("...").." expected")
      end
    until f.is_vararg ~= 0 or not self:testnext(ls, ",")
  end--if
  self:adjustlocalvars(ls, nparams)
  -- NOTE: the following works only when HASARG_MASK is 2!
  f.numparams = fs.nactvar - (f.is_vararg % self.HASARG_MASK)
  luaK:reserveregs(fs, fs.nactvar)  -- reserve register for parameters
end

------------------------------------------------------------------------
-- parse function declaration body
-- * used in simpleexp(), localfunc(), funcstat()
------------------------------------------------------------------------
function luaY:body(ls, e, needself, line)
  -- body ->  '(' parlist ')' chunk END
  local new_fs = disguise{}  -- FuncState
        new_fs.upvalues = {}
        new_fs.actvar = {}
  self:open_func(ls, new_fs)
  new_fs.f.lineDefined = line
  self:checknext(ls, "(")
  if needself then
    self:new_localvarliteral(ls, "self", 0)
    self:adjustlocalvars(ls, 1)
  end
  self:parlist(ls)
  self:checknext(ls, ")")
  self:chunk(ls)
  new_fs.f.lastlinedefined = ls.linenumber
  self:check_match(ls, "TK_END", "TK_FUNCTION", line)
  self:close_func(ls)
  self:pushclosure(ls, new_fs, e)
end

------------------------------------------------------------------------
-- parse a list of comma-separated expressions
-- * used is multiple locations
------------------------------------------------------------------------
function luaY:explist1(ls, v)
  -- explist1 -> expr { ',' expr }
  local n = 1  -- at least one expression
  self:expr(ls, v)
  while self:testnext(ls, ",") do
    luaK:exp2nextreg(ls.fs, v)
    self:expr(ls, v)
    n = n + 1
  end
  return n
end

------------------------------------------------------------------------
-- parse the parameters of a function call
-- * contrast with parlist(), used in function declarations
-- * used in primaryexp()
------------------------------------------------------------------------
function luaY:funcargs(ls, f)
  local fs = ls.fs
  local args = {}  -- expdesc
  local nparams
  local line = ls.linenumber
  local c = ls.t.token
  if c == "(" then  -- funcargs -> '(' [ explist1 ] ')'
    if line ~= ls.lastline then
      luaX:syntaxerror(ls, "ambiguous syntax (function call x new statement)")
    end
    luaX:next(ls)
    if ls.t.token == ")" then  -- arg list is empty?
      args.k = "VVOID"
    else
      self:explist1(ls, args)
      luaK:setmultret(fs, args)
    end
    self:check_match(ls, ")", "(", line)
  elseif c == "{" then  -- funcargs -> constructor
    self:constructor(ls, args)
  elseif c == "TK_STRING" then  -- funcargs -> STRING
    self:codestring(ls, args, ls.t.seminfo)
    luaX:next(ls)  -- must use 'seminfo' before 'next'
  else
    luaX:syntaxerror(ls, "function arguments expected")
    return
  end
  assert(f.k == "VNONRELOC")
  local base = f.info  -- base register for call
  if self:hasmultret(args.k) then
    nparams = self.LUA_MULTRET  -- open call
  else
    if args.k ~= "VVOID" then
      luaK:exp2nextreg(fs, args)  -- close last argument
    end
    nparams = fs.freereg - (base + 1)
  end
  self:init_exp(f, "VCALL", luaK:codeABC(fs, "OP_CALL", base, nparams + 1, 2))
  luaK:fixline(fs, line)
  fs.freereg = base + 1  -- call remove function and arguments and leaves
                         -- (unless changed) one result
end

--[[--------------------------------------------------------------------
-- Expression parsing
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- parses an expression in parentheses or a single variable
-- * used in primaryexp()
------------------------------------------------------------------------
function luaY:prefixexp(ls, v)
  -- prefixexp -> NAME | '(' expr ')'
  local c = ls.t.token
  if c == "(" then
    local line = ls.linenumber
    luaX:next(ls)
    self:expr(ls, v)
    self:check_match(ls, ")", "(", line)
    luaK:dischargevars(ls.fs, v)
  elseif c == "TK_NAME" then
    self:singlevar(ls, v)
  else
    luaX:syntaxerror(ls, "unexpected symbol")
  end--if c
  return
end

------------------------------------------------------------------------
-- parses a prefixexp (an expression in parentheses or a single variable)
-- or a function call specification
-- * used in simpleexp(), assignment(), exprstat()
------------------------------------------------------------------------
function luaY:primaryexp(ls, v)
  -- primaryexp ->
  --    prefixexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs }
  local fs = ls.fs
  self:prefixexp(ls, v)
  while true do
    local c = ls.t.token
    if c == "." then  -- field
      self:field(ls, v)
    elseif c == "[" then  -- '[' exp1 ']'
      local key = {}  -- expdesc
      luaK:exp2anyreg(fs, v)
      self:yindex(ls, key)
      luaK:indexed(fs, v, key)
    elseif c == ":" then  -- ':' NAME funcargs
      local key = {}  -- expdesc
      luaX:next(ls)
      self:checkname(ls, key)
      luaK:_self(fs, v, key)
      self:funcargs(ls, v)
    elseif c == "(" or c == "TK_STRING" or c == "{" then  -- funcargs
      luaK:exp2nextreg(fs, v)
      self:funcargs(ls, v)
    else
      return
    end--if c
  end--while
end

------------------------------------------------------------------------
-- parses general expression types, constants handled here
-- * used in subexpr()
------------------------------------------------------------------------
function luaY:simpleexp(ls, v)
  -- simpleexp -> NUMBER | STRING | NIL | TRUE | FALSE | ... |
  --              constructor | FUNCTION body | primaryexp
  local c = ls.t.token
  if c == "TK_NUMBER" then
    self:init_exp(v, "VKNUM", 0)
    v.nval = ls.t.seminfo
  elseif c == "TK_STRING" then
    self:codestring(ls, v, ls.t.seminfo)
  elseif c == "TK_NIL" then
    self:init_exp(v, "VNIL", 0)
  elseif c == "TK_TRUE" then
    self:init_exp(v, "VTRUE", 0)
  elseif c == "TK_FALSE" then
    self:init_exp(v, "VFALSE", 0)
  elseif c == "TK_DOTS" then  -- vararg
    local fs = ls.fs
    self:check_condition(ls, fs.f.is_vararg ~= 0,
                    "cannot use "..self:LUA_QL("...").." outside a vararg function");
    -- NOTE: the following substitutes for a bitop, but is value-specific
    local is_vararg = fs.f.is_vararg
    if is_vararg >= self.VARARG_NEEDSARG then
      fs.f.is_vararg = is_vararg - self.VARARG_NEEDSARG  -- don't need 'arg'
    end
    self:init_exp(v, "VVARARG", luaK:codeABC(fs, "OP_VARARG", 0, 1, 0))
  elseif c == "{" then  -- constructor
    self:constructor(ls, v)
    return
  elseif c == "TK_FUNCTION" then
    luaX:next(ls)
    self:body(ls, v, false, ls.linenumber)
    return
  else
    self:primaryexp(ls, v)
    return
  end--if c
  luaX:next(ls)
end

------------------------------------------------------------------------
-- Translates unary operators tokens if found, otherwise returns
-- OPR_NOUNOPR. getunopr() and getbinopr() are used in subexpr().
-- * used in subexpr()
------------------------------------------------------------------------
function luaY:getunopr(op)
  if op == "TK_NOT" then
    return "OPR_NOT"
  elseif op == "-" then
    return "OPR_MINUS"
  elseif op == "#" then
    return "OPR_LEN"
  else
    return "OPR_NOUNOPR"
  end
end

------------------------------------------------------------------------
-- Translates binary operator tokens if found, otherwise returns
-- OPR_NOBINOPR. Code generation uses OPR_* style tokens.
-- * used in subexpr()
------------------------------------------------------------------------
luaY.getbinopr_table = {
  ["+"] = "OPR_ADD",
  ["-"] = "OPR_SUB",
  ["*"] = "OPR_MUL",
  ["/"] = "OPR_DIV",
  ["%"] = "OPR_MOD",
  ["^"] = "OPR_POW",
  ["TK_CONCAT"] = "OPR_CONCAT",
  ["TK_NE"] = "OPR_NE",
  ["TK_EQ"] = "OPR_EQ",
  ["<"] = "OPR_LT",
  ["TK_LE"] = "OPR_LE",
  [">"] = "OPR_GT",
  ["TK_GE"] = "OPR_GE",
  ["TK_AND"] = "OPR_AND",
  ["TK_OR"] = "OPR_OR",
}
function luaY:getbinopr(op)
  local opr = self.getbinopr_table[op]
  if opr then return opr else return "OPR_NOBINOPR" end
end

------------------------------------------------------------------------
-- the following priority table consists of pairs of left/right values
-- for binary operators (was a static const struct); grep for ORDER OPR
-- * the following struct is replaced:
--   static const struct {
--     lu_byte left;  /* left priority for each binary operator */
--     lu_byte right; /* right priority */
--   } priority[] = {  /* ORDER OPR */
------------------------------------------------------------------------
luaY.priority = {
  {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7}, -- `+' `-' `/' `%'
  {10, 9}, {5, 4},                 -- power and concat (right associative)
  {3, 3}, {3, 3},                  -- equality
  {3, 3}, {3, 3}, {3, 3}, {3, 3},  -- order
  {2, 2}, {1, 1}                   -- logical (and/or)
}

luaY.UNARY_PRIORITY = 8  -- priority for unary operators

------------------------------------------------------------------------
-- Parse subexpressions. Includes handling of unary operators and binary
-- operators. A subexpr is given the rhs priority level of the operator
-- immediately left of it, if any (limit is -1 if none,) and if a binop
-- is found, limit is compared with the lhs priority level of the binop
-- in order to determine which executes first.
------------------------------------------------------------------------

------------------------------------------------------------------------
-- subexpr -> (simpleexp | unop subexpr) { binop subexpr }
-- where 'binop' is any binary operator with a priority higher than 'limit'
-- * for priority lookups with self.priority[], 1=left and 2=right
-- * recursively called
-- * used in expr()
------------------------------------------------------------------------
function luaY:subexpr(ls, v, limit)
  self:enterlevel(ls)
  local uop = self:getunopr(ls.t.token)
  if uop ~= "OPR_NOUNOPR" then
    luaX:next(ls)
    self:subexpr(ls, v, self.UNARY_PRIORITY)
    luaK:prefix(ls.fs, uop, v)
  else
    self:simpleexp(ls, v)
  end
  -- expand while operators have priorities higher than 'limit'
  local op = self:getbinopr(ls.t.token)
  while op ~= "OPR_NOBINOPR" and self.priority[luaK.BinOpr[op] + 1][1] > limit do
    local v2 = {}  -- expdesc
    luaX:next(ls)
    luaK:infix(ls.fs, op, v)
    -- read sub-expression with higher priority
    local nextop = self:subexpr(ls, v2, self.priority[luaK.BinOpr[op] + 1][2])
    luaK:posfix(ls.fs, op, v, v2)
    op = nextop
  end
  self:leavelevel(ls)
  return op  -- return first untreated operator
end

------------------------------------------------------------------------
-- Expression parsing starts here. Function subexpr is entered with the
-- left operator (which is non-existent) priority of -1, which is lower
-- than all actual operators. Expr information is returned in parm v.
-- * used in multiple locations
------------------------------------------------------------------------
function luaY:expr(ls, v)
  self:subexpr(ls, v, 0)
end

-- }====================================================================

--[[--------------------------------------------------------------------
-- Rules for Statements
----------------------------------------------------------------------]]

------------------------------------------------------------------------
-- checks next token, used as a look-ahead
-- * returns boolean instead of 0|1
-- * used in retstat(), chunk()
------------------------------------------------------------------------
function luaY:block_follow(token)
  if token == "TK_ELSE" or token == "TK_ELSEIF" or token == "TK_END"
     or token == "TK_UNTIL" or token == "TK_EOS" then
    return true
  else
    return false
  end
end

------------------------------------------------------------------------
-- parse a code block or unit
-- * used in multiple functions
------------------------------------------------------------------------
function luaY:block(ls)
  -- block -> chunk
  local fs = ls.fs
  local bl = disguise{}  -- BlockCnt
  self:enterblock(fs, bl, false)
  self:chunk(ls)
  assert(bl.breaklist == luaK.NO_JUMP)
  self:leaveblock(fs)
end

------------------------------------------------------------------------
-- structure to chain all variables in the left-hand side of an
-- assignment
-- struct LHS_assign:
--   prev  -- (table: struct LHS_assign)
--   v  -- variable (global, local, upvalue, or indexed) (table: expdesc)
------------------------------------------------------------------------

------------------------------------------------------------------------
-- check whether, in an assignment to a local variable, the local variable
-- is needed in a previous assignment (to a table). If so, save original
-- local value in a safe place and use this safe copy in the previous
-- assignment.
-- * used in assignment()
------------------------------------------------------------------------
function luaY:check_conflict(ls, lh, v)
  local fs = ls.fs
  local extra = fs.freereg  -- eventual position to save local variable
  local conflict = false
  while lh do
    if lh.v.k == "VINDEXED" then
      if lh.v.info == v.info then  -- conflict?
        conflict = true
        lh.v.info = extra  -- previous assignment will use safe copy
      end
      if lh.v.aux == v.info then  -- conflict?
        conflict = true
        lh.v.aux = extra  -- previous assignment will use safe copy
      end
    end
    lh = lh.prev
  end
  if conflict then
    luaK:codeABC(fs, "OP_MOVE", fs.freereg, v.info, 0)  -- make copy
    luaK:reserveregs(fs, 1)
  end
end

------------------------------------------------------------------------
-- parse a variable assignment sequence
-- * recursively called
-- * used in exprstat()
------------------------------------------------------------------------
function luaY:assignment(ls, lh, nvars)
  local e = {}  -- expdesc
  -- test was: VLOCAL <= lh->v.k && lh->v.k <= VINDEXED
  local c = lh.v.k
  self:check_condition(ls, c == "VLOCAL" or c == "VUPVAL" or c == "VGLOBAL"
                       or c == "VINDEXED", "syntax error")
  if self:testnext(ls, ",") then  -- assignment -> ',' primaryexp assignment
    local nv = {}  -- LHS_assign
          nv.v = {}
    nv.prev = lh
    self:primaryexp(ls, nv.v)
    if nv.v.k == "VLOCAL" then
      self:check_conflict(ls, lh, nv.v)
    end
    self:checklimit(ls.fs, nvars, self.LUAI_MAXCCALLS - ls.L.nCcalls,
                    "variables in assignment")
    self:assignment(ls, nv, nvars + 1)
  else  -- assignment -> '=' explist1
    self:checknext(ls, "=")
    local nexps = self:explist1(ls, e)
    if nexps ~= nvars then
      self:adjust_assign(ls, nvars, nexps, e)
      if nexps > nvars then
        ls.fs.freereg = ls.fs.freereg - (nexps - nvars)  -- remove extra values
      end
    else
      luaK:setoneret(ls.fs, e)  -- close last expression
      luaK:storevar(ls.fs, lh.v, e)
      return  -- avoid default
    end
  end
  self:init_exp(e, "VNONRELOC", ls.fs.freereg - 1)  -- default assignment
  luaK:storevar(ls.fs, lh.v, e)
end

------------------------------------------------------------------------
-- parse condition in a repeat statement or an if control structure
-- * used in repeatstat(), test_then_block()
------------------------------------------------------------------------
function luaY:cond(ls)
  -- cond -> exp
  local v = disguise{}  -- expdesc
  self:expr(ls, v)  -- read condition
  if v.k == "VNIL" then v.k = "VFALSE" end  -- 'falses' are all equal here
  luaK:goiftrue(ls.fs, v)
  return v.f
end

------------------------------------------------------------------------
-- parse a break statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:breakstat(ls)
  -- stat -> BREAK
  local fs = ls.fs
  local bl = fs.bl
  local upval = false
  while bl and not bl.isbreakable do
    if bl.upval then upval = true end
    bl = bl.previous
  end
  if not bl then
    luaX:syntaxerror(ls, "no loop to break")
  end
  if upval then
    luaK:codeABC(fs, "OP_CLOSE", bl.nactvar, 0, 0)
  end
  bl.breaklist = luaK:concat(fs, bl.breaklist, luaK:jump(fs))
end

------------------------------------------------------------------------
-- parse a while-do control structure, body processed by block()
-- * with dynamic array sizes, MAXEXPWHILE + EXTRAEXP limits imposed by
--   the function's implementation can be removed
-- * used in statements()
------------------------------------------------------------------------
function luaY:whilestat(ls, line)
  -- whilestat -> WHILE cond DO block END
  local fs = ls.fs
  local bl = {}  -- BlockCnt
  luaX:next(ls)  -- skip WHILE
  local whileinit = luaK:getlabel(fs)
  local condexit = self:cond(ls)
  self:enterblock(fs, bl, true)
  self:checknext(ls, "TK_DO")
  self:block(ls)
  luaK:patchlist(fs, luaK:jump(fs), whileinit)
  self:check_match(ls, "TK_END", "TK_WHILE", line)
  self:leaveblock(fs)
  luaK:patchtohere(fs, condexit)  -- false conditions finish the loop
end

------------------------------------------------------------------------
-- parse a repeat-until control structure, body parsed by chunk()
-- * used in statements()
------------------------------------------------------------------------
function luaY:repeatstat(ls, line)
  -- repeatstat -> REPEAT block UNTIL cond
  local fs = ls.fs
  local repeat_init = luaK:getlabel(fs)
  local bl1, bl2 = {}, {}  -- BlockCnt
  self:enterblock(fs, bl1, true)  -- loop block
  self:enterblock(fs, bl2, false)  -- scope block
  luaX:next(ls)  -- skip REPEAT
  self:chunk(ls)
  self:check_match(ls, "TK_UNTIL", "TK_REPEAT", line)
  local condexit = self:cond(ls)  -- read condition (inside scope block)
  if not disguise(bl2).upval then  -- no upvalues?
    self:leaveblock(fs)  -- finish scope
    luaK:patchlist(ls.fs, condexit, repeat_init)  -- close the loop
  else  -- complete semantics when there are upvalues
    self:breakstat(ls)  -- if condition then break
    luaK:patchtohere(ls.fs, condexit)  -- else...
    self:leaveblock(fs)  -- finish scope...
    luaK:patchlist(ls.fs, luaK:jump(fs), repeat_init)  -- and repeat
  end
  self:leaveblock(fs)  -- finish loop
end

------------------------------------------------------------------------
-- parse the single expressions needed in numerical for loops
-- * used in fornum()
------------------------------------------------------------------------
function luaY:exp1(ls)
  local e = disguise{}  -- expdesc
  self:expr(ls, e)
  local k = e.k
  luaK:exp2nextreg(ls.fs, e)
  return k
end

------------------------------------------------------------------------
-- parse a for loop body for both versions of the for loop
-- * used in fornum(), forlist()
------------------------------------------------------------------------
function luaY:forbody(ls, base, line, nvars, isnum)
  -- forbody -> DO block
  local bl = {}  -- BlockCnt
  local fs = ls.fs
  self:adjustlocalvars(ls, 3)  -- control variables
  self:checknext(ls, "TK_DO")
  local prep = isnum and luaK:codeAsBx(fs, "OP_FORPREP", base, luaK.NO_JUMP)
                     or luaK:jump(fs)
  self:enterblock(fs, bl, false)  -- scope for declared variables
  self:adjustlocalvars(ls, nvars)
  luaK:reserveregs(fs, nvars)
  self:block(ls)
  self:leaveblock(fs)  -- end of scope for declared variables
  luaK:patchtohere(fs, prep)
  local endfor = isnum and luaK:codeAsBx(fs, "OP_FORLOOP", base, luaK.NO_JUMP)
                       or luaK:codeABC(fs, "OP_TFORLOOP", base, 0, nvars)
  luaK:fixline(fs, line)  -- pretend that `OP_FOR' starts the loop
  luaK:patchlist(fs, isnum and endfor or luaK:jump(fs), prep + 1)
end

------------------------------------------------------------------------
-- parse a numerical for loop, calls forbody()
-- * used in forstat()
------------------------------------------------------------------------
function luaY:fornum(ls, varname, line)
  -- fornum -> NAME = exp1,exp1[,exp1] forbody
  local fs = ls.fs
  local base = fs.freereg
  self:new_localvarliteral(ls, "(for index)", 0)
  self:new_localvarliteral(ls, "(for limit)", 1)
  self:new_localvarliteral(ls, "(for step)", 2)
  self:new_localvar(ls, varname, 3)
  self:checknext(ls, '=')
  self:exp1(ls)  -- initial value
  self:checknext(ls, ",")
  self:exp1(ls)  -- limit
  if self:testnext(ls, ",") then
    self:exp1(ls)  -- optional step
  else  -- default step = 1
    luaK:codeABx(fs, "OP_LOADK", fs.freereg, luaK:numberK(fs, 1))
    luaK:reserveregs(fs, 1)
  end
  self:forbody(ls, base, line, 1, true)
end

------------------------------------------------------------------------
-- parse a generic for loop, calls forbody()
-- * used in forstat()
------------------------------------------------------------------------
function luaY:forlist(ls, indexname)
  -- forlist -> NAME {,NAME} IN explist1 forbody
  local fs = ls.fs
  local e = {}  -- expdesc
  local nvars = 0
  local base = fs.freereg
  -- create control variables
  self:new_localvarliteral(ls, "(for generator)", nvars)
  nvars = nvars + 1
  self:new_localvarliteral(ls, "(for state)", nvars)
  nvars = nvars + 1
  self:new_localvarliteral(ls, "(for control)", nvars)
  nvars = nvars + 1
  -- create declared variables
  self:new_localvar(ls, indexname, nvars)
  nvars = nvars + 1
  while self:testnext(ls, ",") do
    self:new_localvar(ls, self:str_checkname(ls), nvars)
    nvars = nvars + 1
  end
  self:checknext(ls, "TK_IN")
  local line = ls.linenumber
  self:adjust_assign(ls, 3, self:explist1(ls, e), e)
  luaK:checkstack(fs, 3)  -- extra space to call generator
  self:forbody(ls, base, line, nvars - 3, false)
end

------------------------------------------------------------------------
-- initial parsing for a for loop, calls fornum() or forlist()
-- * used in statements()
------------------------------------------------------------------------
function luaY:forstat(ls, line)
  -- forstat -> FOR (fornum | forlist) END
  local fs = ls.fs
  local bl = {}  -- BlockCnt
  self:enterblock(fs, bl, true)  -- scope for loop and control variables
  luaX:next(ls)  -- skip `for'
  local varname = self:str_checkname(ls)  -- first variable name
  local c = ls.t.token
  if c == "=" then
    self:fornum(ls, varname, line)
  elseif c == "," or c == "TK_IN" then
    self:forlist(ls, varname)
  else
    luaX:syntaxerror(ls, self:LUA_QL("=").." or "..self:LUA_QL("in").." expected")
  end
  self:check_match(ls, "TK_END", "TK_FOR", line)
  self:leaveblock(fs)  -- loop scope (`break' jumps to this point)
end

------------------------------------------------------------------------
-- parse part of an if control structure, including the condition
-- * used in ifstat()
------------------------------------------------------------------------
function luaY:test_then_block(ls)
  -- test_then_block -> [IF | ELSEIF] cond THEN block
  luaX:next(ls)  -- skip IF or ELSEIF
  local condexit = self:cond(ls)
  self:checknext(ls, "TK_THEN")
  self:block(ls)  -- `then' part
  return condexit
end

------------------------------------------------------------------------
-- parse an if control structure
-- * used in statements()
------------------------------------------------------------------------
function luaY:ifstat(ls, line)
  -- ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END
  local fs = ls.fs
  local escapelist = luaK.NO_JUMP
  local flist = self:test_then_block(ls)  -- IF cond THEN block
  while ls.t.token == "TK_ELSEIF" do
    escapelist = luaK:concat(fs, escapelist, luaK:jump(fs))
    luaK:patchtohere(fs, flist)
    flist = self:test_then_block(ls)  -- ELSEIF cond THEN block
  end
  if ls.t.token == "TK_ELSE" then
    escapelist = luaK:concat(fs, escapelist, luaK:jump(fs))
    luaK:patchtohere(fs, flist)
    luaX:next(ls)  -- skip ELSE (after patch, for correct line info)
    self:block(ls)  -- 'else' part
  else
    escapelist = luaK:concat(fs, escapelist, flist)
  end
  luaK:patchtohere(fs, escapelist)
  self:check_match(ls, "TK_END", "TK_IF", line)
end

------------------------------------------------------------------------
-- parse a local function statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:localfunc(ls)
  local v, b = {}, {}  -- expdesc
  local fs = ls.fs
  self:new_localvar(ls, self:str_checkname(ls), 0)
  self:init_exp(v, "VLOCAL", fs.freereg)
  luaK:reserveregs(fs, 1)
  self:adjustlocalvars(ls, 1)
  self:body(ls, b, false, ls.linenumber)
  luaK:storevar(fs, v, b)
  -- debug information will only see the variable after this point!
  self:getlocvar(fs, fs.nactvar - 1).startpc = fs.pc
end

------------------------------------------------------------------------
-- parse a local variable declaration statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:localstat(ls)
  -- stat -> LOCAL NAME {',' NAME} ['=' explist1]
  local nvars = 0
  local nexps
  local e = {}  -- expdesc
  repeat
    self:new_localvar(ls, self:str_checkname(ls), nvars)
    nvars = nvars + 1
  until not self:testnext(ls, ",")
  if self:testnext(ls, "=") then
    nexps = self:explist1(ls, e)
  else
    e.k = "VVOID"
    nexps = 0
  end
  self:adjust_assign(ls, nvars, nexps, e)
  self:adjustlocalvars(ls, nvars)
end

------------------------------------------------------------------------
-- parse a function name specification
-- * used in funcstat()
------------------------------------------------------------------------
function luaY:funcname(ls, v)
  -- funcname -> NAME {field} [':' NAME]
  local needself = false
  self:singlevar(ls, v)
  while ls.t.token == "." do
    self:field(ls, v)
  end
  if ls.t.token == ":" then
    needself = true
    self:field(ls, v)
  end
  return needself
end

------------------------------------------------------------------------
-- parse a function statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:funcstat(ls, line)
  -- funcstat -> FUNCTION funcname body
  local v, b = {}, {}  -- expdesc
  luaX:next(ls)  -- skip FUNCTION
  local needself = self:funcname(ls, v)
  self:body(ls, b, needself, line)
  luaK:storevar(ls.fs, v, b)
  luaK:fixline(ls.fs, line)  -- definition 'happens' in the first line
end

------------------------------------------------------------------------
-- parse a function call with no returns or an assignment statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:exprstat(ls)
  -- stat -> func | assignment
  local fs = ls.fs
  local v = {}  -- LHS_assign
        v.v = {}
  self:primaryexp(ls, v.v)
  if v.v.k == "VCALL" then  -- stat -> func
    luaP:SETARG_C(luaK:getcode(fs, v.v), 1)  -- call statement uses no results
  else  -- stat -> assignment
    v.prev = nil
    self:assignment(ls, v, 1)
  end
end

------------------------------------------------------------------------
-- parse a return statement
-- * used in statements()
------------------------------------------------------------------------
function luaY:retstat(ls)
  -- stat -> RETURN explist
  local fs = ls.fs
  local e = disguise{}  -- expdesc
  local first, nret  -- registers with returned values
  luaX:next(ls)  -- skip RETURN
  if self:block_follow(ls.t.token) or ls.t.token == ";" then
    first, nret = 0, 0  -- return no values
  else
    nret = self:explist1(ls, e)  -- optional return values
    if self:hasmultret(e.k) then
      luaK:setmultret(fs, e)
      if e.k == "VCALL" and nret == 1 then  -- tail call?
        luaP:SET_OPCODE(luaK:getcode(fs, e), "OP_TAILCALL")
        assert(luaP:GETARG_A(luaK:getcode(fs, e)) == fs.nactvar)
      end
      first = fs.nactvar
      nret = self.LUA_MULTRET  -- return all values
    else
      if nret == 1 then  -- only one single value?
        first = luaK:exp2anyreg(fs, e)
      else
        luaK:exp2nextreg(fs, e)  -- values must go to the 'stack'
        first = fs.nactvar  -- return all 'active' values
        assert(nret == fs.freereg - first)
      end
    end--if
  end--if
  luaK:ret(fs, first, nret)
end

------------------------------------------------------------------------
-- initial parsing for statements, calls a lot of functions
-- * returns boolean instead of 0|1
-- * used in chunk()
------------------------------------------------------------------------
function luaY:statement(ls)
  local line = ls.linenumber  -- may be needed for error messages
  local c = ls.t.token
  if c == "TK_IF" then  -- stat -> ifstat
    self:ifstat(ls, line)
    return false
  elseif c == "TK_WHILE" then  -- stat -> whilestat
    self:whilestat(ls, line)
    return false
  elseif c == "TK_DO" then  -- stat -> DO block END
    luaX:next(ls)  -- skip DO
    self:block(ls)
    self:check_match(ls, "TK_END", "TK_DO", line)
    return false
  elseif c == "TK_FOR" then  -- stat -> forstat
    self:forstat(ls, line)
    return false
  elseif c == "TK_REPEAT" then  -- stat -> repeatstat
    self:repeatstat(ls, line)
    return false
  elseif c == "TK_FUNCTION" then  -- stat -> funcstat
    self:funcstat(ls, line)
    return false
  elseif c == "TK_LOCAL" then  -- stat -> localstat
    luaX:next(ls)  -- skip LOCAL
    if self:testnext(ls, "TK_FUNCTION") then  -- local function?
      self:localfunc(ls)
    else
      self:localstat(ls)
    end
    return false
  elseif c == "TK_RETURN" then  -- stat -> retstat
    self:retstat(ls)
    return true  -- must be last statement
  elseif c == "TK_BREAK" then  -- stat -> breakstat
    luaX:next(ls)  -- skip BREAK
    self:breakstat(ls)
    return true  -- must be last statement
  else
    self:exprstat(ls)
    return false  -- to avoid warnings
  end--if c
end

------------------------------------------------------------------------
-- parse a chunk, which consists of a bunch of statements
-- * used in parser(), body(), block(), repeatstat()
------------------------------------------------------------------------
function luaY:chunk(ls)
  -- chunk -> { stat [';'] }
  local islast = false
  self:enterlevel(ls)
  while not islast and not self:block_follow(ls.t.token) do
    islast = self:statement(ls)
    self:testnext(ls, ";")
    assert(ls.fs.f.maxstacksize >= ls.fs.freereg and
               ls.fs.freereg >= ls.fs.nactvar)
    ls.fs.freereg = ls.fs.nactvar  -- free registers
  end
  self:leavelevel(ls)
end

-- }======================================================================
return luaY]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFC31284D19B34775802AF11C26150955">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">LuaZ</string>
						<string name="ScriptGuid">{BCA5480E-BD70-4427-BF45-695A8FDBE299}</string>
						<ProtectedString name="Source"><![CDATA[--# selene: allow(incorrect_standard_library_use, multiple_statements, shadowing, unused_variable, empty_if, divide_by_zero, unbalanced_assignments)
--[[--------------------------------------------------------------------

  lzio.lua
  Lua buffered streams in Lua
  This file is part of Yueliang.

  Copyright (c) 2005-2006 Kein-Hong Man <khman@users.sf.net>
  The COPYRIGHT file describes the conditions
  under which this software may be distributed.

  See the ChangeLog for more information.

----------------------------------------------------------------------]]

--[[--------------------------------------------------------------------
-- Notes:
-- * EOZ is implemented as a string, "EOZ"
-- * Format of z structure (ZIO)
--     z.n       -- bytes still unread
--     z.p       -- last read position position in buffer
--     z.reader  -- chunk reader function
--     z.data    -- additional data
-- * Current position, p, is now last read index instead of a pointer
--
-- Not implemented:
-- * luaZ_lookahead: used only in lapi.c:lua_load to detect binary chunk
-- * luaZ_read: used only in lundump.c:ezread to read +1 bytes
-- * luaZ_openspace: dropped; let Lua handle buffers as strings (used in
--   lundump.c:LoadString & lvm.c:luaV_concat)
-- * luaZ buffer macros: dropped; buffers are handled as strings
-- * lauxlib.c:getF reader implementation has an extraline flag to
--   skip over a shbang (#!) line, this is not implemented here
--
-- Added:
-- (both of the following are vaguely adapted from lauxlib.c)
-- * luaZ:make_getS: create Reader from a string
-- * luaZ:make_getF: create Reader that reads from a file
--
-- Changed in 5.1.x:
-- * Chunkreader renamed to Reader (ditto with Chunkwriter)
-- * Zio struct: no more name string, added Lua state for reader
--   (however, Yueliang readers do not require a Lua state)
----------------------------------------------------------------------]]

local luaZ = {}

------------------------------------------------------------------------
-- * reader() should return a string, or nil if nothing else to parse.
--   Additional data can be set only during stream initialization
-- * Readers are handled in lauxlib.c, see luaL_load(file|buffer|string)
-- * LUAL_BUFFERSIZE=BUFSIZ=512 in make_getF() (located in luaconf.h)
-- * Original Reader typedef:
--   const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);
-- * This Lua chunk reader implementation:
--   returns string or nil, no arguments to function
------------------------------------------------------------------------

------------------------------------------------------------------------
-- create a chunk reader from a source string
------------------------------------------------------------------------
function luaZ:make_getS(buff)
  local b = buff
  return function() -- chunk reader anonymous function here
    if not b then return nil end
    local data = b
    b = nil
    return data
  end
end

------------------------------------------------------------------------
-- create a chunk reader from a source file
------------------------------------------------------------------------
--[[
function luaZ:make_getF(filename)
  local LUAL_BUFFERSIZE = 512
  local h = io.open(filename, "r")
  if not h then return nil end
  return function() -- chunk reader anonymous function here
    if not h or io.type(h) == "closed file" then return nil end
    local buff = h:read(LUAL_BUFFERSIZE)
    if not buff then h:close(); h = nil end
    return buff
  end
end
--]]
------------------------------------------------------------------------
-- creates a zio input stream
-- returns the ZIO structure, z
------------------------------------------------------------------------
function luaZ:init(reader, data, name)
  if not reader then return end
  local z = {}
  z.reader = reader
  z.data = data or ""
  z.name = name
  -- set up additional data for reading
  if not data or data == "" then z.n = 0 else z.n = #data end
  z.p = 0
  return z
end

------------------------------------------------------------------------
-- fill up input buffer
------------------------------------------------------------------------
function luaZ:fill(z)
  local buff = z.reader()
  z.data = buff
  if not buff or buff == "" then return "EOZ" end
  z.n, z.p = #buff - 1, 1
  return string.sub(buff, 1, 1)
end

------------------------------------------------------------------------
-- get next character from the input stream
-- * local n, p are used to optimize code generation
------------------------------------------------------------------------
function luaZ:zgetc(z)
  local n, p = z.n, z.p + 1
  if n > 0 then
    z.n, z.p = n - 1, p
    return string.sub(z.data, p, p)
  else
    return self:fill(z)
  end
end

return luaZ]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD671CFE4B11D4452936D38D145418BE9">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">FiOne</string>
						<string name="ScriptGuid">{F1402B74-6DC7-42A6-84A7-A3CFD9318F2E}</string>
						<ProtectedString name="Source"><![CDATA[--# selene: allow(divide_by_zero, multiple_statements)
local bit = bit32
local unpack = table.unpack or unpack

local stm_lua_bytecode
local wrap_lua_func
local stm_lua_func

-- SETLIST config
local FIELDS_PER_FLUSH = 50

-- remap for better lookup
local OPCODE_RM = {
	-- level 1
	[22] = 18, -- JMP
	[31] = 8, -- FORLOOP
	[33] = 28, -- TFORLOOP
	-- level 2
	[0] = 3, -- MOVE
	[1] = 13, -- LOADK
	[2] = 23, -- LOADBOOL
	[26] = 33, -- TEST
	-- level 3
	[12] = 1, -- ADD
	[13] = 6, -- SUB
	[14] = 10, -- MUL
	[15] = 16, -- DIV
	[16] = 20, -- MOD
	[17] = 26, -- POW
	[18] = 30, -- UNM
	[19] = 36, -- NOT
	-- level 4
	[3] = 0, -- LOADNIL
	[4] = 2, -- GETUPVAL
	[5] = 4, -- GETGLOBAL
	[6] = 7, -- GETTABLE
	[7] = 9, -- SETGLOBAL
	[8] = 12, -- SETUPVAL
	[9] = 14, -- SETTABLE
	[10] = 17, -- NEWTABLE
	[20] = 19, -- LEN
	[21] = 22, -- CONCAT
	[23] = 24, -- EQ
	[24] = 27, -- LT
	[25] = 29, -- LE
	[27] = 32, -- TESTSET
	[32] = 34, -- FORPREP
	[34] = 37, -- SETLIST
	-- level 5
	[11] = 5, -- SELF
	[28] = 11, -- CALL
	[29] = 15, -- TAILCALL
	[30] = 21, -- RETURN
	[35] = 25, -- CLOSE
	[36] = 31, -- CLOSURE
	[37] = 35, -- VARARG
}

-- opcode types for getting values
local OPCODE_T = {
	[0] = 'ABC',
	'ABx',
	'ABC',
	'ABC',
	'ABC',
	'ABx',
	'ABC',
	'ABx',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'AsBx',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'ABC',
	'AsBx',
	'AsBx',
	'ABC',
	'ABC',
	'ABC',
	'ABx',
	'ABC',
}

local OPCODE_M = {
	[0] = {b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgK', c = 'OpArgN'},
	{b = 'OpArgU', c = 'OpArgU'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgU', c = 'OpArgN'},
	{b = 'OpArgK', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgN'},
	{b = 'OpArgU', c = 'OpArgN'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgU', c = 'OpArgU'},
	{b = 'OpArgR', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgR'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgK', c = 'OpArgK'},
	{b = 'OpArgR', c = 'OpArgU'},
	{b = 'OpArgR', c = 'OpArgU'},
	{b = 'OpArgU', c = 'OpArgU'},
	{b = 'OpArgU', c = 'OpArgU'},
	{b = 'OpArgU', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgR', c = 'OpArgN'},
	{b = 'OpArgN', c = 'OpArgU'},
	{b = 'OpArgU', c = 'OpArgU'},
	{b = 'OpArgN', c = 'OpArgN'},
	{b = 'OpArgU', c = 'OpArgN'},
	{b = 'OpArgU', c = 'OpArgN'},
}

-- int rd_int_basic(string src, int s, int e, int d)
-- @src - Source binary string
-- @s - Start index of a little endian integer
-- @e - End index of the integer
-- @d - Direction of the loop
local function rd_int_basic(src, s, e, d)
	local num = 0

	-- if bb[l] > 127 then -- signed negative
	-- 	num = num - 256 ^ l
	-- 	bb[l] = bb[l] - 128
	-- end

	for i = s, e, d do num = num + string.byte(src, i, i) * 256 ^ (i - s) end

	return num
end

-- float rd_flt_basic(byte f1..8)
-- @f1..4 - The 4 bytes composing a little endian float
local function rd_flt_basic(f1, f2, f3, f4)
	local sign = (-1) ^ bit.rshift(f4, 7)
	local exp = bit.rshift(f3, 7) + bit.lshift(bit.band(f4, 0x7F), 1)
	local frac = f1 + bit.lshift(f2, 8) + bit.lshift(bit.band(f3, 0x7F), 16)
	local normal = 1

	if exp == 0 then
		if frac == 0 then
			return sign * 0
		else
			normal = 0
			exp = 1
		end
	elseif exp == 0x7F then
		if frac == 0 then
			return sign * (1 / 0)
		else
			return sign * (0 / 0)
		end
	end

	return sign * 2 ^ (exp - 127) * (1 + normal / 2 ^ 23)
end

-- double rd_dbl_basic(byte f1..8)
-- @f1..8 - The 8 bytes composing a little endian double
local function rd_dbl_basic(f1, f2, f3, f4, f5, f6, f7, f8)
	local sign = (-1) ^ bit.rshift(f8, 7)
	local exp = bit.lshift(bit.band(f8, 0x7F), 4) + bit.rshift(f7, 4)
	local frac = bit.band(f7, 0x0F) * 2 ^ 48
	local normal = 1

	frac = frac + (f6 * 2 ^ 40) + (f5 * 2 ^ 32) + (f4 * 2 ^ 24) + (f3 * 2 ^ 16) + (f2 * 2 ^ 8) + f1 -- help

	if exp == 0 then
		if frac == 0 then
			return sign * 0
		else
			normal = 0
			exp = 1
		end
	elseif exp == 0x7FF then
		if frac == 0 then
			return sign * (1 / 0)
		else
			return sign * (0 / 0)
		end
	end

	return sign * 2 ^ (exp - 1023) * (normal + frac / 2 ^ 52)
end

-- int rd_int_le(string src, int s, int e)
-- @src - Source binary string
-- @s - Start index of a little endian integer
-- @e - End index of the integer
local function rd_int_le(src, s, e) return rd_int_basic(src, s, e - 1, 1) end

-- int rd_int_be(string src, int s, int e)
-- @src - Source binary string
-- @s - Start index of a big endian integer
-- @e - End index of the integer
local function rd_int_be(src, s, e) return rd_int_basic(src, e - 1, s, -1) end

-- float rd_flt_le(string src, int s)
-- @src - Source binary string
-- @s - Start index of little endian float
local function rd_flt_le(src, s) return rd_flt_basic(string.byte(src, s, s + 3)) end

-- float rd_flt_be(string src, int s)
-- @src - Source binary string
-- @s - Start index of big endian float
local function rd_flt_be(src, s)
	local f1, f2, f3, f4 = string.byte(src, s, s + 3)
	return rd_flt_basic(f4, f3, f2, f1)
end

-- double rd_dbl_le(string src, int s)
-- @src - Source binary string
-- @s - Start index of little endian double
local function rd_dbl_le(src, s) return rd_dbl_basic(string.byte(src, s, s + 7)) end

-- double rd_dbl_be(string src, int s)
-- @src - Source binary string
-- @s - Start index of big endian double
local function rd_dbl_be(src, s)
	local f1, f2, f3, f4, f5, f6, f7, f8 = string.byte(src, s, s + 7) -- same
	return rd_dbl_basic(f8, f7, f6, f5, f4, f3, f2, f1)
end

-- to avoid nested ifs in deserializing
local float_types = {
	[4] = {little = rd_flt_le, big = rd_flt_be},
	[8] = {little = rd_dbl_le, big = rd_dbl_be},
}

-- byte stm_byte(Stream S)
-- @S - Stream object to read from
local function stm_byte(S)
	local idx = S.index
	local bt = string.byte(S.source, idx, idx)

	S.index = idx + 1
	return bt
end

-- string stm_string(Stream S, int len)
-- @S - Stream object to read from
-- @len - Length of string being read
local function stm_string(S, len)
	local pos = S.index + len
	local str = string.sub(S.source, S.index, pos - 1)

	S.index = pos
	return str
end

-- string stm_lstring(Stream S)
-- @S - Stream object to read from
local function stm_lstring(S)
	local len = S:s_szt()
	local str

	if len ~= 0 then str = string.sub(stm_string(S, len), 1, -2) end

	return str
end

-- fn cst_int_rdr(string src, int len, fn func)
-- @len - Length of type for reader
-- @func - Reader callback
local function cst_int_rdr(len, func)
	return function(S)
		local pos = S.index + len
		local int = func(S.source, S.index, pos)
		S.index = pos

		return int
	end
end

-- fn cst_flt_rdr(string src, int len, fn func)
-- @len - Length of type for reader
-- @func - Reader callback
local function cst_flt_rdr(len, func)
	return function(S)
		local flt = func(S.source, S.index)
		S.index = S.index + len

		return flt
	end
end

local function stm_instructions(S)
	local size = S:s_int()
	local code = {}

	for i = 1, size do
		local ins = S:s_ins()
		local op = bit.band(ins, 0x3F)
		local args = OPCODE_T[op]
		local mode = OPCODE_M[op]
		local data = {value = ins, op = OPCODE_RM[op], A = bit.band(bit.rshift(ins, 6), 0xFF)}

		if args == 'ABC' then
			data.B = bit.band(bit.rshift(ins, 23), 0x1FF)
			data.C = bit.band(bit.rshift(ins, 14), 0x1FF)
			data.is_KB = mode.b == 'OpArgK' and data.B > 0xFF -- post process optimization
			data.is_KC = mode.c == 'OpArgK' and data.C > 0xFF
		elseif args == 'ABx' then
			data.Bx = bit.band(bit.rshift(ins, 14), 0x3FFFF)
			data.is_K = mode.b == 'OpArgK'
		elseif args == 'AsBx' then
			data.sBx = bit.band(bit.rshift(ins, 14), 0x3FFFF) - 131071
		end

		code[i] = data
	end

	return code
end

local function stm_constants(S)
	local size = S:s_int()
	local consts = {}

	for i = 1, size do
		local tt = stm_byte(S)
		local k

		if tt == 1 then
			k = stm_byte(S) ~= 0
		elseif tt == 3 then
			k = S:s_num()
		elseif tt == 4 then
			k = stm_lstring(S)
		end

		consts[i] = k -- offset +1 during instruction decode
	end

	return consts
end

local function stm_subfuncs(S, src)
	local size = S:s_int()
	local sub = {}

	for i = 1, size do
		sub[i] = stm_lua_func(S, src) -- offset +1 in CLOSURE
	end

	return sub
end

local function stm_lineinfo(S)
	local size = S:s_int()
	local lines = {}

	for i = 1, size do lines[i] = S:s_int() end

	return lines
end

local function stm_locvars(S)
	local size = S:s_int()
	local locvars = {}

	for i = 1, size do locvars[i] = {varname = stm_lstring(S), startpc = S:s_int(), endpc = S:s_int()} end

	return locvars
end

local function stm_upvals(S)
	local size = S:s_int()
	local upvals = {}

	for i = 1, size do upvals[i] = stm_lstring(S) end

	return upvals
end

function stm_lua_func(S, psrc)
	local proto = {}
	local src = stm_lstring(S) or psrc -- source is propagated

	proto.source = src -- source name

	S:s_int() -- line defined
	S:s_int() -- last line defined

	proto.numupvals = stm_byte(S) -- num upvalues
	proto.numparams = stm_byte(S) -- num params

	stm_byte(S) -- vararg flag
	stm_byte(S) -- max stack size

	proto.code = stm_instructions(S)
	proto.const = stm_constants(S)
	proto.subs = stm_subfuncs(S, src)
	proto.lines = stm_lineinfo(S)

	stm_locvars(S)
	stm_upvals(S)

	-- post process optimization
	for _, v in ipairs(proto.code) do
		if v.is_K then
			v.const = proto.const[v.Bx + 1] -- offset for 1 based index
		else
			if v.is_KB then v.const_B = proto.const[v.B - 0xFF] end

			if v.is_KC then v.const_C = proto.const[v.C - 0xFF] end
		end
	end

	return proto
end

function stm_lua_bytecode(src)
	-- func reader
	local rdr_func

	-- header flags
	local little
	local size_int
	local size_szt
	local size_ins
	local size_num
	local flag_int

	-- stream object
	local stream = {
		-- data
		index = 1,
		source = src,
	}

	assert(stm_string(stream, 4) == '\27Lua', 'invalid Lua signature')
	assert(stm_byte(stream) == 0x51, 'invalid Lua version')
	assert(stm_byte(stream) == 0, 'invalid Lua format')

	little = stm_byte(stream) ~= 0
	size_int = stm_byte(stream)
	size_szt = stm_byte(stream)
	size_ins = stm_byte(stream)
	size_num = stm_byte(stream)
	flag_int = stm_byte(stream) ~= 0

	rdr_func = little and rd_int_le or rd_int_be
	stream.s_int = cst_int_rdr(size_int, rdr_func)
	stream.s_szt = cst_int_rdr(size_szt, rdr_func)
	stream.s_ins = cst_int_rdr(size_ins, rdr_func)

	if flag_int then
		stream.s_num = cst_int_rdr(size_num, rdr_func)
	elseif float_types[size_num] then
		stream.s_num = cst_flt_rdr(size_num, float_types[size_num][little and 'little' or 'big'])
	else
		error('unsupported float size')
	end

	return stm_lua_func(stream, '@virtual')
end

local function close_lua_upvalues(list, index)
	for i, uv in pairs(list) do
		if uv.index >= index then
			uv.value = uv.store[uv.index] -- store value
			uv.store = uv
			uv.index = 'value' -- self reference
			list[i] = nil
		end
	end
end

local function open_lua_upvalue(list, index, stack)
	local prev = list[index]

	if not prev then
		prev = {index = index, store = stack}
		list[index] = prev
	end

	return prev
end

local function wrap_lua_variadic(...) return select('#', ...), {...} end

local function on_lua_error(exst, err)
	local src = exst.source
	local line = exst.lines[exst.pc - 1]
	local psrc, pline, pmsg = string.match(err or '', '^(.-):(%d+):%s+(.+)')
	local fmt = '%s:%i: [%s:%i] %s'

	line = line or '0'
	psrc = psrc or '?'
	pline = pline or '0'
	pmsg = pmsg or err or ''

	error(string.format(fmt, src, line, psrc, pline, pmsg), 0)
end

local function exec_lua_func(exst)
	-- localize for easy lookup
	local code = exst.code
	local subs = exst.subs
	local env = exst.env
	local upvs = exst.upvals
	local vargs = exst.varargs

	-- state variables
	local stktop = -1
	local openupvs = {}
	local stack = exst.stack
	local pc = exst.pc

	while true do
		local inst = code[pc]
		local op = inst.op
		pc = pc + 1

		if op < 18 then
			if op < 8 then
				if op < 3 then
					if op < 1 then
						--[[LOADNIL]]
						for i = inst.A, inst.B do stack[i] = nil end
					elseif op > 1 then
						--[[GETUPVAL]]
						local uv = upvs[inst.B]

						stack[inst.A] = uv.store[uv.index]
					else
						--[[ADD]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = stack[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = stack[inst.C]
						end

						stack[inst.A] = lhs + rhs
					end
				elseif op > 3 then
					if op < 6 then
						if op > 4 then
							--[[SELF]]
							local A = inst.A
							local B = inst.B
							local index

							if inst.is_KC then
								index = inst.const_C
							else
								index = stack[inst.C]
							end

							stack[A + 1] = stack[B]
							stack[A] = stack[B][index]
						else
							--[[GETGLOBAL]]
							stack[inst.A] = env[inst.const]
						end
					elseif op > 6 then
						--[[GETTABLE]]
						local index

						if inst.is_KC then
							index = inst.const_C
						else
							index = stack[inst.C]
						end

						stack[inst.A] = stack[inst.B][index]
					else
						--[[SUB]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = stack[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = stack[inst.C]
						end

						stack[inst.A] = lhs - rhs
					end
				else --[[MOVE]]
					stack[inst.A] = stack[inst.B]
				end
			elseif op > 8 then
				if op < 13 then
					if op < 10 then
						--[[SETGLOBAL]]
						env[inst.const] = stack[inst.A]
					elseif op > 10 then
						if op < 12 then
							--[[CALL]]
							local A = inst.A
							local B = inst.B
							local C = inst.C
							local params
							local sz_vals, l_vals

							if B == 0 then
								params = stktop - A
							else
								params = B - 1
							end

							sz_vals, l_vals = wrap_lua_variadic(stack[A](unpack(stack, A + 1, A + params)))

							if C == 0 then
								stktop = A + sz_vals - 1
							else
								sz_vals = C - 1
							end

							for i = 1, sz_vals do stack[A + i - 1] = l_vals[i] end
						else
							--[[SETUPVAL]]
							local uv = upvs[inst.B]

							uv.store[uv.index] = stack[inst.A]
						end
					else
						--[[MUL]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = stack[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = stack[inst.C]
						end

						stack[inst.A] = lhs * rhs
					end
				elseif op > 13 then
					if op < 16 then
						if op > 14 then
							--[[TAILCALL]]
							local A = inst.A
							local B = inst.B
							local params

							if B == 0 then
								params = stktop - A
							else
								params = B - 1
							end

							close_lua_upvalues(openupvs, 0)
							return wrap_lua_variadic(stack[A](unpack(stack, A + 1, A + params)))
						else
							--[[SETTABLE]]
							local index, value

							if inst.is_KB then
								index = inst.const_B
							else
								index = stack[inst.B]
							end

							if inst.is_KC then
								value = inst.const_C
							else
								value = stack[inst.C]
							end

							stack[inst.A][index] = value
						end
					elseif op > 16 then
						--[[NEWTABLE]]
						stack[inst.A] = {}
					else
						--[[DIV]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = stack[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = stack[inst.C]
						end

						stack[inst.A] = lhs / rhs
					end
				else
					--[[LOADK]]
					stack[inst.A] = inst.const
				end
			else
				--[[FORLOOP]]
				local A = inst.A
				local step = stack[A + 2]
				local index = stack[A] + step
				local limit = stack[A + 1]
				local loops

				if step == math.abs(step) then
					loops = index <= limit
				else
					loops = index >= limit
				end

				if loops then
					stack[inst.A] = index
					stack[inst.A + 3] = index
					pc = pc + inst.sBx
				end
			end
		elseif op > 18 then
			if op < 28 then
				if op < 23 then
					if op < 20 then
						--[[LEN]]
						stack[inst.A] = #stack[inst.B]
					elseif op > 20 then
						if op < 22 then
							--[[RETURN]]
							local A = inst.A
							local B = inst.B
							local vals = {}
							local size

							if B == 0 then
								size = stktop - A + 1
							else
								size = B - 1
							end

							for i = 1, size do vals[i] = stack[A + i - 1] end

							close_lua_upvalues(openupvs, 0)
							return size, vals
						else
							--[[CONCAT]]
							local str = stack[inst.B]

							for i = inst.B + 1, inst.C do str = str .. stack[i] end

							stack[inst.A] = str
						end
					else
						--[[MOD]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = stack[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = stack[inst.C]
						end

						stack[inst.A] = lhs % rhs
					end
				elseif op > 23 then
					if op < 26 then
						if op > 24 then
							--[[CLOSE]]
							close_lua_upvalues(openupvs, inst.A)
						else
							--[[EQ]]
							local lhs, rhs

							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = stack[inst.B]
							end

							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = stack[inst.C]
							end

							if (lhs == rhs) == (inst.A ~= 0) then pc = pc + code[pc].sBx end

							pc = pc + 1
						end
					elseif op > 26 then
						--[[LT]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = stack[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = stack[inst.C]
						end

						if (lhs < rhs) == (inst.A ~= 0) then pc = pc + code[pc].sBx end

						pc = pc + 1
					else
						--[[POW]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = stack[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = stack[inst.C]
						end

						stack[inst.A] = lhs ^ rhs
					end
				else
					--[[LOADBOOL]]
					stack[inst.A] = inst.B ~= 0

					if inst.C ~= 0 then pc = pc + 1 end
				end
			elseif op > 28 then
				if op < 33 then
					if op < 30 then
						--[[LE]]
						local lhs, rhs

						if inst.is_KB then
							lhs = inst.const_B
						else
							lhs = stack[inst.B]
						end

						if inst.is_KC then
							rhs = inst.const_C
						else
							rhs = stack[inst.C]
						end

						if (lhs <= rhs) == (inst.A ~= 0) then pc = pc + code[pc].sBx end

						pc = pc + 1
					elseif op > 30 then
						if op < 32 then
							--[[CLOSURE]]
							local sub = subs[inst.Bx + 1] -- offset for 1 based index
							local nups = sub.numupvals
							local uvlist

							if nups ~= 0 then
								uvlist = {}

								for i = 1, nups do
									local pseudo = code[pc + i - 1]

									if pseudo.op == OPCODE_RM[0] then -- @MOVE
										uvlist[i - 1] = open_lua_upvalue(openupvs, pseudo.B, stack)
									elseif pseudo.op == OPCODE_RM[4] then -- @GETUPVAL
										uvlist[i - 1] = upvs[pseudo.B]
									end
								end

								pc = pc + nups
							end

							stack[inst.A] = wrap_lua_func(sub, env, uvlist)
						else
							--[[TESTSET]]
							local A = inst.A
							local B = inst.B

							if (not stack[B]) == (inst.C ~= 0) then
								pc = pc + 1
							else
								stack[A] = stack[B]
							end
						end
					else
						--[[UNM]]
						stack[inst.A] = -stack[inst.B]
					end
				elseif op > 33 then
					if op < 36 then
						if op > 34 then
							--[[VARARG]]
							local A = inst.A
							local size = inst.B

							if size == 0 then
								size = vargs.size
								stktop = A + size - 1
							end

							for i = 1, size do stack[A + i - 1] = vargs.list[i] end
						else
							--[[FORPREP]]
							local A = inst.A
							local init, limit, step

							init = assert(tonumber(stack[A]), '`for` initial value must be a number')
							limit = assert(tonumber(stack[A + 1]), '`for` limit must be a number')
							step = assert(tonumber(stack[A + 2]), '`for` step must be a number')

							stack[A] = init - step
							stack[A + 1] = limit
							stack[A + 2] = step

							pc = pc + inst.sBx
						end
					elseif op > 36 then
						--[[SETLIST]]
						local A = inst.A
						local C = inst.C
						local size = inst.B
						local tab = stack[A]
						local offset

						if size == 0 then size = stktop - A end

						if C == 0 then
							C = inst[pc].value
							pc = pc + 1
						end

						offset = (C - 1) * FIELDS_PER_FLUSH

						for i = 1, size do tab[i + offset] = stack[A + i] end
					else
						--[[NOT]]
						stack[inst.A] = not stack[inst.B]
					end
				else
					--[[TEST]]
					if (not stack[inst.A]) == (inst.C ~= 0) then pc = pc + 1 end
				end
			else
				--[[TFORLOOP]]
				local A = inst.A
				local func = stack[A]
				local state = stack[A + 1]
				local index = stack[A + 2]
				local base = A + 3
				local vals

				-- === Luau compatibility - General iteration begin ===
				-- // ccuser44 added support for generic iteration
				-- (Please don't use general iteration in vanilla Lua code)
				if not index and not state and type(func) == "table" then
					-- Hacky check to see if __metatable is locked
					local canGetMt = pcall(getmetatable, func)
					local isMtLocked = canGetMt and not pcall(setmetatable, func, getmetatable(func)) or not canGetMt
					local metatable = canGetMt and getmetatable(func)

					if not (table.isfrozen and table.isfrozen(func)) and isMtLocked and not metatable then
						warn("[FiOne]: The table has a metatable buts it's hidden, __iter and __call won't work in forloop.")
					end

					if not (type(metatable) == "table" and rawget(metatable, "__call")) then
						func, state, index = (type(metatable) == "table" and rawget(metatable, "__iter") or next), func, nil
						stack[A], stack[A + 1], stack[A + 2] = func, state, index
					end
				end
				-- === Luau compatibility - General iteration end ===

				stack[base + 2] = index
				stack[base + 1] = state
				stack[base] = func

				vals = {func(state, index)}

				for i = 1, inst.C do stack[base + i - 1] = vals[i] end

				if stack[base] ~= nil then
					stack[A + 2] = stack[base]
				else
					pc = pc + 1
				end
			end
		else
			--[[JMP]]
			pc = pc + inst.sBx
		end

		exst.pc = pc
	end
end

function wrap_lua_func(state, env, upvals)
	local st_code = state.code
	local st_subs = state.subs
	local st_lines = state.lines
	local st_source = state.source
	local st_numparams = state.numparams

	local function exec_wrap(...)
		local stack = {}
		local varargs = {}
		local sizevarg = 0
		local sz_args, l_args = wrap_lua_variadic(...)

		local exst
		local ok, err, vals

		for i = 1, st_numparams do stack[i - 1] = l_args[i] end

		if st_numparams < sz_args then
			sizevarg = sz_args - st_numparams
			for i = 1, sizevarg do varargs[i] = l_args[st_numparams + i] end
		end

		exst = {
			varargs = {list = varargs, size = sizevarg},
			code = st_code,
			subs = st_subs,
			lines = st_lines,
			source = st_source,
			env = env,
			upvals = upvals,
			stack = stack,
			pc = 1,
		}

		ok, err, vals = pcall(exec_lua_func, exst, ...)

		if ok then
			return unpack(vals, 1, err)
		else
			on_lua_error(exst, err)
		end

		return -- explicit "return nothing"
	end

	return exec_wrap
end

return function(BCode, Env)
	return wrap_lua_func(stm_lua_bytecode(BCode), Env or {})
end
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX0B6D00EB6C5243ADB065298B4CBC11E1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">@CHL/MapInterface</string>
					<string name="ScriptGuid">{941BD937-6F3E-4F08-90A3-EC9F67A687C5}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	based from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/
]]

local Iterator = require(script.Parent["@CHL/Iterator"])

type __object<I, V> = {
	getSize: (self: __object<I, V>) -> number;
	
	clear: (self: __object<I, V>) -> nil;
	delete: (self: __object<I, V>, i: I) -> boolean?;
	entries: (self: __object<I, V>) -> Iterator.object<I, V>;
	forEach: (self: __object<I, V>, fn: (v: V, i: I) -> any?) -> nil;
	get: (self: __object<I, V>, i: I) -> V?;
	has: (self: __object<I, V>, i: I) -> boolean;
	keys: (self: __object<I, V>) -> Iterator.object<I>;
	set: (self:__object<I, V>, i: I, v: V) -> nil;
	values: (self: __object<I, V>) -> Iterator.object<V>
}

export type object<I, V> = __object<I, V>

return true]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXD125BABE1B154FEE837CC878B435CBE4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">@CHL/DashSingular</string>
					<string name="ScriptGuid">{6FB0ACE7-4131-4ABE-AAD0-CCC27992EE19}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	DashSingular is a warningless version of Dash.
	https://devforum.roblox.com/t/luau-libraries-available-for-use/2692468
	
	! IS UNTESTED
]]
--// TYPES

-- class
type __class<
	ClassName,
	Object,
	ConstructorArgs...
	> = {
	name: ClassName;

	-- creates object, uses constructor upfront
	new: (ConstructorArgs...) -> Object;

	-- init function for class, functionally the same for argument constructor but
	-- finishes set up upon metatable set up
	_init: (self:Object, ConstructorArgs...) -> nil;

	-- checks of value a contains strictly this class by checking its class and all 
	-- classes below.
	isInstance: (a: any) -> boolean;

	-- creates a subclass from class, because of now type checking works, extend is
	-- deparameterized. consider using a type in tangent for type checking.
	extend: (name: string, (...any) -> any) -> any;

	tostring: (self:Object) -> string;
	equals: (self:Object, other: any) -> boolean;

	-- all metamethods.
	__lt: (self:Object, other: Object) -> boolean;
	__le: (self:Object, other: Object) -> boolean;
	__add: (self:Object, other: Object) -> boolean;
	__sub: (self:Object, other: Object) -> boolean;
	__mul: (self:Object, other: Object) -> boolean;
	__div: (self:Object, other: Object) -> boolean;
	__mod: (self:Object, other: Object) -> boolean;
}

export type class<ClassName,Object,ConstructorArgs...> = 
	__class<ClassName,Object,ConstructorArgs...>

export type classReturn = <name, object, args...>(name: string, args...) ->
__class<name, object, args...>

type __object = {
	name: string;
	tostring: (self:__object) -> string;
	equals: (self:__object, other: any) -> boolean;
}
export type object = __object

-- Error
type __Error = {
	name: string;
	message: string;
	tags: Map<string, any>?;
	stack: string;

	joinTags: (self:__Error, Table?) -> __Error;
	throw:(self:__Error, Table?) -> nil;
} & __object
export type Error = __Error

type __ErrorClass = __class<'Error', __Error, (string, string, Table?)>
export type ErrorClass = __ErrorClass

-- Symbol
export type SymbolClass = __class<"Symbol", __object, string>

-- cycles
export type Cycles = {
	-- A set of tables which were visited recursively
	visited: Set<Table>,
	-- A map from table to unique index in visit order
	refs: Map<Table, number>,
	-- The number to use for the next unique table visited
	nextRef: number,
	-- An array of keys which should not be visited
	omit: Array<any>,
}

-- pretty
export type PrettyOptions = {
	-- The maximum depth of ancestors of a table to display (default = 2)
	depth: number?,
	-- An array of keys which should not be visited
	omit: Array<any>?,
	-- Whether to use multiple lines (default = false)
	multiline: boolean?,
	-- Whether to show the length of any array in front of its content
	arrayLength: boolean?,
	-- The maximum length of a line (default = 80)
	maxLineLength: number?,
	-- Whether to drop the quotation marks around strings. By default, this is true for table keys
	noQuotes: boolean?,
	-- The indent string to use (default = "\t")
	indent: string?,
	-- A set of tables which have already been visited and should be referred to by reference
	visited: Set<Table>?,
	-- A cycles object returned from `cycles` to aid reference display
	cycles: Cycles?,
}

-- handlers
type __itHandler<V, I, v> = (V, I) -> v;

-- iterable
type __itFunction<A...> = (...any) -> (A...)
export type itFunction<A...> = __itFunction<A...>

type __iterable<I, V> = Map<I, V> | __itFunction<I, V>
export type iterable<I, V> = __iterable<I, V>

-- main module
type __module = {
	class: classReturn;
	Error: __ErrorClass;
	Symbol: SymbolClass;
	None: __object;

	append: <A>(Array<A>, ...__iterable<any, A>) -> Array<A>;
	assertEqual: (left: any, right: any, msg: string?) -> nil;
	assign: <I, V>(t: Map<I, V>, ...__iterable<I, V>) -> Map<I, V>;
	collect: <I,V, i,v>(t: __iterable<I,V>, handler: (I,V) -> (i,v) ) -> Map<i,v>;
	collectArray: <I,V, v>(t: __iterable<I,V>, handler: (I,V) -> v) -> Array<v>;
	collectSet: <I,V, v>(t: __iterable<I,V>, handler: (I,V) -> v) -> Set<v>;
	--// Current issue: find generic compatible version of compose
	-- compose: <params...,returns...>(...AnyFunction) -> (params...) -> returns...;
	compose: <params...,returns...>(...any) -> (params...) -> returns...;
	
	copy: <I,V>(__iterable<I,V>)->Map<I,V>;
	cycles: (t: Table, depth:number?, initcycles: Cycles?) -> Cycles?;
	endsWith: (input: string, suffix: string) -> boolean;
	filter: <I,V>(t: __iterable<I,V>, filterFunc: (V,I)->any?) -> Array<V>;
	find: <I,V>(t: __iterable<I,V>,findFunc: (V,I)->any?) -> V?;
	findIndex: <V>(t: Array<V>,findFunc: (V,number)->any?) -> number?;
	flat: <A>(t: Array<Array<A>>) -> Array<A>;
	forEach: <I, V>(t: __iterable<I,V>, handler: __itHandler<V, I, any?>) -> nil;
	forEachArgs: <A>(handler: (a: A) -> nil, ...A) -> nil;
	format: (template: string, ...string) -> nil;
	formatValue: (val: any, display: string) -> string;
	freeze: <A>(objectname:string, t: A, throwIfMissing: boolean?) -> A;
	getOrSet: <I,V>(t: Map<I,V>, k: I, handler: (Map<I,V>, I) -> V) -> V;
	groupBy: <I,V, v>(t: Map<I,V>, getKey: string | (V,I) -> v) -> Map<v, Array<V>>;
	identity: <A...>(A...) -> A...;
	includes: <I,V>(t: Map<I,V>, needle: V) -> boolean;
	isCallable: (a: any) -> boolean;
	isLowerCase: (a: string) -> boolean;
	isUpperCase: (a: string) -> boolean;
	iterable: <I,V>(a: Map<I,V>) -> () -> (I,V);
	iterator: <I, V>(a: __iterable<I, V>) -> __itFunction<I, V>;
	join: <I,V>(...Map<I,V>) -> Map<I,V>;
	joinDeep: <I,V>(source: Map<I,V>, delta: Map<I,V>) -> Map<I,V>;
	keyBy: <I,V, i>(t: __iterable<I,V>, getKey: (V,I) -> i) -> Map<i, V>;
	keys: <I>(t: iterable<I, any>) -> Array<I>;
	last: <A>(t: Array<A>, handler: ((A, number) -> true?)?) -> A;
	leftPad: (input: string, length: number, prefix: string?) -> string;
	map: <I, V, v>(t: __iterable<I, V>, handler: __itHandler<V, I, v>) -> Map<I, v>;
	mapFirst: <V, v>(t: Array<V>, handler: (V, number) -> v?) -> v?;
	mapLast: <V, v>(t: Array<V>, handler: (V, number) -> v?) -> v?;
	mapOne: <I, V, v>(t: Map<I, V>, handler: ((V, I) -> v?)?) -> v?;
	noop: () -> nil;
	omit: <I,V>(input: Map<I,V>, keys: Array<V>) -> Map<I,V>;
	pick: <I,V>(input: __iterable<I,V>, handler: (V,I) -> any?) -> Map<I,V>;
	prettyLines: (object: any, prettyOp: PrettyOptions?) -> Array<string>;
	pretty: (object: any, options: PrettyOptions?) -> string;
	reduce: <A,B>(arr: Array<A>, handler: (last: B, current: A, i: number) -> B, init: B) -> B;
	reverse: <A>(t: Array<A>) -> Array<A>;
	rightPad: (input:string, len: number, suffix: string?) -> string;
	shallowEqual: (left: any, right: any) -> boolean;
	slice: <A>(t: Array<A>, left: number, right: number) -> Array<A>;
	some: <I,V>(t: Map<I,V>, handler: (V,I)->any?) -> boolean;
	splitOn: (from: string, patt: string) -> Array<string>;
	startsWith: (from: string, prefix: string) -> boolean;
	trim: (input: string) -> string;
	values: <V>(t: __iterable<any,V>) -> Array<V>;
}

export type Array<Value> = {Value}
export type Map<Key, Value> = {[Key]: Value};
export type Set<Key> = Map<Key, boolean>
export type Table = Map<any, any>
export type AnyFunction = (...any) -> ...any
export type module = __module;

--// MAIN
local DashSingular = {} :: __module
local Objects = script.Parent
local LuaUTypes = require(Objects.LuaUTypes)
local disguise = LuaUTypes.disguise
local same = LuaUTypes.same

local class, 
	format,
	join,
	assertEqual,
	formatValue,
	pretty,
	map,
	iterator,
	None,
	forEach,
	forEachArgs,
	assign,
	cycles,
	keys,
	includes,
	append,
	slice,
	splitOn,
	startsWith
	= disguise()

local concat = table.concat
local insert = table.insert
local sort = table.sort

local __error = {}
__error.__index = __error

function __error.new(name: string, message: string, tags)
	return disguise(setmetatable({
		name = name;
		message = message or 'An error occurred';
		tags = tags or {}
	}, __error)) :: __Error
end

function __error.__tostring(self: __Error): string
	return format("{}: {}\n{}", self.name, format(self.message, self.tags), self.stack)
end

function __error.joinTags(self: __Error, tags: Table?): Error
	return __error.new(self.name, self.message, join(self.tags, tags))
end

function __error:throw(tags: Table?)
	local instance = self:joinTags(tags)
	instance.stack = debug.traceback()
	error(instance)
end

function throwNotImplemented(tags: Table)
	__error.new(
		"NotImplemented", 
		[[The method "{methodName}" is not implemented on the class "{className}"]]
	)
	:throw(tags)
end

export type Constructor = () -> Table

local defaultConstructor = function()return {}end

function class(name: string, constructor: Constructor?)
	constructor = constructor or defaultConstructor
	local Class = {
		name = name
	}
	--[[
		Return a new instance of the class, passing any arguments to the specified constructor.
		@example
			local Car = class("Car", function(speed)
				return {
					speed = speed
				}
			end)
			local car = Car.new(5)
			pretty(car) --> 'Car {speed = 5}'
	]]
	function Class.new(...)
		local instance = disguise(constructor)(...)
		setmetatable(
			instance,
			{
				__index = Class,
				__tostring = Class.toString,
				__eq = Class.equals,
				__lt = Class.__lt,
				__le = Class.__le,
				__add = Class.__add,
				__sub = Class.__sub,
				__mul = Class.__mul,
				__div = Class.__div,
				__mod = Class.__mod
			}
		)
		instance.Class = Class
		instance:_init(...)
		return instance
	end
	--[[
		Run after the instance has been properly initialized, allowing methods on the instance to
		be used.
		@example
			local Vehicle = dash.class("Vehicle", function(wheelCount) return 
				{
					speed = 0,
					wheelCount = wheelCount
				}
			end)
			-- Let's define a static private function to generate a unique id for each vehicle.
			function Vehicle._getNextId()
				Vehicle._nextId = Vehicle._nextId + 1
				return Vehicle._nextId
			end
			Vehicle._nextId = 0
			-- A general purpose init function may call other helper methods
			function Vehicle:_init()
				self._id = self:_generateId()
			end
			-- Assign an id to the new instance
			function Vehicle:_generateId()
				return format("#{}: {} wheels", Vehicle._getNextId(), self.wheelCount)
			end
			-- Return the id if the instance is represented as a string 
			function Vehicle:toString()
				return self._id
			end
			local car = Vehicle.new(4)
			tostring(car) --> "#1: 4 wheels"
	]]
	function Class:_init()
	end

	--[[
		Returns `true` if _value_ is an instance of _Class_ or any sub-class.
		@example
			local Vehicle = dash.class("Vehicle", function(wheelCount) return 
				{
					speed = 0,
					wheelCount = wheelCount
				}
			end)
			local Car = Vehicle:extend("Vehicle", function()
				return Vehicle.constructor(4)
			end)
			local car = Car.new()
			car.isInstance(Car) --> true
			car.isInstance(Vehicle) --> true
			car.isInstance(Bike) --> false
	]]
	function Class.isInstance(value)
		local ok, isInstance = pcall(function()
			local metatable = getmetatable(value)
			while metatable do
				if metatable.__index == Class then
					return true
				end
				metatable = getmetatable(metatable.__index)
			end
			return false
		end)
		return ok and isInstance
	end

	--[[
		Create a subclass of _Class_ with a new _name_ that inherits the metatable of _Class_,
		optionally overriding the _constructor_ and providing additional _decorators_.
		The super-constructor can be accessed with `Class.constructor`.
		Super methods can be accessed using `Class.methodName` and should be called with self.
		@example
			local Vehicle = dash.class("Vehicle", function(wheelCount) return 
				{
					speed = 0,
					wheelCount = wheelCount
				}
			end)
			-- Let's define a static private function to generate a unique id for each vehicle.
			function Vehicle._getNextId()
				Vehicle._nextId = Vehicle._nextId + 1
				return Vehicle._nextId
			end
			Vehicle._nextId = 0
			-- A general purpose init function may call other helper methods
			function Vehicle:_init()
				self.id = self:_generateId()
			end
			-- Assign an id to the new instance
			function Vehicle:_generateId()
				return dash.format("#{}: {} wheels", Vehicle._getNextId(), self.wheelCount)
			end
			-- Let's make a Car class which has a special way to generate ids
			local Car = Vehicle:extend("Vehicle", function()
				return Vehicle.constructor(4)
			end)
			-- Uses the super method to generate a car-specific id
			function Car:_generateId()
				self.id = dash.format("Car {}", Vehicle._generateId(self))
			end
			local car = Car.new()
			car.id --> "Car #1: 4 wheels"
	]]
	function Class:extend(name: string, constructor)
		local SubClass = class(name, constructor or Class.new)
		setmetatable(SubClass, {__index = self})
		return SubClass
	end

	--[[
		Return a string representation of the instance. By default this is the _name_ field (or the
		Class name if this is not defined), but the method can be overridden.
		@example
			local Car = class("Car", function(name)
				return {
					name = name
				}
			end)
			
			local car = Car.new()
			car:toString() --> 'Car'
			tostring(car) --> 'Car'
			print("Hello " .. car) -->> Hello Car
			local bob = Car.new("Bob")
			bob:toString() --> 'Bob'
			tostring(bob) --> 'Bob'
			print("Hello " .. bob) -->> Hello Bob
		@example
			local NamedCar = class("NamedCar", function(name)
				return {
					name = name
				}
			end)
			function NamedCar:toString()
				return "Car called " .. self.name
			end
			local bob = NamedCar.new("Bob")
			bob:toString() --> 'Car called Bob'
			tostring(bob) --> 'Car called Bob'
			print("Hello " .. bob) -->> Hello Car called Bob
	]]
	function Class:toString()
		return self.name
	end

	--[[
		Returns `true` if `self` is considered equal to _other_. This replaces the `==` operator
		on instances of this class, and can be overridden to provide a custom implementation.
	]]
	function Class:equals(other)
		return rawequal(self, other)
	end

	--[[
		Returns `true` if `self` is considered less than  _other_. This replaces the `<` operator
		on instances of this class, and can be overridden to provide a custom implementation.
	]]
	function Class:__lt(other)
		throwNotImplemented({
			methodName = "__lt",
			className = name
		})	
	end

	--[[
		Returns `true` if `self` is considered less than or equal to _other_. This replaces the
		`<=` operator on instances of this class, and can be overridden to provide a custom
		implementation.
	]]
	function Class:__le(other)
		throwNotImplemented({
			methodName = "__le",
			className = name
		})	
	end

	function Class:__add()
		throwNotImplemented({
			methodName = "__add",
			className = name
		})	
	end
	function Class:__sub()
		throwNotImplemented({
			methodName = "__sub",
			className = name
		})	
	end
	function Class:__mul()
		throwNotImplemented({
			methodName = "__mul",
			className = name
		})	
	end
	function Class:__div()
		throwNotImplemented({
			methodName = "__div",
			className = name
		})	
	end
	function Class:__mod()
		throwNotImplemented({
			methodName = "__mod",
			className = name
		})	
	end

	return Class
end

function assertEqual(left: any, right: any, formattedErrorMessage: string?)
	if left == right then return true end;
	__error.new("AssertError", formattedErrorMessage or 
		[[Left {left:?} does not equal right {right:?}]]):throw({
		left = left,
		right = right
	})
end

function iterator<I, V>(input: __iterable<I, V>): AnyFunction
	if typeof(input) == 'function' then
		return input
	elseif typeof(input) == 'table' then
		if #input > 0 then
			return ipairs(disguise(input))
		end

		return pairs(input)
	end

	return disguise()
end


function map<I, V, v>(input: __iterable<I, V>, handler: __itHandler<I, V, v>): Map<I, V>
	assertEqual(typeof(input), "table", [[Attempted to call Dash.map with argument #1 of type {left:?} not {right:?}]])
	assertEqual(typeof(handler), "function", [[Attempted to call Dash.map with argument #2 of type {left:?} not {right:?}]])
	local result = {}
	for key, child in iterator(input) do
		local value = handler(child, key)
		assertEqual(value == nil, false, [[Returned nil from a Dash.map handler]])
		result[key] = value
	end
	return result
end

function indentLines(lines: Array<string>, indent: string)
	return map(lines, function(line: string)return indent .. line end)
end

function forEach<I, V>(input: __iterable<I, V>, handler: __itHandler<V, I, any?>)
	assertEqual(typeof(input), "table", [[Attempted to call Dash.forEach with argument #1 of type {left:?} not {right:?}]])
	assertEqual(typeof(handler), "function", [[Attempted to call Dash.forEach with argument #2 of type {left:?} not {right:?}]])
	for key, value in iterator(input) do handler(value, key)end
end

function forEachArgs<A>(handler: __itHandler<A, number, any?>, ...: A)
	assertEqual(typeof(handler), "function", [[Attempted to call Dash.forEachArgs with argument #1 of type {left:?} not {right:?}]])
	for index = 1, select('#', ...) do handler(select(index, ...), index)end
end

function assign<I, V>(target: Map<I, V>, ...: __iterable<I,V>): Map<I, V>
	assertEqual(typeof(target), "table", [[Attempted to call Dash.assign with argument #1 of type {left:?} not {right:?}]])
	-- Iterate through the varags in order
	forEachArgs(function(input: Table?)
		-- Ignore items which are not defined
		if input == nil or input == None then return end
		-- Iterate through each key of the input and assign to target at the same key
		forEach(input, function(value, key)
			target[key] = if value == None then nil else value
		end)
	end, ...)
	return target
end

local function getDefaultCycles(): Cycles
	return {
		visited = {},
		refs = {},
		nextRef = 1,
		omit = {},
	}
end

function keys<A>(input: __iterable<A, any?>): Array<A>
	assertEqual(typeof(input), "table", [[Attempted to call Dash.keys with argument #1 of type {left:?} not {right:?}]])
	local result = {}
	for key in iterator(input) do insert(result, key)end
	return result
end

function includes<I, V>(input: Map<I, V>, item: V): boolean
	assertEqual(typeof(input), "table", [[Attempted to call Dash.includes with argument #1 of type {left:?} not {right:?}]])
	if item == nil then return false end
	for _, child in pairs(input) do
		if child == item then return true end
	end
	return false
end

function cycles(input: any, depth: number?, initialCycles: any): Cycles?
	if depth == -1 then return initialCycles end
	if typeof(input) ~= "table" then return end
	
	local childCycles = initialCycles or getDefaultCycles()

	if childCycles.visited[input] then
		-- We have already visited the table, so check if it has a reference
		if not childCycles.refs[input] then
			-- If not, create one as it is present at least twice
			childCycles.refs[input] = childCycles.nextRef
			childCycles.nextRef += 1
		end
		
		return
	end
	
	-- We haven't yet visited the table, so recurse
	childCycles.visited[input] = true
	-- Visit in order to preserve reference consistency
	local inputKeys = keys(input)
	sort(inputKeys, function(left, right)
		if typeof(left) == "number" and typeof(right) == "number" then
			return left < right
		else
			return tostring(left) < tostring(right)
		end
	end)
	
	for _, key in ipairs(inputKeys) do
		if includes(childCycles.omit, key) then
			-- Don't visit omitted keys
			continue
		end
		
		local value = input[key]
		
		-- TODO Luau: support type narrowring with "and"
		-- TYPED: cycles(key, depth and depth - 1 or nil, childCycles)
		-- TYPED: cycles(value, depth and depth - 1 or nil, childCycles)
		-- Recurse through both the keys and values of the table
		if depth then
			cycles(key, depth - 1, childCycles)
			cycles(value, depth - 1, childCycles)
		else
			cycles(key, nil, childCycles)
			cycles(value, nil, childCycles)
		end
	end

	return childCycles
end

function append<A>(target: Array<A>, ...: __iterable<any, A>): Array<A>
	assertEqual(typeof(target), "table", [[Attempted to call Dash.append with argument #1 of type {left:?} not {right:?}]])
	forEachArgs(function(list: Table?)
		if list == None or list == nil then return end
		forEach(list, function(value: any)
			insert(target, value)
		end)
	end, ...)
	return target
end

function slice<A>(input: Array<A>, left: number?, right: number?): Array<A>
	assertEqual(typeof(input), "table", [[Attempted to call Dash.slice with argument #1 of type {left:?} not {right:?}]])
	local output = {}

	-- Default values
	local l = left or 1
	local r = right or #input
	assertEqual(typeof(l), "number", [[Attempted to call Dash.slice with argument #2 of type {left:?} not {right:?}]])
	assertEqual(typeof(r), "number", [[Attempted to call Dash.slice with argument #3 of type {left:?} not {right:?}]])

	if l < 0 then l += #input end
	if r and r < 0 then r += #input end
	for i = l, r do insert(output, input[i])end
	
	return output
end

function prettyLines(object: any, options: any): Array<string>
	options = options or {}
	if type(object) == "table" then
		-- A table needs to be serialized recusively
		-- Construct the options for recursive calls for the table values
		local valueOptions = assign({
			visited = {},
			indent = "\t",
			depth = 2
		}, options, {
			-- Depth is reduced until we shouldn't recurse any more
			depth = options.depth and options.depth - 1 or nil,
			cycles = options.cycles or cycles(object, options.depth, {
				visited = {},
				refs = {},
				nextRef = 0,
				depth = options.depth,
				omit = options.omit or {}
			})
		})
		
		-- Indicate there is more information available beneath the maximum depth
		if valueOptions.depth == -1 then return {"..."}end
		
		-- Indicate this table has been printed already, so print a ref number instead of
		-- printing it multiple times
		if valueOptions.visited[object] then 
			return {`&{valueOptions.cycles.refs[object]}`}
		end

		valueOptions.visited[object] = true

		local multiline = valueOptions.multiline
		local comma = multiline and "," or ", "

		-- If the table appears multiple times in the output, mark it with a ref prefix so it can
		-- be identified if it crops up later on
		local ref = valueOptions.cycles.refs[object]
		local refTag = ref and ("<%s>"):format(ref) or ""
		local lines = {refTag .. "{"}

		-- Build the options for the recursive call for the table keys
		local keyOptions = join(valueOptions, {
			noQuotes = true,
			multiline = false
		})

		-- Compact numeric keys into a simpler array style
		local maxConsecutiveIndex = 0
		local first = true
		for index, value in ipairs(object) do
			-- Don't include keys which are omitted
			if valueOptions.omit and includes(valueOptions.omit, index) then continue end
			if first then
				first = false
			else
				lines[#lines] ..= comma
			end
			if valueOptions.multiline then
				local indendedValue = indentLines(prettyLines(value, valueOptions), valueOptions.indent)
				append(lines, indendedValue)
			else
				lines[#lines] ..= pretty(value, valueOptions)
			end
			maxConsecutiveIndex = index
		end
		if #object > 0 and valueOptions.arrayLength then
			lines[1] = ("#%d %s"):format(#object, lines[1])
		end
		-- Ensure keys are printed in order to guarantee consistency
		local objectKeys = keys(object)
		sort(objectKeys, function(left, right)
			if typeof(left) == "number" and typeof(right) == "number" then
				return left < right
			else
				return tostring(left) < tostring(right)
			end
		end)
		for _, key in ipairs(objectKeys) do
			local value = object[key]
			-- We printed a key if it's an index e.g. an integer in the range 1..n.
			if typeof(key) == "number" and 
				key % 1 == 0 and key >= 1 and key <= maxConsecutiveIndex then
				continue
			end
			-- Don't include keys which are omitted
			if valueOptions.omit and includes(valueOptions.omit, key) then
				continue
			end
			if first then
				first = false
			else
				lines[#lines] ..= comma
			end
			if valueOptions.multiline then
				local keyLines = prettyLines(key, keyOptions)
				local indentedKey = indentLines(keyLines, valueOptions.indent)
				local valueLines = prettyLines(value, valueOptions)
				local valueTail = slice(valueLines, 2)
				local indendedValueTail = indentLines(valueTail, valueOptions.indent)
				-- The last line of the key and first line of the value are concatenated together
				indentedKey[#indentedKey] = ("%s = %s"):format(indentedKey[#indentedKey], valueLines[1])
				append(lines, indentedKey, indendedValueTail)
			else
				lines[#lines] = ("%s%s = %s"):format(lines[#lines], pretty(key, keyOptions), pretty(value, valueOptions))
			end
		end
		if valueOptions.multiline then
			if first then
				-- An empty table is just represented as {}
				lines[#lines] ..= "}"
			else
				insert(lines, "}")
			end
		else
			lines[#lines] = ("%s}"):format(lines[#lines])
		end
		return lines
	elseif type(object) == "string" and not options.noQuotes then
		return {('"%s"'):format(object)}
	else
		return {tostring(object)}
	end
end

function pretty(object: any, options: any): string
	return concat(prettyLines(object, options), "\n")
end

function formatValue(value: any, displayString: string): string
	displayString = displayString or ""
	assertEqual(
		typeof(displayString), 
		"string", 
		[[Attempted to call Dash.formatValue with argument #2 of type {left:?} not {right:?}]]
	)
	-- Inline require to prevent infinite require cycle
	local displayTypeStart, displayTypeEnd = displayString:find("[A-Za-z#?]+")
	
	if displayTypeStart then
		local displayType = displayString:sub(displayTypeStart, displayTypeEnd)
		local formatAsString =
			`%{displayString:sub(1, displayTypeStart - 1)}{
			displayString:sub(displayTypeEnd + 1)}s`

		-- Pretty print values
		if displayType == "#?" then
			-- Multiline print a value
			return formatAsString:format(pretty(value, {multiline = true}))
		elseif displayType == "?" then
			-- Inspect a value
			return formatAsString:format(pretty(value))
		end
		return (`%{displayString}`):format(value)
	else
		local displayType = "s"
		if type(value) == "number" then
			-- Correctly display floats or integers
			local _, fraction = math.modf(value)
			displayType = fraction == 0 and "d" or "f"
		end
		return (`%{displayString}{displayType}`):format(tostring(value))
	end
end

function splitOn(input: string, pattern: string): Array<string>
	assertEqual(typeof(input), "string", [[Attempted to call Dash.splitOn with argument #1 of type {left:?} not {right:?}]])
	assertEqual(typeof(pattern), "string", [[Attempted to call Dash.splitOn with argument #2 of type {left:?} not {right:?}]])
	local parts = {}
	local delimiters = {}
	local from = 1
	if not pattern then
		for i = 1, #input do
			insert(parts, input:sub(i, i))
		end
		return parts
	end
	local delimiterStart, delimiterEnd = input:find(pattern, from)
	while delimiterStart do
		insert(delimiters, input:sub(delimiterStart, delimiterEnd))
		insert(parts, input:sub(from, delimiterStart - 1))
		from = delimiterEnd + 1
		delimiterStart, delimiterEnd = input:find(pattern, from)
	end
	insert(parts, input:sub(from))
	return parts, delimiters
end

function startsWith(input: string, prefix: string): boolean
	assertEqual(typeof(input), "string", [[Attempted to call Dash.startsWith with argument #1 of type {left:?} not {right:?}]])
	assertEqual(typeof(prefix), "string", [[Attempted to call Dash.startsWith with argument #2 of type {left:?} not {right:?}]])
	return input:sub(1, prefix:len()) == prefix
end

function format(formatString: string, ...)
	assertEqual(typeof(formatString), "string", [[Attempted to call Dash.format with argument #1 of type {left:?} not {right:?}]])
	local args = {...}
	local argIndex = 1
	local texts, subs = splitOn(formatString, "{[^{}]*}")
	local result = {}
	-- Iterate through possible curly-brace matches, ignoring escaped and substituting valid ones
	for i, text in pairs(texts) do
		local unescaped = text:gsub("{{", "{"):gsub("}}", "}")
		insert(result, unescaped)
		local placeholder = subs[i] and subs[i]:sub(2, -2)
		if placeholder then
			-- Ensure that the curly braces have not been escaped
			local escapeMatch = text:gmatch("{+$")()
			local isEscaped = escapeMatch and #escapeMatch % 2 == 1
			if not isEscaped then
				-- Split the placeholder into left & right parts pivoting on the central ":"
				local placeholderSplit = splitOn(placeholder, ":")
				local isLength = startsWith(placeholderSplit[1], "#")
				local argString = isLength and placeholderSplit[1]:sub(2) or placeholderSplit[1]
				local nextIndex = tonumber(argString)
				local displayString = placeholderSplit[2]
				local arg = "nil"
				if nextIndex then
					-- Return the next argument
					arg = args[nextIndex]
				elseif argString:len() > 0 then
					-- Print a child key of the 1st argument
					local argChild = args[1] and args[1][argString]
					if argChild ~= nil then
						arg = argChild
					end
				else
					arg = args[argIndex]
					argIndex += 1
				end
				if isLength then
					arg = #arg
				end
				-- Format the selected value
				insert(result, formatValue(arg, displayString or ""))
			else
				local unescapedSub = placeholder
				insert(result, unescapedSub)
			end
		end
	end
	return concat(result, "")
end

function join<I, V>(...: Map<I,V>): Map<I, V>return assign({}, ...)end

-- other functions
function collect<I,V, i,v>(input: __iterable<I,V>, handler: (I,V) -> (i,v)): Map<i, v>
	assertEqual(typeof(input), "table", [[Attempted to call Dash.collect with argument #1 of type {left:?} not {right:?}]])
	assertEqual(typeof(handler), "function", [[Attempted to call Dash.collect with argument #2 of type {left:?} not {right:?}]])
	local result = {}
	for key, child in iterator(input) do
		local outputKey, outputValue = handler(key, child)
		if outputKey ~= nil then
			result[outputKey] = outputValue
		end
	end
	return result
end

function collectArray<I,V, v>(input: __iterable<I,V>, handler: (I,V) -> v): Array<v>
	assertEqual(typeof(input), "table", [[Attempted to call Dash.collectArray with argument #1 of type {left:?} not {right:?}]])
	assertEqual(typeof(handler), "function", [[Attempted to call Dash.collectArray with argument #2 of type {left:?} not {right:?}]])
	local result = {}
	for key, child in iterator(input) do
		local outputValue = handler(key, child)
		if outputValue ~= nil then
			insert(result, outputValue)
		end
	end
	return result
end

function collectSet<I,V, v>(input: __iterable<I,V>, handler: ((I,V) -> v)?): Set<v>
	assertEqual(typeof(input), "table", [[Attempted to call Dash.collectSet with argument #1 of type {left:?} not {right:?}]])
	local result = {}
	for key, child in iterator(input) do
		local outputValue
		if handler == nil then
			outputValue = child 
		else
			outputValue = handler(key, child)
		end
		if outputValue ~= nil then
			result[outputValue] = true
		end
	end
	return result
end

function compose<params...,returns...>(...: AnyFunction): ((params...) -> returns...)
	local fns = {...}
	if #fns == 0 then return disguise(LuaUTypes.same) end
	return function(...)
		local result = {fns[1](...)}
		for i = 2, #fns do
			result = {fns[i](unpack(result))}
		end
		return unpack(result)
	end
end

function copy<I,V>(input: __iterable<I,V>): Map<I,V>
	assertEqual(typeof(input), "table", [[Attempted to call Dash.copy with argument #1 of type {left:?} not {right:?}]])
	return join(input)
end

function endsWith(input: string, suffix: string)
	assertEqual(typeof(input), "string", [[Attempted to call Dash.endsWith with argument #1 of type {left:?} not {right:?}]])
	assertEqual(typeof(suffix), "string", [[Attempted to call Dash.endsWith with argument #2 of type {left:?} not {right:?}]])
	return input:sub(-suffix:len()) == suffix
end

function filter<I,V>(input: __iterable<I,V>, handler: (V,I)->any?): Array<V>
	assertEqual(typeof(input), "table", [[Attempted to call Dash.filter with argument #1 of type {left:?} not {right:?}]])
	assertEqual(typeof(handler), "function", [[Attempted to call Dash.filter with argument #2 of type {left:?} not {right:?}]])
	local result = {}
	for index, child in iterator(input) do
		if handler(child, index) then insert(result, child)end
	end
	return result
end

function find<I,V>(input: __iterable<I,V>, handler: (V,I)->any?): V?
	assertEqual(typeof(input), "table", [[Attempted to call Dash.find with argument #1 of type {left:?} not {right:?}]])
	assertEqual(typeof(handler), "function", [[Attempted to call Dash.find with argument #2 of type {left:?} not {right:?}]])
	for key, child in iterator(input) do
		if handler(child, key) then return child end
	end
	
	return nil
end

function findIndex<V>(input: Array<V>, handler: (V, number)->any?): number?
	assertEqual(typeof(input), "table", [[Attempted to call Dash.findIndex with argument #1 of type {left:?} not {right:?}]])
	assertEqual(typeof(handler), "function", [[Attempted to call Dash.findIndex with argument #2 of type {left:?} not {right:?}]])
	for key, child in ipairs(input) do
		if handler(child, key) then
			return key
		end
	end
	
	return nil
end

function flat<A>(input: Array<Array<A>>): Array<A>
	assertEqual(typeof(input), "table", [[Attempted to call Dash.flat with argument #1 of type {left:?} not {right:?}]])
	local result = {}
	forEach(input, function(childArray: Array<A>)append(result, childArray)end)
	return result
end

local ReadonlyKey = __error.new(
	"ReadonlyKey", 
	"Attempted to write to readonly key {key:?} of frozen object {objectName:?}"
)
local MissingKey = __error.new(
	"MissingKey", 
	"Attempted to read missing key {key:?} of frozen object {objectName:?}"
)

-- TYPED: local function freeze<T extends Types.Table>(objectName: string, object: T, throwIfMissing: boolean?): T
function freeze<A>(objectName: string, object: A, throwIfMissing: boolean?): A
	assertEqual(typeof(objectName), "string", [[Attempted to call Dash.freeze with argument #1 of type {left:?} not {right:?}]])
	assertEqual(typeof(object), "table", [[Attempted to call Dash.freeze with argument #2 of type {left:?} not {right:?}]])
	
	local __object = disguise(object)
	-- We create a proxy so that the underlying object is not affected
	local proxy = {}
	setmetatable(
		proxy,
		{
			__index = function(_, key: any)
				local value = __object[key]
				if value == nil and throwIfMissing then
					-- Tried to read a key which isn't present in the underlying object
					MissingKey:throw({
						key = key,
						objectName = objectName
					})
				end
				return value
			end,
			__newindex = function(_, key: any)
				-- Tried to write to any key
				ReadonlyKey:throw({
					key = key,
					objectName = objectName
				})
			end,
			__len = function()return #__object;end,
			__tostring = function()return format("Frozen({})", objectName)end,
			-- TODO Luau: Gated check for if a function has a __call value
			__call = function(_, ...)return __object(...)end
		}
	)
	return disguise(proxy)
end

function getOrSet<I,V>(input: Map<I,V>, key: I, getValue: (Map<I,V>, I) -> V): V
	assertEqual(typeof(input), "table", [[Attempted to call Dash.getOrSet with argument #1 of type {left:?} not {right:?}]])
	assertEqual(key == nil, false, [[Attempted to call Dash.getOrSet with a nil key argument]])
	assertEqual(typeof(getValue), "function", [[Attempted to call Dash.getOrSet with argument #3 of type {left:?} not {right:?}]])
	if input[key] == nil then input[key] = getValue(input, key)end
	return input[key]
end

function groupBy<I,V, v>(input: Map<I,V>, getKey: string | ((V,I) -> v)): Map<v, Array<V>>
	assertEqual(typeof(input), "table", [[Attempted to call Dash.groupBy with argument #1 of type {left:?} not {right:?}]])
	assertEqual(getKey == nil, false, [[Attempted to call Dash.groupBy with a nil getKey argument]])
	local result = {}
	for key, child in pairs(input) do
		local groupKey = if typeof(getKey) == "function" then
			getKey(child, key)
		else
			child[getKey]
		
		if groupKey == nil then continue; end
		
		if result[groupKey] ~= nil then
			insert(result[groupKey], child)
		else
			result[groupKey] = {child}
		end
	end
	return result
end

function isCallable(value: any): boolean
	return type(value) == "function" or
		(type(value) == "table" and getmetatable(value) and getmetatable(value).__call ~= nil) 	
		or false
end

function isLowercase(input: string)
	assertEqual(typeof(input), "string", [[Attempted to call Dash.isLowercase with argument #1 of type {left:?} not {right:?}]])
	assertEqual(#input > 0, true, [[Attempted to call Dash.isLowercase with an empty string]])
	local firstLetter = input:sub(1, 1)
	return firstLetter == firstLetter:lower()
end

function isUppercase(input: string)
	assertEqual(typeof(input), "string", [[Attempted to call Dash.isUppercase with argument #1 of type {left:?} not {right:?}]])
	assertEqual(#input > 0, true, [[Attempted to call Dash.isUppercase with an empty string]])
	local firstLetter = input:sub(1, 1)
	return firstLetter == firstLetter:upper()
end

function iterable<I,V>(input: Map<I,V>): (() -> (I,V))
	local currentIndex = 1
	local inOrderedKeys = true
	local currentKey
	local iterateFn
	
	iterateFn = function()
		if inOrderedKeys then
			local value = input[currentIndex]
			if value == nil then
				inOrderedKeys = false
			else
				local index = currentIndex
				currentIndex += 1
				return index, value
			end
		end
		while true do
			currentKey = next(input, currentKey)
			-- Don't re-visit ordered keys 1..n
			if typeof(currentKey) == "number" and currentKey > 0 and currentKey < currentIndex and currentKey % 1 == 0 then
				continue
			end
			if currentKey == nil then
				return nil
			else
				return currentKey, input[disguise(currentKey)]
			end
		end
	end
	return iterateFn
end

function joinDeep<I,V>(source: Map<I,V>, delta: Map<I,V>): Map<I,V>
	assertEqual(typeof(source), "table", [[Attempted to call Dash.joinDeep with argument #1 of type {left:?} not {right:?}]])
	assertEqual(typeof(delta), "table", [[Attempted to call Dash.joinDeep with argument #2 of type {left:?} not {right:?}]])
	local result = copy(source)
	-- Iterate through each key of the input and assign to target at the same key
	forEach(delta, function(value, key)
		result[key] = if typeof(source[key]) == "table" and typeof(value) == "table" then
				-- Only merge tables
				joinDeep(disguise(source[key]), value)
			elseif value == None then
				-- Remove none values
				nil
			else
				value
	end)
	return result
end

function keyBy<I,V, i>(input: __iterable<I,V>, getKey: ((V,I) -> i)): Map<i, V>
	assertEqual(typeof(input), "table", [[Attempted to call Dash.keyBy with argument #1 of type {left:?} not {right:?}]])
	assertEqual(getKey == nil, false, [[Attempted to call Dash.keyBy with a nil getKey argument]])

	return collect(input, function(key, child)
		local newKey = if typeof(getKey) == "function" then
			getKey(child, key)
		else
			child[getKey]
		
		return newKey, child
	end)
end

function last<A>(input: Array<A>, handler: ((A, number) -> true?)?): A
	assertEqual(typeof(input), "table", [[Attempted to call Dash.last with argument #1 of type {left:?} not {right:?}]])
	for index = #input, 1, -1 do
		local child = input[index]
		
		if not handler or handler(child, index) then
			return child
		end
	end
	
	return disguise()
end

function leftPad(input: string, length: number, prefix: string?): string
	assertEqual(typeof(input), "string", [[Attempted to call Dash.leftPad with argument #1 of type {left:?} not {right:?}]])
	assertEqual(typeof(length), "number", [[Attempted to call Dash.leftPad with argument #2 of type {left:?} not {right:?}]])

	local definedPrefix = prefix or " "
	assertEqual(typeof(definedPrefix), "string", [[Attempted to call Dash.leftPad with argument #3 of type {left:?} not {right:?}]])

	local padLength = length - input:len()
	local remainder = padLength % definedPrefix:len()
	local repetitions = (padLength - remainder) / definedPrefix:len()
	return string.rep(definedPrefix or " ", repetitions) .. definedPrefix:sub(1, remainder) .. input
end

function mapFirst<V, v>(input: Array<V>, handler: __itHandler<V, number, v?>): v?
	assertEqual(typeof(input), "table", [[Attempted to call Dash.mapFirst with argument #1 of type {left:?} not {right:?}]])
	assertEqual(typeof(handler), "function", [[Attempted to call Dash.mapFirst with argument #2 of type {left:?} not {right:?}]])
	for index, child in ipairs(input) do
		local output = handler(child, index)
		if output ~= nil then
			return output
		end
	end
	return disguise()
end

function mapLast<V, v>(input: Array<V>, handler: __itHandler<V, number, v?>): v?
	assertEqual(typeof(input), "table", [[Attempted to call Dash.mapLast with argument #1 of type {left:?} not {right:?}]])
	assertEqual(typeof(handler), "function", [[Attempted to call Dash.mapLast with argument #2 of type {left:?} not {right:?}]])
	for key = #input, 1, -1 do
		local child = input[key]
		local output = handler(child, key)
		if output ~= nil then
			return output
		end
	end
	
	return disguise()
end

function mapOne<I, V, v>(input: Map<I, V>, handler: __itHandler<V, I, v>?): v?
	assertEqual(typeof(input), "table", [[Attempted to call Dash.mapOne with argument #1 of type {left:?} not {right:?}]])
	for key, child in pairs(input) do
		local output
		if handler then
			output = handler(child, key)
		else
			output = child
		end
		if output ~= nil then
			return output
		end
	end
	
	return disguise()
end

function omit<I, V>(input: Map<I,V>, keys: Array<V>): Map<I,V>
	assertEqual(typeof(input), "table", [[Attempted to call Dash.omit with argument #1 of type {left:?} not {right:?}]])
	assertEqual(typeof(keys), "table", [[Attempted to call Dash.omit with argument #2 of type {left:?} not {right:?}]])
	local output = {}
	local keySet = collectSet(keys)
	-- TYPED: forEach(input, function(child: Value, key: Key)
	forEach(input, function(child, key)
		if not keySet[key] then output[key] = input[key]end
	end)
	return output
end

function pick<I,V>(input: iterable<I,V>, handler: __itHandler<V, I, any?>): Map<I,V>
	assertEqual(typeof(input), "table", [[Attempted to call Dash.pick with argument #1 of type {left:?} not {right:?}]])
	assertEqual(typeof(handler), "function", [[Attempted to call Dash.pick with argument #2 of type {left:?} not {right:?}]])
	local result = {}
	for key, child in iterator(input) do
		if handler(child, key) then
			result[key] = child
		end
	end
	return result
end

function reduce<A,B>(input: Array<A>, 
	handler: ((last: B, current: A, i: number) -> B), initial: B): B
	assertEqual(typeof(input), "table", [[Attempted to call Dash.reduce with argument #1 of type {left:?} not {right:?}]])
	assertEqual(typeof(handler), "function", [[Attempted to call Dash.reduce with argument #2 of type {left:?} not {right:?}]])
	local result = initial
	for i = 1, #input do
		result = handler(result, input[i], i)
	end
	return result
end

function reverse<A>(input: Array<A>): Array<A>
	assertEqual(typeof(input), "table", [[Attempted to call Dash.reverse with argument #1 of type {left:?} not {right:?}]])
	local output = {}
	for i = #input, 1, -1 do insert(output, input[i])end
	return output
end

function rightPad(input: string, length: number, suffix: string?): string
	assertEqual(typeof(input), "string", [[Attempted to call Dash.rightPad with argument #1 of type {left:?} not {right:?}]])
	assertEqual(typeof(length), "number", [[Attempted to call Dash.rightPad with argument #2 of type {left:?} not {right:?}]])

	local definedSuffix = suffix or " "
	assertEqual(typeof(definedSuffix), "string", [[Attempted to call Dash.rightPad with argument #3 of type {left:?} not {right:?}]])

	local padLength = length - input:len()
	local remainder = padLength % definedSuffix:len()
	local repetitions = (padLength - remainder) / definedSuffix:len()
	return input .. string.rep(suffix or " ", repetitions) .. definedSuffix:sub(1, remainder)
end

function shallowEqual(left: any, right: any)
	if left == right then
		return true
	end
	if typeof(left) ~= "table" or typeof(right) ~= "table" or #left ~= #right then
		return false
	end
	if left == nil or right == nil then
		return false
	end
	for key, value in pairs(left) do
		if right[key] ~= value then
			return false
		end
	end
	for key, value in pairs(right) do
		if left[key] ~= value then
			return false
		end
	end
	return true
end

function some<I,V>(input: Map<I,V>, handler: __itHandler<V, I, any?>): boolean
	assertEqual(typeof(input), "table", [[Attempted to call Dash.some with argument #1 of type {left:?} not {right:?}]])
	assertEqual(typeof(handler), "function", [[Attempted to call Dash.some with argument #2 of type {left:?} not {right:?}]])
	for key, child in pairs(input) do
		if handler(child, key) then
			return true
		end
	end
	return false
end

function trim(input: string): string
	assertEqual(typeof(input), "string", [[Attempted to call Dash.trim with argument #1 of type {left:?} not {right:?}]])
	return disguise(input:match("^%s*(.-)%s*$"))
end

function values<V>(input: iterable<any,V>): Array<V>
	assertEqual(typeof(input), "table", [[Attempted to call Dash.values with argument #1 of type {left:?} not {right:?}]])
	local result = {}
	for _, value in iterator(input) do
		insert(result, value)
	end
	return result
end

--// Symbol section for NONE
local Symbol = class("Symbol", function(name: string)
	return {
		name = name
	}
end)

function Symbol:toString(): string return ("Symbol(%s)"):format(self.name)end

None = Symbol.new("None")

--// Library
-- methods
DashSingular.append = append
DashSingular.assertEqual = assertEqual
DashSingular.assign = assign
DashSingular.collect = collect
DashSingular.collectArray = collectArray
DashSingular.collectSet = collectSet;
DashSingular.compose = compose;
DashSingular.cycles = cycles
DashSingular.endsWith = endsWith;
DashSingular.filter = filter;
DashSingular.find = find;
DashSingular.findIndex = findIndex;
DashSingular.flat = flat;
DashSingular.freeze = freeze;
DashSingular.getOrSet = getOrSet
DashSingular.groupBy = groupBy;
DashSingular.identity = same
DashSingular.includes = includes
DashSingular.isCallable = isCallable
DashSingular.isLowercase = isLowercase
DashSingular.isUppercase = isUppercase
DashSingular.iterable = iterable
DashSingular.iterator = iterator
DashSingular.join = join
DashSingular.joinDeep = joinDeep
DashSingular.keyBy = keyBy
DashSingular.keys = keys
DashSingular.last = last;
DashSingular.leftPad = leftPad
DashSingular.map = map
DashSingular.mapFirst = mapFirst
DashSingular.mapLast = mapLast
DashSingular.mapOne = mapOne
DashSingular.noop = LuaUTypes.empty
DashSingular.omit = omit
DashSingular.pick = pick
DashSingular.prettyLines = prettyLines
DashSingular.pretty = pretty
DashSingular.reduce = reduce
DashSingular.reverse = reverse
DashSingular.rightPad = rightPad
DashSingular.shallowEqual = shallowEqual
DashSingular.slice = slice
DashSingular.some = some
DashSingular.splitOn = splitOn
DashSingular.startsWith = startsWith
DashSingular.trim = trim
DashSingular.values = values

-- classes
DashSingular.class = class

DashSingular.Error = disguise(__error) :: ErrorClass
DashSingular.Symbol = Symbol

-- objects
DashSingular.None = None

return DashSingular :: __module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXC54A0BDC569342E3B512D4AC43857D77">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">InstanceConstruct</string>
					<string name="ScriptGuid">{741A378E-8F38-4256-9832-7E0D1DBB38E8}</string>
					<ProtectedString name="Source"><![CDATA[--// TYPES
local LuaUTypes = require(script.Parent.LuaUTypes)
local Types = require(script.Types)

type __instance = Types.instance
export type instance = __instance

type __resultStruct = Types.resultStruct
export type resultStruct = __resultStruct

type __postAppliedProperty = Types.postAppliedProperty

type __inputStruct = Types.inputStruct
export type inputStruct = __inputStruct

--// MAIN
local PropertyManager = require(script.PropertyManager)
local disguise = LuaUTypes.disguise
local module = {}

function compileStruct(resultStruct: __resultStruct, struct: __instance)
	--// pre
	local cN = assert(
		struct.className,
		`Attempting to construct nil class, expected: string, got: {
		struct.className}, from: {struct}`
	)
	local structInstance = Instance.new(cN)
	
	--// set id
	if struct.id then
		resultStruct.instances[struct.id] = structInstance
	end
	
	--// set values
	if struct.properties then
		for i, v in next, struct.properties do
			PropertyManager.imprint(resultStruct, structInstance, i, v)
		end
	end
	
	--// set children
	if struct.children then
		for _, v in next, struct.children do
			local i = compileStruct(resultStruct, v)
			
			table.insert(resultStruct.postAppliedProperties, {
				instance = i;
				property = 'Parent';
				value = structInstance;
			} :: __postAppliedProperty)
		end
	end
	
	return structInstance
end

function module.convertToInstance(iStruct: __inputStruct)
	--// parse inputs
	local icVersion: Types.inputCompileVersion = iStruct.inputCompileVersion or 'base'
	
	if icVersion == 'all_modules' then
		for _, v in next, iStruct.root do
			--// classname
			v.className = 'ModuleScript'
			
			--// properties
			local properties = {}
			
			for i, w in next, v do
				properties[i] = w;
			end
			
			v.properties = properties;
		end
	end
	
	local result = {} :: __resultStruct
	result.instances = {}
	result.root = {}
	result.postAppliedProperties = {}
	
	--// compile
	for _, v in next, iStruct.root do
		local instance = compileStruct(result, v)
		
		if not v.properties.Parent then
			table.insert(result.root, instance)
		end
	end
	
	--// set values for post applied
	for _, v in next, result.postAppliedProperties do
		disguise(v.instance)[v.property] = v.value;
	end
	
	return result
end


return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX629F59852D1F4B2FA8D5C9F8E7302247">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Types</string>
						<string name="ScriptGuid">{737511B0-F1CD-4D4F-9DDE-26C07D3DB55D}</string>
						<ProtectedString name="Source"><![CDATA[--// TYPES
type __instance = {
	className: string;
	id: string?;
	children: {__instance}?;
	properties: {[string]: any?}?;
}
export type instance = __instance;

type __postAppliedProperty = {
	instance: Instance;
	property: string;
	value: any;
}
export type postAppliedProperty = __postAppliedProperty

type __resultStruct = {
	instances: {[string]: __instance};
	root: {Instance};
	postAppliedProperties: {__postAppliedProperty};
}
export type resultStruct = __resultStruct

type __inputCompileVersion = 'base' | 'all_modules'
export type inputCompileVersion = __inputCompileVersion

type __inputStruct = {
	root: {__instance};
	inputCompileVersion: __inputCompileVersion?;
}
export type inputStruct = __inputStruct

return true
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF1A32D80BC394C13A6FD3E4853C29307">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PropertyManager</string>
						<string name="ScriptGuid">{976BBF98-476B-4EA5-97AB-657CE97DDCB8}</string>
						<ProtectedString name="Source"><![CDATA[--// TYPES
local Shared = script.Parent.Parent
local Types = require(script.Parent.Types)
local LuaUTypes = require(Shared.LuaUTypes)
local Dash = require(Shared["@CHL/DashSingular"])
local TableUtils = require(Shared["@CHL/TableUtils"])

--[[
type __propertyManager = {
	imprint: (Types.resultStruct, Instance, string, any) -> nil;
}
--]]
type __propertyFunction = (Types.resultStruct, Instance, string, any) -> nil;

type __module = {
	classes: {
		[string]: {
			[string] : {
				default: __propertyFunction?;
				[string]: __propertyFunction;
			}
		}
	};
	
	get: (inst: Instance, property: string, value: any) -> __propertyFunction;
	imprint: (Types.resultStruct, Instance, property: string, value: any) -> nil
}

--// MAIN
local disguise = LuaUTypes.disguise

default = function(_, i, p, v)TableUtils.safeSet(i, p, v)end :: __propertyFunction
instanceProperty = function(rStruct , inst, property, value)
	table.insert(rStruct.postAppliedProperties, {
		instance = inst;
		property = property;
		value = assert(rStruct.instances[value], `Can not find instance: Got {value}`)
	} :: Types.postAppliedProperty)
end :: __propertyFunction

--// API
local module = disguise{} :: __module

--// POPULATION
module.classes = {}

module.classes.Weld = {Part0 = {string = instanceProperty};};

module.classes.ModuleScript = {
	Source = {
		string = function(result, inst, p, v: string)
			if Dash.startsWith(v, 'https://') then
				module.classes.ModuleScript.Source.table(result, inst, p, {
					vType = 'url';
					url = v;
				})
			else
				error(`got unknown v: {v}`)
			end
		end,
		table = function(r, i, p, v)
			if v.vType == 'url' then
				local url = assert(v.url, 'Missing v.url')
				disguise(i)[p] = game:GetService('HttpService'):GetAsync(url)
			else
				error(`invalid vType {v.vType}`)
			end
		end :: __propertyFunction,
	};
	Parent = {
		string = instanceProperty;
	}
}

--// METHODS
function module.get(inst: Instance, property: string, value: any) : __propertyFunction
	local set = TableUtils.deepSoftIndex(module.classes, inst.ClassName, property)
	local vType = typeof(value)

	local result: __propertyFunction = set and (set[vType] or set.default) or default
	
	return result
end

function module.imprint(
	rStruct: Types.resultStruct, 
	inst: Instance,
	property: string,
	value: any)
	
	local f = module.get(inst, property, value)
	f(rStruct, inst, property, value)
end


return module
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX031D8B288E28426183E4D4D84DD189AD">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">@CHL/TableUtils</string>
					<string name="ScriptGuid">{FB860858-00B2-4AA3-953E-6A1756AAEA6C}</string>
					<ProtectedString name="Source"><![CDATA[local module = {}
local LuaUTypes = require(script.Parent.LuaUTypes)
local disguise = LuaUTypes.disguise

function isEmpty(a: {[any]: any}): boolean return next(a) == nil end

function deepSoftIndex<A, B>(t: {[A]: any}, ...: A): B?
	for i = 1, select('#', ...) do
		local index = select(i, ...)
		t = t[index]

		if not t then return end
	end

	return disguise(t);
end

function safeSet(t: any, i: any, v: any): (boolean, string?)
	return pcall(function()
		t[i] = v
	end)
end

function imprint<A>(t: A, t2: {[any]: any}, shouldWarn: boolean?): A
	for i, v in next, t2 do
		local s, e = safeSet(t, i, v)
		if shouldWarn and not s then
			warn(e)
		end
	end

	return t
end

function push<A, B>(t: A, ...: B): A
	for i = 1, select('#', ...) do
		local a = select(i, ...)
		table.insert(disguise(t), a)
	end
	return t
end

function clearNils<A>(t: A): A
	local i = 1
	local b = disguise(t)

	while i > #b do
		if b[i] == nil then
			table.remove(b,i)
			i -= 1
		end
		i += 1
	end

	return t
end

function fill<A>(ground: A, concrete: A): A
	local a, b = disguise(ground, concrete)
	
	for i, v in next, b do
		if a[i] == nil then
			a[i] = v
		end
	end
	
	return ground
end

function defaultify<A>(a: A?, default: A): A
	return not a and default or fill(a, default)
end

function isProperArray(a: {[any]: any}): boolean
	return type(disguise(next(a))) == 'number' and next(a, #a) == nil
end

module.deepSoftIndex = deepSoftIndex
module.safeSet = safeSet
module.imprint = imprint
module.push = push
module.clearNils = clearNils
module.fill = fill
module.defaultify = defaultify
module.isProperArray = isProperArray
module.isEmpty = isEmpty

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX23C89FBB1D64484F9A31BC43AA2A506F">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">@CHL/Iterator</string>
					<string name="ScriptGuid">{9C7760DC-94D7-46C4-9ADE-9B38786DB4AE}</string>
					<ProtectedString name="Source"><![CDATA[--// TYPES
local Class = require(script.Parent.Class)

type __object<A...> = {
	proceed: (self:__object<A...>) -> A...;
	canProceed: (self:__object<A...>) -> boolean;
}
export type object<A...> = __object<A...>

--// MAIN
local module = {}
local disguise = require(script.Parent.LuaUTypes).disguise

module.__index = module

module.__call = function<A...>(self: __object<A...>)
	if self:canProceed() then
		return self:proceed()
	end
end

module.new = function<A...>()
	return disguise(setmetatable({}, module)) :: __object<A...>
end

module.proceed = Class.abstractMethod
module.canProceed = Class.abstractMethod

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX37731EE0D23C4E82A7E2790BF9A5E9A8">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">@CHL/GameReferralMap</string>
					<string name="ScriptGuid">{683BC078-3C40-4FA2-B14E-DECDE16D0ED2}</string>
					<ProtectedString name="Source"><![CDATA[--// TYPES
local Objects = script.Parent
local Iterator = require(Objects["@CHL/Iterator"])
local MapInterface = require(Objects["@CHL/MapInterface"])
local Class = require(Objects.Class)

type __entryIterator<A> = {
	i: number;
	t: {ObjectValue};
} & Class.subclass<Iterator.object<string, A>>

type __kIterator = {
	it: __entryIterator<any>;
} & Class.subclass<Iterator.object<string>>

type __vIterator<A> = {
	it: __entryIterator<A>;
} & Class.subclass<Iterator.object<string>>


type __object<A> = {
	folder: Folder;
	
	getPointer: (self: __object<A>, i: string) -> ObjectValue?;
	getPointers: (self: __object<A>) -> {ObjectValue};
} & MapInterface.object<string, A>
export type object<A> = __object<A>

--// MAIN

-- iterators
local disguise = require(Objects.LuaUTypes).disguise

local EntryIterator = {}

EntryIterator.__index = EntryIterator

function EntryIterator.new<A>(ovs: {ObjectValue})
	local self: __entryIterator<A> = disguise(Class.inherit(Iterator.new(), EntryIterator))
	
	self.t = ovs
	self.i = 1
	
	return self
end

EntryIterator.canProceed = function<A>(self: __entryIterator<A>)return self.i <= #self.t end

EntryIterator.proceed = function<A>(self: __entryIterator<A>)
	local i, v = self.i, self.t[self.i]
	self.i += 1
	return i, v
end

local KIterator = {}

KIterator.__index = KIterator

function KIterator.new(ovs: {ObjectValue})
	local self: __kIterator = disguise(Class.inherit(Iterator.new(), KIterator))
	self.it = EntryIterator.new(ovs);
	return self
end

KIterator.canProceed = function(self: __kIterator)return self.it:canProceed()end
KIterator.proceed = function(self: __kIterator)local i = self.it:proceed()return i end

local VIterator = {}

VIterator.__index = VIterator

function VIterator.new<A>(ovs: {ObjectValue})
	local self: __vIterator<A> = disguise(Class.inherit(Iterator.new(), VIterator))
	self.it = EntryIterator.new(ovs);
	return self
end

VIterator.canProceed = KIterator.canProceed
VIterator.proceed=function<A>(self:__vIterator<A>)local _,v=self.it:proceed()return v end

--// module
local module = {}
local Debris = game:GetService('Debris')
local Dash = require(Objects["@CHL/DashSingular"])

local compose = Dash.compose

module.__index = module

function module.new<A>(folder: Folder)
	local self: __object<A> = disguise(setmetatable({}, module))
	
	self.folder = folder
	
	return self
end

module.clear = function<A>(self: __object<A>)self.folder:ClearAllChildren()end
module.has =function<A>(self:__object<A>,i:string)return not not self:getPointer(i)end
module.getPointers = function<A>(self: __object<A>)return self.folder:GetChildren()end
module.getSize = function<A>(self: __object<A>)return #self:getPointers()end
module.entries = compose(module.getPointers, EntryIterator.new)
module.keys = compose(module.getPointers, KIterator.new)
module.values = compose(module.getPointers,VIterator.new)

module.getPointer = function<A>(self: __object<A>, i: string)
	local o = self.folder:FindFirstChild(i)
	return o and o:IsA('ObjectValue') and o or nil;
end

module.get = function<A>(self: __object<A>, i: string)
	local o = self:getPointer(i)
	return o and o.Value
end

module.delete = function<A>(self:__object<A>, i: string)
	local p = self:getPointer(i)
	if p then
		Debris:AddItem(p, 0)
		return true
	end
	
	return false
end

module.set = function<A>(self: __object<A>, i: string, v: A)
	local o = self:getPointer(i)
	
	if not o then
		local ov = Instance.new('ObjectValue')
		ov.Name = i;
		ov.Parent = self.folder
		o = ov
	end
	
	o.Value = v;
end

module.forEach = function<A>(self:__object<A>, fn: (v: A, i: string) -> any?)
	Dash.forEach(self:entries(), fn)
end



return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXEED0D418F10F455BA3CB9CED5120BB32">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">StringifyCompiler</string>
					<string name="ScriptGuid">{66FDC042-D517-4155-A355-00F4C8AE5B85}</string>
					<ProtectedString name="Source"><![CDATA[--// TYPES
local Objects = script.Parent
local StringUtils = require(Objects["@CHL/StringUtils"])
local Dash = require(Objects["@CHL/DashSingular"])

type __object = {
	depth: number;
	tableOptions: __options;
	accessed: Dash.Set<Dash.Table>;
	
	parseToLines: (self: __object, v: any, __options?) -> {string};
	parse: (self: __object, v: any, __options) -> string;
	clearAccessed: (self: __object) -> nil;
	reset: (self: __object) -> nil;
}
export type object = __object

type __options = {
	maxDepth: number?;
	indentUnit: string | '\t';
	stringArgs: StringUtils.luaSArgs?;
}
export type options = __options

--// MAIN
local module = {}
local LuaUTypes = require(Objects.LuaUTypes)
local disguise = LuaUTypes.disguise
local TableUtils = require(Objects["@CHL/TableUtils"])
local push = TableUtils.push
local defaultify = TableUtils.defaultify

module.__index = module

function assertType<A>(value: any | A, __type: string, msg: string?): A
	Dash.assertEqual(typeof(value), __type, msg or `Attempting to pass value, {
		value}, of type {typeof(value)}, and not {__type}`)
	return value
end

module.defaultOptions = {
	maxDepth = 10;
	indentUnit = '\t';
	stringArgs = {
		token = '\'';
		multilineType = 'single';
	}
} :: __options

function module.new(options: __options?): __object
	local self: __object = disguise(setmetatable({}, module))
	
	self.tableOptions = defaultify(options, module.defaultOptions)
	self.accessed = {}
	self.depth = 1
	
	return self
end

module.parseToLines = function(self: __object, v: any, op: __options): {string}
	-- pre
	op = TableUtils.defaultify(op, self.tableOptions)
	
	-- main
	if typeof(v) == 'table' then
		-- case of deep
		if self.depth > op.maxDepth then
			return {'* Max depth reached *'}
		end
		
		-- case of accessed
		if self.accessed[v] then return {'* Cyclic referencing reached *'}end
		
		-- case of metatable
		local meta = getmetatable(v) :: LuaUTypes.metatable<typeof(v)>?
		
		if meta and meta.__tostring then return tostring(v):split('\n') end
		
		-- case of empty
		if TableUtils.isEmpty(v) then return {'{}'}end
		
		-- other cases
		local result = {'{'}
		local isProperArray = TableUtils.isProperArray(v)

		self.accessed[v] = true
		
		for i: string, w: any in next, v do
			-- index
			if not isProperArray then
				i = `{StringUtils.sugarfy(i, op.stringArgs)} = `
			else
				i = ''
			end
			
			-- value
			self.depth += 1
			
			local wLines = self:parseToLines(w, op)
			
			self.depth -= 1
			
			wLines[1] = `{op.indentUnit}{i}{wLines[1]}`
			
			for i = 2, #wLines do
				wLines[i] = op.indentUnit .. wLines[i]
			end
			
			wLines[#wLines] = Dash.last(wLines) .. (isProperArray and ',' or ';')
			
			Dash.append(result, wLines)
		end
		
		return push(result, '}')
	elseif typeof(v) == 'string' then
		return {StringUtils.luaStringify(v, op.stringArgs)}
	end
	return {tostring(v)}
end

module.parse = function(self: __object, v: any, override): string
	return table.concat(self:parseToLines(v, override), '\n')
end

module.clearAccessed = function(self:__object)table.clear(self.accessed)end

module.reset = function(self: __object) self:clearAccessed()self.depth = 1 end


return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX026572F87E414D7691EEA3F75C5708C9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">@CHL/StringUtils</string>
					<string name="ScriptGuid">{5B5465F6-9C37-49E0-BE3D-917CFC9B4B66}</string>
					<ProtectedString name="Source"><![CDATA[--// TYPES
type __multilineType = 'single' | 'multiline'
export type multilineType = __multilineType

type __singleLineTokens = '"' | "'"
export type singleLineTokens = __singleLineTokens

type __luaSArgs = {
	multilineType: __multilineType;
	token: __singleLineTokens?;
	equalSigns: number?;
	prefix: string?;
	suffix: string?;
}
export type luaSArgs = __luaSArgs

--// MAIN
local module = {}
local Objects = script.Parent
local disguise = require(Objects.LuaUTypes).disguise

insert = table.insert

function isSugarIndex(i: string)return not not i:match('^[%a_][%w_]*$')end

function compareStrings(strA: string, strB: string): boolean
	-- pre
	assert(
		type(strA) == 'string' and 
			type(strB) == 'string'
	)

	-- main
	local result = false
	local lStr = #strA > #strB and strA or strB

	for i = 1, #lStr do
		local cA = strA:sub(i, i)
		local cB = strB:sub(i, i)
		local vA = cA == '' and -1 or cA:byte()
		local vB = cB == '' and -1 or cB:byte()

		if vA ~= vB then
			result = vA < vB
			break
		end
	end

	return result
end

function luaStringTokenize(str: string, args: __luaSArgs): {string}
	local result = str:split''
	insert(result, 1, args.prefix)
	
	local i = 2
	
	while i <= #result do
		local v = result[i]

		if args.multilineType == 'single' then
			if v == args.suffix then
				result[i] = `\\{v}`
			elseif v == '\n' then
				result[i] = '\\n'
			elseif v == '\\' then
				result[i] = '\\\\'
			end
		elseif v == ']' then
			local j = i
			repeat
				i += 1
			until result[i] ~= '='
			
			if i - j - 1 == args.equalSigns then
				result[i] = '\\]'
			end
		end
		
		i += 1
	end
	
	insert(result, args.suffix)
	return result
end

function luaStringify(str: string, args: __luaSArgs?)
	-- pre
	local a = disguise(args or {})::__luaSArgs
	a.multilineType = a.multilineType or 'single'
	a.equalSigns = a.equalSigns or 0
	a.token = a.token or '\''
	
	if a.multilineType == 'single' then
		a.prefix = a.token
		a.suffix = a.token
	else
		local s = ('='):rep(a.equalSigns)
		a.prefix = `[{s}[`
		a.suffix = `]{s}]`
	end
	
	-- main
	return table.concat(luaStringTokenize(str, a))
end

function sugarfy(i: string, args: __luaSArgs?)
	if isSugarIndex(i) then return i;end
	if typeof(i) == 'string' then
		i = luaStringify(i, args)
	end
	return `[{i}]`
end

module.compareStrings = compareStrings
module.luaStringify = luaStringify
module.luaStringTokenize = luaStringTokenize
module.isSugarIndex = isSugarIndex
module.sugarfy = sugarfy

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX1924CF4246394AECB138BDDFE7DFBE39">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PMStringifyCompiler</string>
					<string name="ScriptGuid">{458E3BAD-29AA-40EE-A15E-E4202E6EC405}</string>
					<ProtectedString name="Source"><![CDATA[--// TYPES
local Objects = script.Parent
local Class = require(Objects.Class)
local SC = require(Objects.StringifyCompiler)
local Dash = require(Objects["@CHL/DashSingular"])

type __object = {
	parseLibraryLines: (self: __object, lib: Dash.Array<Dash.Table>) -> {string};
	parseLibrary: (self: __object, lib: Dash.Array<Dash.Table>) -> string;
} & Class.subclass<SC.object>
export type object = __object

--// MAIN
local module = {}
local disguise = require(Objects.LuaUTypes).disguise

module.__index = module

module.indexPrecedence =  Dash.collect({
	'name',
	'targetRepository',
	'dependencies',
	'packageType',
	'url',
	'asset_id',
	'params'
}, function(a0: number, a1: string) return a1, a0 end)

function module.new(op: SC.options?): __object
	local self: __object = disguise(Class.inherit(SC.new(op), module))
	
	return self
end

module.sort2ndLevel = function(a: string, b: string)
	local aK = a:match('^\t\t([%a_][%w_]*)')
	local bK = b:match('^\t\t([%a_][%w_]*)')

	local aI = assert(
		module.indexPrecedence[aK], 
		`(left) does not exist in {module.indexPrecedence} from |{a}|`
	)
	local bI = assert(
		module.indexPrecedence[bK], 
		`(right) does not exist in {module.indexPrecedence} from |{b}|`
	)

	return aI < bI
end

module.parseLibraryLines = function(self: __object, lib)
	local lines = self:parseToLines(lib)
	
	local list = {}
	local i = 1
	local isInSort = false
	
	while lines[i] do
		local v = lines[i]
		
		-- print(`|{i}|{isInSort}|{v}`)
		
		if v == '\t},' then
			isInSort = false
			
			-- sort
			table.sort(list, module.sort2ndLevel)
			
			-- print(`|#L|{#list}`)
			
			while #list > 0 do
				-- print(`|#|{i}`)
				table.insert(lines, i, table.remove(list, 1))
				i += 1
			end
			
		elseif v == '\t{' then isInSort = true
		elseif isInSort then
			local hasFormat = v:match('^\t\t[%a_][%w_]* = .+')
			
			-- print(`|hF|{not not hasFormat}|{v}`)
			
			table.remove(lines, i)
			
			i -= 1
			
			if hasFormat then
				table.insert(list, v)
			else
				list[#list] ..= `\n{v}`
			end
		end
		
		i += 1
	end
	
	return lines
end

module.parseLibrary = function(self: __object, lib)
	return `return {table.concat(self:parseLibraryLines(lib), '\n')}`
end


return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX6D4C96361B2B4BF2B398F87CBB6D2E25">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">@CHL/Switch</string>
					<string name="ScriptGuid">{8F42DB1C-2F15-4D59-B893-60986444C609}</string>
					<ProtectedString name="Source"><![CDATA[--// TYPES
local Objects = script.Parent
local EventPackage = require(Objects.EventPackage)

type __object = {
	isOn: boolean;
	flick: (self:__object, toBool: boolean?) -> nil;
	flicked: EventPackage.event<boolean>;
	__flicked:  EventPackage.package<boolean>
}
export type object = __object

--// MAIN
local module = {}
local disguise = require(Objects.LuaUTypes).disguise
module.__index = module

function module.new()
	local self: __object = disguise(setmetatable({}, module))
	
	self.isOn = false;
	self.__flicked = EventPackage.new()
	self.flicked = self.__flicked.event
	
	return self
end

module.flick = function(self: __object, b: boolean)
	if b == nil then
		b = not self.isOn
	end
	
	if self.isOn ~= b then
		self.isOn = b;
		self.__flicked:fire(b)
	end
end

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXE96BEBB05FB84B1BA0C70343E826E704">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">@CHL/SelectionCollection</string>
					<string name="ScriptGuid">{6C818063-5DB5-46D6-A279-6621D904B35A}</string>
					<ProtectedString name="Source"><![CDATA[--// TYPES
local Objects = script.Parent
local Switch = require(Objects["@CHL/Switch"])
local Dash = require(Objects["@CHL/DashSingular"])

type __object<A> = {
	switchCollection: Dash.Map<A,Switch.object>;
	
	addSwitch: (self: __object<A>, i: A, v: Switch.object) -> nil;
	getSwitched: (self: __object<A>) -> Dash.Array<A>;
	clearSwitches: (self:__object<A>) -> nil;
	turnAllButOneOff: (self: __object<A>, one: Switch.object) -> nil;
}
export type object<A> = __object<A>

--// MAIN
local module = {}
local disguise = require(Objects.LuaUTypes).disguise
local compose = Dash.compose

module.__index = module

function module.new<A>(): __object<A>
	local self: __object<A> = disguise(setmetatable({}, module))
	
	self.switchCollection = {}
	
	return self
end

module.addSwitch = function<A>(self: __object<A>, i: A, v: Switch.object)
	self.switchCollection[i] = v
end

function __getSwitched<A>(i: A, v: Switch.object)return v.isOn and i or nil;end

module.getSwitched = compose(
	function<A>(self: __object<A>)return self.switchCollection, __getSwitched end,
	Dash.collectArray
)

module.clearSwitches = compose(
	function<A>(self:__object<A>)return self.switchCollection end,
	table.clear
)

module.turnAllButOneOff = function<A>(self: __object<A>, i: A)
	for j, v in next, self.switchCollection do
		v:flick(j == i)
	end
end


return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXAF8C41F5238B4CB19BDA959F908342E1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">@CHL/GitHubApiInstanceBuilder</string>
					<string name="ScriptGuid">{F7CC95EB-040E-410A-8734-A56E2561716D}</string>
					<ProtectedString name="Source"><![CDATA[local Objects = script.Parent
local UrlStruct = require(Objects["@CHL/UrlStruct"])
local Dash = require(Objects["@CHL/DashSingular"])
local TableUtils = require(Objects["@CHL/TableUtils"])

export type v1_base = {
	name: string;
	path: string;
	download_url: string?;
	type: "dir" | 'file'
}

local module = {}

HttpService = game:GetService('HttpService')

-- v1
v1 = {}

function v1.build(init: {v1_base}, prefix: string): Folder?
	local result = Instance.new('Folder')
	local success = true
	local queue = table.create(#init * 2)
	
	for i,v in init do
		queue[i * 2 - 1] = result
		queue[i * 2] = v
	end
	
	while #queue > 0 do
		local parent = table.remove(queue, 1)
		local value: v1_base? = table.remove(queue, 1)
		
		if not value then break;end
		
		local i: Instance
		
		if value.type == 'file' then
			local source = nil
			success, source = pcall(function()
				local url = assert(
					value.download_url, 
					'missing download_url from: ' .. value.name
				)
				return HttpService:GetAsync(url)
			end)
			
			if not success then warn(source)end
			
			local _i = Instance.new('ModuleScript')
			i = _i
			_i.Source = source
			_i.Name = value.name:sub(1, -5)
		elseif value.type == 'dir' then
			local _i = Instance.new('Folder')
			i = _i
			_i.Name = value.name
			
			local list = nil
			success, list = pcall(function()
				return HttpService:JSONDecode(
					HttpService:GetAsync(`{prefix}{value.path}`)
				)
			end)
			
			if not success then 
				warn(list)
				
			else
				for _, v in list do
					table.insert(queue, _i)
					table.insert(queue, v)
				end
			end
		else
			error(`Invalid value type: {value.type}`)
		end

		if not success then 
			result:Destroy()
			return
		end
		
		i.Parent = parent
	end
	
	return result
end

v1.from = {}

function v1.from.url(s: string)
	local u_struct = UrlStruct.parse(s)
	local success, base = pcall(function()
		return HttpService:JSONDecode(HttpService:GetAsync(s))
	end)
	
	assert(success, `Error occured: url={s}\nreason={base}`)
	
	for i = 5, #u_struct.path_split do
		u_struct.path_split[i] = nil
	end
	
	u_struct.path = table.concat(u_struct.path_split, '/')
	
	return v1.build(base, `{UrlStruct.toString(u_struct)}/`)
end

module.v1 = v1

-- v2
-- subject to change
export type v2_instance = {
	path: string;
	type: 'blob' | 'tree'
}

export type v2_tree = {
	tree: {v2_instance}
}
v2 = {}

function v2.check_repo_set(s: string)
	assert(s:find('/'), 'Reposet needs {owner}/{repo}')
end

function v2.get_raw_url(repo_set: string, suffix: string)
	v2.check_repo_set(repo_set)
	return `https://raw.githubusercontent.com/{repo_set}/refs/heads/master/{suffix}`
end

function v2.build(tree: v2_tree, repo_set: string, suffix: string): Folder
	local result = Instance.new('Folder')
	
	for _, v in tree.tree do
		local i = nil
		local name_split = v.path:split('/')
		local last = table.remove(name_split)
		
		local parent = TableUtils.deepSoftIndex(result, unpack(name_split))
		
		if v.type == 'tree' then
			i = Instance.new('Folder')
		elseif v.type == 'blob' then
			i = Instance.new('ModuleScript')
			local suc, src = pcall(function(...)
				return HttpService:GetAsync(v2.get_raw_url(repo_set, `{suffix}/{v.path}`))
			end)
			if not suc then
				result:Destroy()
				error('Got error:' .. src)
			end
			i.Source = src
			last = last:sub(1,-5)
		else
			error(`bad type: got: {v.type}`)
		end
		
		i.Name = last
		i.Parent = parent
	end
	
	return result
end

v2.from = {}

function v2.from.sha_hash(h: string, repo_set: string, suffix: string): Folder
	local u = `https://api.github.com/repos/{repo_set}/git/trees/{h}?recursive=true`
	local json = HttpService:JSONDecode(HttpService:GetAsync(u))
	
	return v2.build(json, repo_set, suffix)
end

module.v2 = v2

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX4AC33906C41842C78B44C9FDA4F0CAEC">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">@CHL/SoundFolder</string>
					<string name="ScriptGuid">{9D752AF3-F3AB-41C7-BA2B-F3D2F0CA3665}</string>
					<ProtectedString name="Source"><![CDATA[--// TYPES
type __object = {
	folder: Folder;
	getSound: (self: __object, name: string) -> Sound;
}
export type object = __object

--// MAIN
local module = {}
local Objects = script.Parent
local LuaUTypes = require(Objects.LuaUTypes)

disguise = LuaUTypes.disguise

module.__index = module

function module.new(folder: Folder): __object
	local self: __object = disguise(setmetatable({}, module))
	
	self.folder = folder
	
	return self
end

module.getSound = function(self: __object, name: string)
	local s = self.folder:FindFirstChild(name)
	
	return assert(s, `Missing a sound: {name}`)
end

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX2B17CC638EFC4842AD43E76D0A2FA956">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">@CHL/SourceMapBuilder</string>
					<string name="ScriptGuid">{1EB665D4-469C-43D7-B38D-C9DBD23D0E7A}</string>
					<ProtectedString name="Source"><![CDATA[local Objects = script.Parent
local UrlStruct = require(Objects["@CHL/UrlStruct"])

export type filePaths = {string}
export type instance = {
	name: string;
	className: string;
	filePaths: filePaths?;
	children: {instance}?
}

HttpService = game:GetService('HttpService')
disguise = require(Objects.LuaUTypes).disguise


local module = {}

function getInstance<A>(t: instance, prefix: string): A
	local root
	local queue = {false, t}
	
	while #queue > 0 do
		local parent = table.remove(queue, 1)
		local c = table.remove(queue, 1)
		
		local i: Instance = Instance.new(c.className)
		local _i = disguise(i)
		i.Name = c.name
		
		if not root then root = i end
		if parent then i.Parent = parent end
		
		
		if c.filePaths then
			local url = prefix .. c.filePaths[1]:gsub('\\','/')
			if not pcall(function(...)
				_i.Source = HttpService:GetAsync(url)
				end) then
				error("Failed to fetch:" .. url)
			end
		end
		
		if c.children then
			for _, v in c.children do
				table.insert(queue, i)
				table.insert(queue, v)
			end
		end
	end
	
	return root
end

function fromUrl(u: string)
	local ok, content = pcall(function(...)
		return HttpService:JSONDecode(HttpService:GetAsync(u))
	end) 
	
	assert(ok, `unable to build: \nurl: {u}\nerror: {content}\n`)
	
	local u_struct = UrlStruct.parse(u)
	u_struct.path_split[#u_struct.path_split] = nil
	u_struct.path = table.concat(u_struct.path_split,'/')
	
	local prefix = UrlStruct.toString(u_struct)
	
	return getInstance(content, prefix .. '/')
end

module.getInstance = getInstance
module.from = {}
module.from.url = fromUrl

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXCBAC178CFC2348A6A907D33A3808A5BF">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Object</string>
					<string name="ScriptGuid">{1E42A2CC-952E-4BE3-8EAE-D8DE1E59B4F9}</string>
					<ProtectedString name="Source"><![CDATA[-- TYPES
local Objects = script.Parent
local Class = require(Objects.Class)
local Destructable = require(Objects["@CHL/Destructable"])

export type object = {-- typeof(setmetatable({}, module))
	className: string;
	__event_names: {string};
	
	getAncestry: (self: object) -> {string};
	__inherit: <A>(self: object, Class: any) -> A;
	__constructEvent: (self: object, ...string) -> ();
	isA: (self: object, className: string) -> boolean;
	isClass: (self: object, C: any) -> boolean;
	hasClass: (self: object, C: any) -> boolean;
	add: <A, B>(self: object, A) -> B;
	sub: <A, B>(self: object, A) -> B;
	mul: <A, B>(self: object, A) -> B;
	div: <A, B>(self: object, A) -> B;
	mod: <A, B>(self: object, A) -> B;
	pow: <A, B>(self: object, A) -> B;
	idiv: <A, B>(self: object, A) -> B;
	eq: <A>(self: object, A) -> boolean;
	lt: <A>(self: object, A) -> boolean;
	le: <A>(self: object, A) -> boolean;
	concat: <A, B>(self: object, A) -> B;
	len: (self: object) -> number;
	call: <A..., B...>(self: object, A...) -> B...;
	toString: <A...>(self: object, A...) -> string;
} & Destructable.object

export type object_inheritance = Class.subclass<object>

type method<self, P..., R...> = (self: self, P...) -> (R...)
type binaryMethod = method<(any), (any)>
type relationalMethod = method<(any), (boolean)>

-- MAIN
local module = {}

local LuaUTypes = require(Objects.LuaUTypes)
local EventPackage = require(Objects.EventPackage)

disguise = LuaUTypes.disguise
unimplemented = disguise(Class.unimplemented)
insert = table.insert
from = {}

function proxyCall(s: string)
	return function(self: object, ...)
		return disguise(self)[s](self, ...)
	end
end

function module.new(): object return from.rawStruct{}end

function from.rawStruct(t): object
	local self: object = disguise(setmetatable(t, module))
	disguise(self).__supers = {}
	self.__event_names = {}
	return self
end

function from.simple_object(o): object
	local C = getmetatable(o)
	rawset(o, '__supers', {})
	setmetatable(o, module)
	return (o::object):__inherit(C)
end

function from.class<A>(CLASS): A
	return module.new():__inherit(CLASS)
end

function module.__constructEvent(self: object, ...: string): ()
	local __s = disguise(self)
	for i = 1, select('#', ...) do
		local s = select(i, ...)
		local t = `__{s}`
		__s[t] = EventPackage.new()
		__s[s] = __s[t].event
		insert(self.__event_names, s)
	end
end

function module.isA(self: object, className: string)
	local supers = disguise(self).__supers
	
	for _, v in next, supers do
		if v.className == className then
			return true
		end
	end
	
	return false
end

function module.getAncestry(self: object)
	local result = {}
	local supers = disguise(self).__supers
	
	if supers then
		for i = 1, #supers do
			local v = supers[i]
			
			if typeof(v) == 'table' then
				insert(result, v.className)
			else
				insert(result, '!Unlabeled')
			end
		end
	else
		insert(result, self.className)
	end
	
	
	return result
end

function module.destroy(self: object)
	if self.isDestroyed then return end
	
	self.isDestroyed = true
	
	for _, v in next, self.__event_names do
		disguise(self)[`__{v}`]:destroy()
		disguise(self)[`__{v}`] = nil
	end
	
	disguise(self).__super = nil
end

function module.eq(a,e)
	if a.__is_proxy then
		a = a.__object
	end
	return rawequal(a,e)
end

module.from = from
module.className = 'Object'
module.__index = module
module.isClass = Class.isClass
module.hasClass = Class.hasClass
module.__inherit = Class.inherit

module.add =      unimplemented
module.sub =      unimplemented
module.mul =      unimplemented
module.div =      unimplemented
module.mod =      unimplemented
module.pow =      unimplemented
module.idiv =     unimplemented
module.lt =       unimplemented
module.le =       unimplemented
module.concat =   unimplemented
module.len =      unimplemented
module.call =     unimplemented
module.toString = unimplemented

module.__add =    proxyCall'add'
module.__sub =    proxyCall'sub'
module.__mul =    proxyCall'mul'
module.__div =    proxyCall'div'
module.__mod =    proxyCall'mod'
module.__pow =    proxyCall'pow'
module.__idiv =   proxyCall'idiv'
module.__eq =     proxyCall'eq'
module.__lt =     proxyCall'lt'
module.__le =     proxyCall'le'
module.__concat = proxyCall'concat'
module.__len =    proxyCall'len'
module.__call =   proxyCall'call'

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX533368D7966D4A4B904AE2E1B72CB783">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">EventPackage</string>
					<string name="ScriptGuid">{29DBEBDD-B777-406D-BB0A-0488E40E60BB}</string>
					<ProtectedString name="Source"><![CDATA[local Objects = script.Parent
local Destructable = require(Objects["@CHL/Destructable"])

-- CLASS
--###################################################################################
--###################################################################################
--###################################################################################

-- connection
type structFunc<a...> = (a...) -> ();

export type eventSubjectTypes = 'connect' | 'once' | 'wait'

export type connection<a...> = {
	__q: queue<a...>;
	__id: number;
	__f: structFunc<a...>;
	__is_disconnected: boolean;

	disconnect: (self: connection<a...>) -> ();
} & RBXScriptConnection

local connection = {}

disguise = require(Objects.LuaUTypes).disguise

function connection.new<a...>(
	f: structFunc<a...>, id: number, q: queue<a...>): connection<a...>
	local self: connection<a...> = disguise(setmetatable({}, connection))
	self.__id = id;
	self.__f = f
	self.__q = q
	
	return self
end

function connection.disconnect<a...>(self: connection<a...>)
	if self.__is_disconnected then return;end
	
	self.__is_disconnected = true
	
	for i, v in next, self.__q do
		if v.f == self.__f and v.id == self.__id then
			table.remove(self.__q, i)
			return
		end
	end
	
end

connection.Disconnect = connection.disconnect
connection.__index = connection

--###################################################################################
--###################################################################################
--###################################################################################

-- event
type queue<a...> = {
	{
		subject: eventSubjectTypes;
		f: structFunc<a...>;
		id: number
	}
};

export type event<a...> = {
	__availibleId: number;
	__queue: queue<a...>;
	isDestroyed: boolean;

	__insert: (self:event<a...>, eventSubjectTypes, structFunc<a...>) -> ();
	connect: (self: event<a...>, responder: structFunc<a...>) -> connection<a...>;
	once: (self: event<a...>,responder: structFunc<a...>) -> connection<a...>;
	wait: (self: event<a...>) -> a...;
} & RBXScriptSignal

local event = {}

local Class = require(Objects.Class)

function event.new<a...>(): event<a...>
	local object: event<a...> = disguise(setmetatable({}, event))
	object.__availibleId = 0;
	object.__queue = {}
	
	return object
end

function event.__tostring()return '(Event)'end

function event.__insert<a...>(self: event<a...>, ev, f)
	assert(not self.isDestroyed, 'Attempting to use destroyed object')
	
	self.__availibleId += 1
	table.insert(self.__queue, {
		subject = ev;
		f = f;
		id = self.__availibleId
	})
end

function event.connect<a...>(self: event<a...>, f)
	self:__insert('connect', f)
	
	return connection.new(f, self.__availibleId, self.__queue)
end

function event.wait<a...>(self:event<a...>)
	local thread = coroutine.running()
	
	self:__insert('wait', function(...)
		coroutine.resume(thread,...)
	end)
	
	return coroutine.yield(thread)
end

function event.once<a...>(self:event<a...>, f)
	self:__insert('once', f)

	return connection.new(f, self.__availibleId, self.__queue)
end

event.ConnectParallel = Class.unimplemented
event.Connect = event.connect
event.Wait = event.wait
event.Once = event.once
event.__index = event

--###################################################################################
--###################################################################################
--###################################################################################

-- package
export type package<a...> = {
	event: event<a...>;

	fire: (self:package<a...>, a...) -> ();
} & Destructable.object

local package = {}

function package.new<a...>(): package<a...>
	local object: package<a...> = disguise(setmetatable({}, package))

	object.event = event.new()

	return object
end

function package.__tostring()return '(EventPackage)'end


function package.destroy<a...>(self: package<a...>)
	if self.isDestroyed then return end
	
	self.isDestroyed = true
	self.event.isDestroyed = true
	self.event = disguise()
end

function package.fire<a...>(self:package<a...>, ...:a...)
	assert(not self.isDestroyed, 'Attempting to use destroyed value.')
	
	local i = 1
	local q = self.event.__queue
	
	while i <= #q do
		local v = q[i]
		
		v.f(...)
		
		if v.subject ~= 'connect' then
			table.remove(q, i)
			i -= 1
		end
		
		i += 1
	end
end

package.__index = package

return package
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX4CBA63E62FE54954B24C1838A2804DE2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">@CHL/Destructable</string>
					<string name="ScriptGuid">{BD89B706-1B95-4993-8B31-6FF9E7060849}</string>
					<ProtectedString name="Source"><![CDATA[type __object = {
	isDestroyed: boolean;
	destroy: (self: __object) -> nil;
	Destroy: (self: __object) -> nil;
	assertDestruction: (self: __object) -> nil;
}
export type object = __object

local module = {}

module.destroy = function(self: __object)self.isDestroyed = true;end
module.Destroy = module.destroy
module.assertDestruction = function(self: __object)
	assert(
		not self.isDestroyed, 
		'Attempting to destroy a destroyed object.'
	)
end

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXE4E615F3A5114051AA66385070B2C6A9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LuaUTypes</string>
					<string name="ScriptGuid">{E3A08FCA-325B-4F62-95B4-05DB179CE2AE}</string>
					<ProtectedString name="Source"><![CDATA[--// metatable indices
export type metatableIndices = '__index' |'__newindex' | '__call' | '__concat' | 
'__unm' | '__add' | '__sub' | '__mul' | '__div' | '__idiv' | '__mod' | 
'__pow' | '__tostring' | '__metatable' | '__eq' | '__lt' | '__le' | 
'__mode' | '__gc' | '__len' | '__iter'

local module = {}

function same<A...>(...: A...): A... return ... end
function disguise<A...>(...: any) : A... return same(...) end
function empty()end

--#######################################################################################
--#######################################################################################
--#######################################################################################

--// metatable type
type __binaryOp<__self> = (<__in, __out>(__self, __in) -> __out)?;
type __logicalOp<__self> = (<__in>(__self, __in) -> any?)?

export type metatable<__self> = typeof({
	__index = disguise() :: (
		{[any]: any} | -- needs work
			<I,V>(__self, I) -> V
	)?;
	__newindex = disguise() :: (<I, V>(__self, I, V) -> nil)?;
	__call = disguise() :: (<__in..., __out...>(__self, __in...) -> __out...)?;
	__concat = disguise() :: __binaryOp<__self>;
	__unm = disguise() :: (<A>(__self) -> A)?;

	__add = disguise() :: __binaryOp<__self>;
	__sub = disguise() :: __binaryOp<__self>;
	__mul = disguise() :: __binaryOp<__self>;
	__div = disguise() :: __binaryOp<__self>;
	__idiv = disguise() :: __binaryOp<__self>;

	__mod = disguise() :: __binaryOp<__self>;
	__pow = disguise() :: __binaryOp<__self>;
	__tostring = disguise() :: ((__self) -> string)?;
	__metatable = disguise() :: any?;
	__eq = disguise() :: __logicalOp<__self>;

	__lt = disguise() :: __logicalOp<__self>;
	__le = disguise() :: __logicalOp<__self>;
	__mode = disguise() :: ('k' | 'v' | 'kv')?; -- needs check
	__len = disguise() :: ((__self) -> number)?;
	__iter = disguise() :: (<__out...>(__self) -> () -> __out...)?
}
-- :: {[__metatableIndices]: any}
)

--// theoretical object
--// !!! subjected to change because this way is terrible because intersection 
--// operation 
--// conflicts with metatmethods, so this is more like a temproary solution
export type __legacyObject<metamethods> = typeof(
	setmetatable({},disguise{} :: metamethods)
)

--#######################################################################################
--#######################################################################################
--#######################################################################################



--#######################################################################################
--#######################################################################################
--#######################################################################################

--// methods
module.assertify = function<A>(val: A?): A return disguise(val)end
module.disguise = disguise
module.same = same
module.empty = empty
module.metamethods = {
	'__index', '__newindex',  '__call',  '__concat',  
	'__unm',  '__add',  '__sub',  '__mul',  '__div',  '__idiv',  '__mod',  
	'__pow',  '__tostring',  '__metatable',  '__eq',  '__lt',  '__le',  
	'__mode',  '__gc',  '__len',  '__iter'
}

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX1BAC62218F254F25877DDE7F7FDEBA18">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Class</string>
					<string name="ScriptGuid">{71C555EC-3B69-40EA-BE37-65B1C4F8A805}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	more modifications of such:
	 * bug fixes
	 * __super strictly checks methods from self and up within method contexting
	 * __proxy<a> and __method<a>
]]
--// TYPES
type __subclass<super> = super & {
	__supers: {super};
	__super: super;
}
export type subclass<A> = __subclass<A>

type __function = (...any) -> ...any

type __super<A> = {
	__object: A & __subclass<A>;
	__class: {[string]:__function};
	__super: __super<A>;

	__get_i: (self:__super<A>) -> nil;
}

type __class = {[string]: __function}

type __method<A> = {
	__proxy: __proxy<A>;
	__func: __function;
	__class: __class?;
	__name: string?;
}

type __proxy<A> = {
	__object: A;
	__is_super: boolean;
	__super: __proxy<A>;
	__super_cached: __proxy<A>;
	__class: __class;

	__get_class_i: (self: __proxy<A>) -> number;
	__get_super_class: (self:__proxy<A>) -> __class?;
	__get_method: (self:__proxy<A>, name: string) -> __method<A>;
	__clone: (self:__proxy<A>) -> __proxy<A>;
	__get_value: <V>(self: __proxy<A>, i: string) -> V;
}

--// MAIN
local Class = {}
local Objects = script.Parent
local LuaUTypes = require(Objects.LuaUTypes)

disguise = LuaUTypes.disguise
find = table.find
clone = table.clone
insert = table.insert

local Method = {}

local Proxy = {}
Proxy.__index = function<A>(self: __proxy<A>, i: string)
	-- needs super and method handling
	-- self.__super
	if i == '__super' then
		local __super_class = self:__get_super_class()
		if not __super_class then return end;

		local __super: __proxy<A> = disguise(Proxy).new(self.__object, __super_class)
		rawset(self,'__super', __super)
		__super.__is_super = true

		return __super
	end

	-- self index
	local self_val = rawget(self,i) or Proxy[i]

	if self_val ~= nil then return self_val end

	-- self.__object methods
	local method = self:__get_method(i)
	if method then return method end

	-- self.__object regular values
	local val = self:__get_value(i)

	if val ~= nil then return val end
end
Proxy.__newindex = function<A>(self: __proxy<A>, i: string, v:any)
	rawset(disguise(self).__object, i, v)
end
Proxy.new = function<A>(object: A, class)
	local self: __proxy<A> = disguise(setmetatable({
		__object = object;
		__class = class;
		__is_super = false;
		__is_proxy = true;
	}, Proxy))

	return self
end
Proxy.__get_class_i = function<A>(self: __proxy<A>)
	return assert(
		find(
			rawget(
				disguise(self).__object, 
				'__supers'
			), 
			self.__class
		)
	)
end
function Proxy.__get_super_class<A>(self:__proxy<A>)
	local i = self:__get_class_i()

	for j = i - 1, 1, -1 do
		local class = disguise(self.__object).__supers[j]

		if type(class) == 'table' then
			return class
		end
	end
end
function Proxy.__get_method<A>(self:__proxy<A>,name: string)
	local supers = disguise(self.__object).__supers
	local start = self.__is_super and self:__get_class_i() or #supers

	-- get method
	local j
	local m
	for i = start, 1, -1 do
		local superclass = supers[i]
		if type(superclass) ~= 'table' then continue end;
		
		local fn = superclass[name]
		
		if type(fn) == 'function' then
			j = superclass
			m = fn
			break
		end
	end

	-- check method existance
	if not m then return end

	-- return psuedo method
	local clone = self:__clone()
	clone.__class = j

	return disguise(Method).new(clone,m,j,name)
end
function Proxy.__clone<A>(self:__proxy<A>)
	return Proxy.new(self.__object, self.__class)
end

function Proxy.__get_value<A, B>(self: __proxy<A>, name: string): B
	local v = rawget(disguise(self.__object),name)
	if v ~= nil then return v;end
	
	local supers = disguise(self.__object).__supers
	local start = self.__is_super and self:__get_class_i() or #supers
	
	-- get method
	
	for i = start, 1, -1 do
		local superclass = supers[i]
		if type(superclass) ~= 'table' then continue end;

		local v = superclass[name]
		if type(v) == 'function' then continue end
		
		return v
	end
	return disguise()
end

Method.__index = Method
Method.__call = function<A>(self: __method<A>,_ ,...)
	--[[
	local a, b = ...
	if type(a) == 'number' and typeof(b) == 'Vector3' then
		print('c',self)
	end
	--]]
	
	return self.__func(self.__proxy, ...)
end

Method.new = function<A>(object: A, func: __function, class:__class?,name: string?)
	local self: __method<A> = disguise(setmetatable({}, Method))
	self.__proxy = disguise(object);
	self.__func = func
	self.__class = class
	self.__name = name

	return self
end

--##################################################################################
--##################################################################################
--##################################################################################

function getLatestFunction<A>(self: __subclass<A>, i: string)
	if i == '__supers' and not rawget(self,'__supers') then return end

	local supers = self.__supers
	local first = supers[#supers]

	-- first method always returned raw
	local first_check = first.__index
	
	if type(first_check) == 'table' and first_check[i] then
		return first_check[i]
	elseif typeof(first_check) == 'function' then
		local got = first_check(self, i)
		if got then return got end
	end
	
	-- upper class methods returned psuedo
	for j = #supers - 1, 1, -1 do
		local class = supers[j]
		local __indexF = class.__index
		
		if not (typeof(__indexF) == 'table' ) then 
			if type(__indexF) == 'function' then
				if __indexF == getLatestFunction then
					print(self,supers)
					error('Attempted to recurse: using getLatestFunction within .__supers')
				end
				
				return __indexF(self, i)
			end
			continue;
		end

		local m = class[i]
		if not m then continue end;

		return Method.new(Proxy.new(self, class), m, class, i)
	end
end

function other(s: string)
	return function<A>(self: subclass<A>, ...)
		local fn = disguise(self)[s]
		
		if not fn then
			error(`Attempting to use operation on uninoperable object: {s}`)
		end
		
		return fn(self, ...)
	end
end

mainMeta = {__index = getLatestFunction}
specialMeta = ('__mode,__metatable,__newindex,__tostring,__index'):split(',')
overwritableMeta = ('__newindex,__tostring'):split(',')

for _, v in next,LuaUTypes.metamethods do
	if find(specialMeta, v) then continue end
	
	mainMeta[v] = other(v)
end

function inherit<A, B>(t: A, methods, is_debugging): B-- __subclass<A>
	if disguise(t).__is_proxy == true then
		t = disguise(t).__object
	end
	
	local _t = disguise(t)
	local result: __subclass<A> = disguise(_t)
	
	local supers = rawget(result,'__supers') or {}; 
	rawset(result,"__supers", supers)
	
	-- metatable evaluation
	local metatable = getmetatable(disguise(result))
	
	if not metatable then setmetatable(_t, mainMeta)
	elseif metatable.__index ~= getLatestFunction then
		if metatable then
			insert(supers, metatable.__index)
		end
		
		local new_metatable = mainMeta
		
		if metatable then
			local didClone = new_metatable.__is_clone
			
			for _, v in next, overwritableMeta do
				if not metatable[v] then continue end
				
				if not didClone then
					new_metatable = clone(new_metatable)
					didClone = true
				end
				
				new_metatable[v] = other(v)
			end
			
			new_metatable.__is_clone = didClone
		end
		
		setmetatable(_t, new_metatable)
	end
	
	if methods then
		insert(supers, methods)
		
		local meta = getmetatable(_t)
		local did_clone = meta.__is_clone
		
		for _, v in next, overwritableMeta do
			if not (methods[v] and not meta[v]) then continue; end
			
			if not did_clone then
				meta = clone(meta)
				did_clone = true
			end

			meta[v] = other(v)		
		end
		
		meta.__is_clone = did_clone
		setmetatable(_t, meta)
	end
	
	--[[] ]
	if new_metat then
		setmetatable(disguise(result), new_metat) -- do something here later?
	end
	--]]
	
	-- set up self.__super
	for i = #supers - 1, 1, -1 do
		local class = supers[i]

		if type(class) == 'table'then
			local super = Proxy.new(result, class)
			super.__is_super = true
			rawset(result, '__super', super)
			break;
		end
	end

	return _t
end

function isClass(obj, class)
	local supers = obj.__supers

	if not supers then
		return getmetatable(obj) == class
	end

	return supers[#supers] == class
end

function isProperClass(CLASS): (boolean, number?, string?)
	if not CLASS.__index then return false, 1, 'CLASS.__index is falsy.'
	elseif type(CLASS.className) ~= 'string' then 
		return false, 2, 'CLASS.className is not a string.'
	end
	
	return true
end

function hasClass(obj, class)
	return isClass(obj, class) or 
		obj.__supers and not not find(obj.__supers, class)
end

function getErrorFunc(s: string) return function() error(s) end end

function makeProperClass<A>(CLASS: A, name: string)
	local c = disguise(CLASS)
	if not c.__index then
		c.__index = c
	end
	
	c.className = assert(name)
end

--########################################################################################
--########################################################################################
--########################################################################################

--Class.getLatestFunction = getLatestFunction
Class.isProperClass = isProperClass
Class.inherit = inherit
Class.isClass = isClass
Class.hasClass = hasClass
Class.abstractMethod = getErrorFunc'Attempting to use abstract method.'
Class.unimplemented = getErrorFunc'Attempting to use an unimplemented method.'
Class.makeProperClass = makeProperClass

return Class
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX24F154D6424B4291AFA00928CD78397A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">@CHL/Map</string>
					<string name="ScriptGuid">{3769CE7B-8050-436A-9055-9DF249D89230}</string>
					<ProtectedString name="Source"><![CDATA[local Objects = script.Parent
local module = {}
local Dash = require(Objects["@CHL/DashSingular"])
module.__index = module

--#####################################################################################
--#####################################################################################
--#####################################################################################
export type simple<I,V> = Dash.Map<I, V>

simple = {}

function flipArray<A>(a: {A}): simple<A, number>
	return Dash.collect(a, function(a0: number, a1)return a1, a0  end)
end

module.simple = simple
module.simple.flipArray = flipArray

--#####################################################################################
--#####################################################################################
--#####################################################################################
export type dictionary<T> = simple<string, T>


return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>